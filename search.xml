<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Drone与GitLab实现Laravel项目自动构建、自动部署</title>
      <link href="/posts/464192a3.html"/>
      <url>/posts/464192a3.html</url>
      
        <content type="html"><![CDATA[<p><a name="oKAoc"></a></p><h2 id="Laravel-项目目录结构"><a href="#Laravel-项目目录结构" class="headerlink" title="Laravel 项目目录结构"></a>Laravel 项目目录结构</h2><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── <span class="hljs-selector-class">.drone</span><span class="hljs-selector-class">.yml</span><br>├── <span class="hljs-selector-class">.editorconfig</span><br>├── <span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.example</span><br>├── <span class="hljs-selector-class">.git</span><br>├── <span class="hljs-selector-class">.gitattributes</span><br>├── <span class="hljs-selector-class">.gitignore</span><br>├── <span class="hljs-selector-class">.gitlab-ci</span><span class="hljs-selector-class">.yml</span><br>├── <span class="hljs-selector-class">.idea</span><br>├── README<span class="hljs-selector-class">.md</span><br>├── app<br>├── artisan<br>├── bin<br>├── bootstrap<br>├── composer<span class="hljs-selector-class">.json</span><br>├── composer<span class="hljs-selector-class">.lock</span><br>├── config<br>├── database<br>├── docker<br>├── env<br>├── lang<br>├── package<span class="hljs-selector-class">.json</span><br>├── phpstan<span class="hljs-selector-class">.neon</span><br>├── phpunit<span class="hljs-selector-class">.xml</span><br>├── pint<span class="hljs-selector-class">.json</span><br>├── public<br>├── resources<br>├── routes<br>├── storage<br>├── tests<br>└── vite<span class="hljs-selector-class">.config</span>.js<br></code></pre></td></tr></tbody></table></figure><p><a name="BTR1c"></a></p><h3 id="docker-目录"><a href="#docker-目录" class="headerlink" title="docker 目录"></a>docker 目录</h3><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker<br>├── etc<br>│&nbsp;&nbsp; └── cron<br>├── nginx<br>│&nbsp;&nbsp; └── vhost.<span class="hljs-keyword">conf</span><br>├── prod<br>│&nbsp;&nbsp; ├── Dockerfile<br>│&nbsp;&nbsp; ├── docker-compose.yml<br>└── <span class="hljs-keyword">test</span><br>    ├── Dockerfile<br>    └── docker-compose.yml<br></code></pre></td></tr></tbody></table></figure><p><a name="RCdOo"></a></p><h4 id="prod-Dockerfile-文件"><a href="#prod-Dockerfile-文件" class="headerlink" title="prod/Dockerfile 文件"></a>prod/Dockerfile 文件</h4><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基础镜像</span><br><span class="hljs-keyword">FROM</span> webdevops/php-nginx:<span class="hljs-number">8.0</span>-alpine<br><br><span class="hljs-comment"># 安装所需的 PHP 扩展</span><br><span class="hljs-comment">#RUN apk update &amp;&amp; apk add --no-cache git gcc g++ make autoconf openssl-dev zlib-dev librdkafka-dev &amp;&amp; pecl install rdkafka &amp;&amp; docker-php-ext-enable rdkafka &amp;&amp; pecl install swoole-5.1.1 &amp;&amp; docker-php-ext-enable swoole</span><br><span class="hljs-comment">##    &amp;&amp; echo "swoole.use_shortname = 'Off'" &gt;&gt; /usr/local/etc/php/conf.d/docker-php-ext-swoole.ini</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#RUN apk del git gcc g++ make autoconf openssl-dev zlib-dev &amp;&amp; rm -rf /var/cache/apk/*</span><br><br><span class="hljs-comment"># 清除缓存</span><br><span class="hljs-comment">#RUN rm -rf /tmp/*</span><br><br><span class="hljs-comment"># php配置</span><br><span class="hljs-keyword">ENV</span> PHP_MEMORY_LIMIT  <span class="hljs-string">'2048M'</span><br><span class="hljs-keyword">ENV</span> PHP_POST_MAX_SIZE  <span class="hljs-string">'200M'</span><br><span class="hljs-keyword">ENV</span> PHP_UPLOAD_MAX_FILESIZE  <span class="hljs-string">'200M'</span><br><span class="hljs-keyword">ENV</span> PHP_MAX_EXECUTION_TIME  <span class="hljs-number">600</span><br><br><span class="hljs-comment">#nginx配置</span><br><span class="hljs-keyword">ENV</span> SERVICE_NGINX_CLIENT_MAX_BODY_SIZE  <span class="hljs-string">'200m'</span><br><br><span class="hljs-comment">#php-fpm配置</span><br><span class="hljs-keyword">ENV</span> FPM_PM_MIN_SPARE_SERVERS <span class="hljs-number">10</span><br><span class="hljs-keyword">ENV</span> FPM_PM_MAX_SPARE_SERVERS <span class="hljs-number">30</span><br><span class="hljs-keyword">ENV</span> FPM_PM_START_SERVERS <span class="hljs-number">10</span><br><span class="hljs-keyword">ENV</span> FPM_PM_MAX_CHILDREN <span class="hljs-number">150</span><br><span class="hljs-keyword">ENV</span> FPM_MAX_REQUESTS <span class="hljs-number">1000</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">ARG</span> LARAVEL_PATH=/app<br><br><span class="hljs-comment"># 复制 Laravel 应用代码到镜像中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . <span class="hljs-variable">${LARAVEL_PATH}</span></span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> docker/nginx/vhost.conf /opt/docker/etc/nginx/vhost.conf</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> docker/etc/cron /opt/docker/etc/cron/</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">rm</span> -rf  <span class="hljs-variable">${LARAVEL_PATH}</span>/.git</span><br><br><span class="hljs-comment"># 安装 Laravel 依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">set</span> -ex ; <span class="hljs-built_in">cd</span> <span class="hljs-variable">${LARAVEL_PATH}</span> \</span><br><span class="language-bash">      &amp;&amp; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ \</span><br><span class="language-bash">      &amp;&amp; composer install \</span><br><span class="language-bash">           --ignore-platform-reqs \</span><br><span class="language-bash">           --no-interaction \</span><br><span class="language-bash">           --no-plugins \</span><br><span class="language-bash">           --no-scripts \</span><br><span class="language-bash">           --prefer-dist \</span><br><span class="language-bash">           --no-dev</span><br><br><span class="hljs-comment"># 设置文件权限</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">set</span> -ex ; <span class="hljs-built_in">cd</span> <span class="hljs-variable">${LARAVEL_PATH}</span> \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">chmod</span> +x artisan \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">rm</span> -rf bootstrap/cache/* \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">mkdir</span> -p storage \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">mkdir</span> -p storage/framework/cache \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">mkdir</span> -p storage/framework/sessions \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">mkdir</span> -p storage/framework/testing \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">mkdir</span> -p storage/framework/views \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">mkdir</span> -p storage/logs \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">chmod</span> 0777 -R storage bootstrap/cache \</span><br><span class="language-bash">      &amp;&amp; <span class="hljs-built_in">cp</span> <span class="hljs-built_in">env</span>/.env.prod .<span class="hljs-built_in">env</span> \</span><br><span class="language-bash">      &amp;&amp; php artisan package:discover --ansi \</span><br><span class="language-bash">      &amp;&amp; php artisan config:cache \</span><br><span class="language-bash">      &amp;&amp; php artisan route:cache \</span><br><span class="language-bash">      &amp;&amp; php artisan view:cache</span><br><br></code></pre></td></tr></tbody></table></figure><p><a name="VQNuY"></a></p><h4 id="prod-docker-compose-yml-文件"><a href="#prod-docker-compose-yml-文件" class="headerlink" title="prod/docker-compose.yml 文件"></a>prod/docker-compose.yml 文件</h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.9'</span><br><span class="hljs-attr">services:</span><br>    <span class="hljs-attr">app:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-shenzhen.aliyuncs.com/thomas-hub/laravel-basic:latest</span><br>        <span class="hljs-attr">deploy:</span><br>            <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>            <span class="hljs-attr">restart_policy:</span><br>                <span class="hljs-attr">condition:</span> <span class="hljs-string">on-failure</span><br>                <span class="hljs-attr">delay:</span> <span class="hljs-string">5s</span><br>                <span class="hljs-attr">max_attempts:</span> <span class="hljs-number">5</span><br>            <span class="hljs-attr">update_config:</span><br>                <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span><br>                <span class="hljs-attr">delay:</span> <span class="hljs-string">10s</span><br>                <span class="hljs-attr">order:</span> <span class="hljs-string">start-first</span><br>        <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">"80:80"</span><br>        <span class="hljs-attr">networks:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">laravel-network</span><br>        <span class="hljs-attr">volumes:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/var/log/apps/laravel-basic/nginx/:/var/log/nginx/</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/var/log/apps/laravel-basic/storage/logs/:/app/storage/logs/</span><br><br><span class="hljs-attr">networks:</span><br>    <span class="hljs-attr">laravel-network:</span><br>        <span class="hljs-attr">driver:</span> <span class="hljs-string">overlay</span><br><br></code></pre></td></tr></tbody></table></figure><p><a name="N1OGI"></a></p><h4 id="nginx-vhost-conf-文件"><a href="#nginx-vhost-conf-文件" class="headerlink" title="nginx/vhost.conf 文件"></a>nginx/vhost.conf 文件</h4><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> {<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default;<br><br>  <span class="hljs-attribute">server_name</span> _;<br>  <span class="hljs-attribute">root</span> /app/public;<br><br>  <span class="hljs-attribute">access_log</span> /var/log/nginx/laravel-basic.access.log;<br>  <span class="hljs-attribute">error_log</span> /var/log/nginx/laravel-basic.log;<br><br>  <span class="hljs-attribute">add_header</span> X-Frame-Options <span class="hljs-string">"SAMEORIGIN"</span>;<br>  <span class="hljs-attribute">add_header</span> X-Content-Type-Options <span class="hljs-string">"nosniff"</span>;<br><br>  <span class="hljs-attribute">index</span> index.html index.php;<br><br>  <span class="hljs-attribute">charset</span> utf-<span class="hljs-number">8</span>;<br><br>  <span class="hljs-section">location</span> = /favicon.ico { <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>; <span class="hljs-attribute">log_not_found</span> <span class="hljs-literal">off</span>; }<br>  <span class="hljs-section">location</span> = /robots.txt  { <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>; <span class="hljs-attribute">log_not_found</span> <span class="hljs-literal">off</span>; }<br><br>  <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /index.php;<br><br>  <span class="hljs-attribute">include</span> /opt/docker/etc/nginx/vhost.common.d/<span class="hljs-regexp">*.conf</span>;<br><br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ /\.(?!well-known).*</span> {<br>    <span class="hljs-attribute">deny</span> all;<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p><a name="GkrSM"></a></p><h4 id="etc-cron-app-文件"><a href="#etc-cron-app-文件" class="headerlink" title="etc/cron/app 文件"></a>etc/cron/app 文件</h4><blockquote><p>注：此文件用于运行定时任务脚本</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">SHELL=/bin/bash<br><br><span class="hljs-comment"># m h dom mon dow   user   command</span><br>* * * * * application <span class="hljs-built_in">cd</span> /app &amp;&amp; /usr/local/bin/php artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1<br></code></pre></td></tr></tbody></table></figure><p><a name="h3Xq7"></a></p><h3 id="env-目录"><a href="#env-目录" class="headerlink" title="env 目录"></a>env 目录</h3><blockquote><p>注：这里所有环境的配置文件统一管理</p></blockquote><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">env<br>├── <span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.dev</span><br>├── <span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.local</span><br>├── <span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.prod</span><br>└── <span class="hljs-selector-class">.env</span>.test<br></code></pre></td></tr></tbody></table></figure><p><a name="NiZIF"></a></p><h2 id="配置-GitLab"><a href="#配置-GitLab" class="headerlink" title="配置 GitLab"></a>配置 GitLab</h2><p><a name="mESaI"></a></p><h3 id="创建-GitLab-Application"><a href="#创建-GitLab-Application" class="headerlink" title="创建 GitLab Application"></a>创建 GitLab Application</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717398165383-c515db09-3e77-4be4-a51a-f0ca54eb527f.png#averageHue=%23b2df84&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=772&amp;id=u78590d3d&amp;originHeight=1544&amp;originWidth=4066&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=420443&amp;status=done&amp;style=none&amp;taskId=u6b91ddf7-d97b-4774-980c-5e448bb78d7&amp;title=&amp;width=2033" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717398230425-03c2eb8e-974b-47b8-8bd6-fd2a5bbd681b.png#averageHue=%23ed5c28&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=756&amp;id=u97159daa&amp;originHeight=1512&amp;originWidth=2864&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=408983&amp;status=done&amp;style=none&amp;taskId=u9341f239-ee8c-4408-912b-6ed8f7fe5b6&amp;title=&amp;width=1432" alt="image.png"><br>最后Save applications即可，保存后，记下相关信息，安装drone会用到。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717399420734-901ecb32-18b3-413c-83de-2b0a3a107c54.png#averageHue=%23fefcfb&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=703&amp;id=u206cc164&amp;originHeight=1406&amp;originWidth=4040&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=347897&amp;status=done&amp;style=none&amp;taskId=u6fbe6355-beb8-4ee0-b5b2-c51e1ddef41&amp;title=&amp;width=2020" alt="image.png"><br><a name="DQH5N"></a></p><h3 id="创建-GitLab-Laravel-项目的-Integration"><a href="#创建-GitLab-Laravel-项目的-Integration" class="headerlink" title="创建 GitLab Laravel 项目的 Integration"></a>创建 GitLab Laravel 项目的 Integration</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717398479722-d4780771-d901-4ea8-bc87-7b8fba1dd7eb.png#averageHue=%234ac485&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=1157&amp;id=u71b05f14&amp;originHeight=2314&amp;originWidth=4072&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=695379&amp;status=done&amp;style=none&amp;taskId=u3e4c82f3-ddae-4960-8d56-31c6c6707e5&amp;title=&amp;width=2036" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717398557790-94198b73-aea8-4556-bfa4-3ba3c30a87cd.png#averageHue=%23ef6259&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=1067&amp;id=udc34347d&amp;originHeight=2134&amp;originWidth=4080&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=563908&amp;status=done&amp;style=none&amp;taskId=u770294ca-7fab-4826-b88c-0d12cfa1da1&amp;title=&amp;width=2040" alt="image.png"><br><a name="W54tM"></a></p><h2 id="部署-Drone-Server-服务"><a href="#部署-Drone-Server-服务" class="headerlink" title="部署 Drone Server 服务"></a>部署 Drone Server 服务</h2><blockquote><p>注： drone server 服务与 drone runner 服务分开不同服务器部署，且都支持 docker 环境</p></blockquote><p>drone有个Server和Runner(Agent)的概念，我们先来理解下：<br>Server：为Drone的管理提供了Web页面，用于管理从Git上获取的仓库中的流水线任务。<br>Runner(Agent)：一个单独的守护进程，会轮询Server，获取需要执行的流水线任务，之后执行。<br>drone-runner不是必选的，官方不推荐吧runner和server安装在一个实例上<br><a name="YOQti"></a></p><h3 id="创建共享密钥"><a href="#创建共享密钥" class="headerlink" title="创建共享密钥"></a>创建共享密钥</h3><blockquote><p>注：生产共享密钥，用于连接Server和Runner之间，两者需一致。</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl rand -hex 16<br>8141566fc1aa1a8815f7b5a1bae671b8<br></code></pre></td></tr></tbody></table></figure><p><a name="NJp4O"></a></p><h3 id="创建-data-目录"><a href="#创建-data-目录" class="headerlink" title="创建 data 目录"></a>创建 data 目录</h3><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/usr/</span>docker<span class="hljs-regexp">/drone-server/</span>data<br></code></pre></td></tr></tbody></table></figure><p><a name="X9Qqq"></a></p><h3 id="创建-docker-compose-yml-文件"><a href="#创建-docker-compose-yml-文件" class="headerlink" title="创建 docker-compose.yml 文件"></a>创建 docker-compose.yml 文件</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.7"</span><br> <br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">drone-server:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">drone/drone:2.20.0</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">drone-server</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">'4000:80'</span>      <span class="hljs-comment"># Web管理面板的入口 PROTO=http  时使用该端口</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span>   <span class="hljs-comment"># docker.sock [1]</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/server:/data</span>            <span class="hljs-comment"># drone数据存放路径</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_AGENTS_ENABLED=true</span>                   <span class="hljs-comment"># 使用Runner</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITLAB_SERVER=${DRONE_GITLAB_SERVER}</span>                     <span class="hljs-comment"># gitlab的地址</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITLAB_CLIENT_ID=${DRONE_GITLAB_CLIENT_ID}</span>          <span class="hljs-comment"># gitlab获得的ClientID</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITLAB_CLIENT_SECRET=${DRONE_GITLAB_CLIENT_SECRET}</span>  <span class="hljs-comment"># gitlab获得的ClientSecret</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RPC_SECRET=${DRONE_RPC_SECRET}</span>                      <span class="hljs-comment"># RPC秘钥     [2]</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_SERVER_HOST=${DRONE_SERVER_HOST}</span>                    <span class="hljs-comment"># RPC域名(在一个实例上可以不用)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_SERVER_PROTO=${DRONE_SERVER_PROTO}</span>                  <span class="hljs-comment"># git webhook使用的协议(建议http)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_OPEN=true</span>                                           <span class="hljs-comment"># 开发drone</span><br>      <span class="hljs-comment">#- DRONE_DATABASE_DATASOURCE=/var/lib/drone/drone.sqlite     # 数据库文件</span><br>      <span class="hljs-comment">#- DRONE_DATABASE_DRIVER=sqlite3                             # 数据库驱动，我这里选的sqlite</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_DEBUG=true</span>                                          <span class="hljs-comment"># 调试相关，部署的时候建议先打开</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_LOGS_DEBUG=true</span>                                     <span class="hljs-comment"># 调试相关，部署的时候建议先打开</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_LOGS_TRACE=true</span>                                     <span class="hljs-comment"># 调试相关，部署的时候建议先打开</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_ADMIN=${DRONE_ADMIN}</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_USER_CREATE=username:${DRONE_ADMIN},admin:true</span>          <span class="hljs-comment"># 初始管理员用户</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RUNNER_PRIVILEGED_IMAGES=plugins/docker</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RUNNER_PRIVILEGED=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span>                                          <span class="hljs-comment"># 时区</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></tbody></table></figure><p><a name="zhFIX"></a></p><h3 id="创建-env-文件"><a href="#创建-env-文件" class="headerlink" title="创建.env 文件"></a>创建.env 文件</h3><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">DRONE_GITLAB_SERVER</span>=<span class="hljs-string">https://gitlab.com</span><br><span class="hljs-attr">DRONE_GITLAB_CLIENT_ID</span>=<span class="hljs-string">b281a70e999a13f471c771441775a86ef83477c0912094f6038d322e56cc78e1</span><br><span class="hljs-attr">DRONE_GITLAB_CLIENT_SECRET</span>=<span class="hljs-string">gloas-0b76517c97f0d00d6a73d79ebc69918313206a497f58a57d153b6bfc87515e6c</span><br><span class="hljs-attr">DRONE_RPC_SECRET</span>=<span class="hljs-string">8141566fc1aa1a8815f7b5a1bae671b8</span><br><span class="hljs-attr">DRONE_SERVER_HOST</span>=<span class="hljs-string">14.103.55.227:4000</span><br><span class="hljs-attr">DRONE_SERVER_PROTO</span>=<span class="hljs-string">http</span><br><span class="hljs-attr">DRONE_RPC_HOST</span>=<span class="hljs-string">14.103.55.227:4000</span><br><span class="hljs-attr">DRONE_RPC_PROTO</span>=<span class="hljs-string">http</span><br><span class="hljs-attr">DRONE_ADMIN</span>=<span class="hljs-string">chendujin</span><br></code></pre></td></tr></tbody></table></figure><p><a name="EABbN"></a></p><h3 id="目录结构概览"><a href="#目录结构概览" class="headerlink" title="目录结构概览"></a>目录结构概览</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── data<br>│   └── server<br>│       └── database.sqlite<br>├── docker-compose.yml<br>└── .<span class="hljs-built_in">env</span><br></code></pre></td></tr></tbody></table></figure><p><a name="z78AX"></a></p><h3 id="启动-Drone-Server-服务"><a href="#启动-Drone-Server-服务" class="headerlink" title="启动 Drone Server 服务"></a>启动 Drone Server 服务</h3><blockquote><p>注：在/usr/docker/drone-server 目录下执行</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></tbody></table></figure><p><a name="wvH9i"></a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Drone 用户名需和gitlab登录用户一致，才会有Project Setting选项，我的 gitlab和drone都是 chendujin 可见。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717399737470-1a7c4b5e-f0d8-4f40-b4d1-54566d301d12.png#averageHue=%2312161b&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=581&amp;id=u5d9e818b&amp;originHeight=1162&amp;originWidth=2543&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=203802&amp;status=done&amp;style=none&amp;taskId=u4a64cdb9-e86f-4c12-995c-2938e70fde8&amp;title=&amp;width=1271.5" alt="image.png"><br><a name="lD1TH"></a></p><h2 id="登录-Drone-控制面板"><a href="#登录-Drone-控制面板" class="headerlink" title="登录 Drone 控制面板"></a>登录 Drone 控制面板</h2><p>浏览器访问14.103.55.227:4000，点击继续Continue，自动跳转gitlab，授权即可进入drone。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717399995176-fa2d3615-5545-413f-a332-01a67cfd4caa.png#averageHue=%2304ace2&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=308&amp;id=u76c50e86&amp;originHeight=615&amp;originWidth=2552&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=124253&amp;status=done&amp;style=none&amp;taskId=uadc92530-5373-4691-a6ae-c8bb2d82a0d&amp;title=&amp;width=1276" alt="image.png"><br>进入可看到gitlab所有项目，选择一个项目，进入点击activate 激活进入项目即可。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717400062595-7a4913b0-f805-4fd5-88a8-1d9c642291bd.png#averageHue=%2312171c&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=397&amp;id=uec62b0ee&amp;originHeight=794&amp;originWidth=2551&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=115670&amp;status=done&amp;style=none&amp;taskId=u519f9dfd-e339-41b5-ae45-4ebb39e3f0f&amp;title=&amp;width=1275.5" alt="image.png"><br>打开设置里面的 Truste 开关，允许容器挂载主机。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717401042644-c40175cc-1440-4b5c-b45e-d0e22f7fe344.png#averageHue=%23121619&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=538&amp;id=u1d1e0879&amp;originHeight=1075&amp;originWidth=2435&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=172876&amp;status=done&amp;style=none&amp;taskId=u5d0f60d6-7835-4eec-95bf-8f713100871&amp;title=&amp;width=1217.5" alt="image.png"><br><a name="VGIYN"></a></p><h2 id="部署-Drone-Runner-服务"><a href="#部署-Drone-Runner-服务" class="headerlink" title="部署 Drone Runner 服务"></a>部署 Drone Runner 服务</h2><p><a name="tSBwq"></a></p><h3 id="创建-Drone-Runner-目录"><a href="#创建-Drone-Runner-目录" class="headerlink" title="创建 Drone Runner 目录"></a>创建 Drone Runner 目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/docker/drone-runner<br></code></pre></td></tr></tbody></table></figure><p><a name="qX2GN"></a></p><h3 id="创建-docker-compose-yml-文件-1"><a href="#创建-docker-compose-yml-文件-1" class="headerlink" title="创建 docker-compose.yml 文件"></a>创建 docker-compose.yml 文件</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.7"</span><br> <br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">drone-runner:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">drone/drone-runner-docker:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">drone-runner</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RPC_HOST=${DRONE_RPC_HOST}</span>  <span class="hljs-comment"># RPC服务地址</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RPC_SECRET=${DRONE_RPC_SECRET}</span>  <span class="hljs-comment"># RPC秘钥</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RPC_PROTO=${DRONE_RPC_PROTO}</span>    <span class="hljs-comment"># RPC协议(http || https)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RUNNER_CAPACITY=2</span>               <span class="hljs-comment"># 最大并发执行的 pipeline 数</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RUNNER_NAME=drone-runner</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RUNNER_PRIVILEGED_IMAGES=plugins/docker</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_UI_USERNAME=${DRONE_UI_USERNAME}</span> <span class="hljs-comment"># 设置 Drone Runner 的 UI 用户账号</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_UI_PASSWORD=${DRONE_UI_PASSWORD}</span> <span class="hljs-comment"># 设置 Drone Runner 的 UI 用户密码</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RUNNER_PRIVILEGED=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_DEBUG=true</span>                      <span class="hljs-comment"># 调试相关，部署的时候建议先打开</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_LOGS_DEBUG=true</span>                 <span class="hljs-comment"># 调试相关，部署的时候建议先打开</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_LOGS_TRACE=true</span>                 <span class="hljs-comment"># 调试相关，部署的时候建议先打开</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></tbody></table></figure><p><a name="VF8P1"></a></p><h3 id="创建-env-文件-1"><a href="#创建-env-文件-1" class="headerlink" title="创建.env 文件"></a>创建.env 文件</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">DRONE_RPC_SECRET=8141566fc1aa1a8815f7b5a1bae671b8<br>DRONE_RPC_HOST=14.103.55.227:4000<br>DRONE_RPC_PROTO=http<br>DRONE_UI_USERNAME=thomas<br>DRONE_UI_PASSWORD=thomas1213.<br></code></pre></td></tr></tbody></table></figure><p><a name="uU6ox"></a></p><h3 id="目录结构概览-1"><a href="#目录结构概览-1" class="headerlink" title="目录结构概览"></a>目录结构概览</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">├── docker-compose.yml<br>└── .env<br></code></pre></td></tr></tbody></table></figure><p><a name="NFCEV"></a></p><h3 id="启动-Drone-Runner-服务"><a href="#启动-Drone-Runner-服务" class="headerlink" title="启动 Drone Runner 服务"></a>启动 Drone Runner 服务</h3><blockquote><p>注：在/usr/docker/drone-runner 目录下执行</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></tbody></table></figure><p><a name="DkuqQ"></a></p><h2 id="配置-Laravel-项目的-drone-yml-文件"><a href="#配置-Laravel-项目的-drone-yml-文件" class="headerlink" title="配置 Laravel 项目的 .drone.yml 文件"></a>配置 Laravel 项目的 .drone.yml 文件</h2><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">pipeline</span> <span class="hljs-comment"># 定义一个管道</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">docker</span> <span class="hljs-comment"># 当前管道的类型</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">drone-laravel-demo</span> <span class="hljs-comment"># 当前管道的名称</span><br><br><span class="hljs-attr">platform:</span><br>  <span class="hljs-attr">os:</span> <span class="hljs-string">linux</span><br>  <span class="hljs-attr">arch:</span> <span class="hljs-string">amd64</span><br><br><span class="hljs-attr">workspace:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/drone/src</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker_sock</span><br>    <span class="hljs-attr">host:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/var/run/docker.sock</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cache</span><br>    <span class="hljs-attr">host:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/var/cache</span><br><br><span class="hljs-attr">clone:</span><br>  <span class="hljs-attr">disable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#禁用默认克隆</span><br><br><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">克隆代码</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">plugins/git</span><br>    <span class="hljs-attr">when:</span><br>      <span class="hljs-attr">branch:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br><span class="hljs-comment">#  - name: 加载缓存 # 加载缓存</span><br><span class="hljs-comment">#    pull: if-not-exists # 如果镜像不存在则拉取,免去每次都要重新下载</span><br><span class="hljs-comment">#    image: drillster/drone-volume-cache</span><br><span class="hljs-comment">#    settings:</span><br><span class="hljs-comment">#      restore: true</span><br><span class="hljs-comment">#      mount:</span><br><span class="hljs-comment">#        - /var/cache</span><br><span class="hljs-comment">#      key: ${DRONE_REPO}_${DRONE_BRANCH}_${DRONE_COMMIT_SHA}</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">构建镜像</span><br>    <span class="hljs-attr">pull:</span> <span class="hljs-string">if-not-exists</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">plugins/docker</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 启用特权模式</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">DOCKER_BUILDKIT:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">settings:</span><br>      <span class="hljs-attr">purge:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">use_cache:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">docker/prod/Dockerfile</span> <span class="hljs-comment"># Dockerfile地址， 注意是相对地址</span><br>      <span class="hljs-attr">registry:</span>   <span class="hljs-comment">#镜像仓库域名</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">registry_url</span><br>      <span class="hljs-attr">repo:</span>        <span class="hljs-comment">#镜像仓库详细地址</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">registry_repo</span><br>      <span class="hljs-attr">tags:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">latest</span><br>      <span class="hljs-attr">username:</span>    <span class="hljs-comment">#镜像仓库账户</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">registry_user_name</span><br>      <span class="hljs-attr">password:</span>    <span class="hljs-comment">#镜像仓库密码</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">registry_password</span><br>      <span class="hljs-attr">cache_from:</span>  <span class="hljs-comment">#镜像缓存</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">registry_cache</span><br>      <span class="hljs-attr">command_timeout:</span> <span class="hljs-string">5m</span><br>      <span class="hljs-attr">mirrors:</span> <span class="hljs-string">https://4t16iqyd.mirror.aliyuncs.com</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker_sock</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/var/run/docker.sock</span><br>    <span class="hljs-attr">when:</span><br>      <span class="hljs-attr">branch:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br><span class="hljs-comment">#  - name: 构建缓存   # 构建缓存</span><br><span class="hljs-comment">#    image: drillster/drone-volume-cache</span><br><span class="hljs-comment">#    settings:</span><br><span class="hljs-comment">#      rebuild: true</span><br><span class="hljs-comment">#      mount:</span><br><span class="hljs-comment">#        - /var/cache</span><br><span class="hljs-comment">#      key: ${DRONE_REPO}_${DRONE_BRANCH}_${DRONE_COMMIT_SHA}</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">部署镜像</span><br>    <span class="hljs-attr">pull:</span> <span class="hljs-string">if-not-exists</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">plugins/docker</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 启用特权模式</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker_sock</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/var/run/docker.sock</span><br>    <span class="hljs-attr">settings:</span><br>      <span class="hljs-attr">swarm:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">swarm_stack:</span> <span class="hljs-string">swarm-app</span><br>      <span class="hljs-attr">swarm_services:</span> <span class="hljs-string">app</span><br>      <span class="hljs-attr">insecure:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">registry:</span> <span class="hljs-string">registry_repo</span><br>      <span class="hljs-attr">username:</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">registry_user_name</span><br>      <span class="hljs-attr">password:</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">registry_password</span><br>      <span class="hljs-attr">mirrors:</span> <span class="hljs-string">https://4t16iqyd.mirror.aliyuncs.com</span><br>    <span class="hljs-attr">commands:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ls</span> <span class="hljs-string">-alh</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">stack</span> <span class="hljs-string">deploy</span> <span class="hljs-string">-c</span> <span class="hljs-string">docker/prod/docker-compose.yml</span> <span class="hljs-string">--with-registry-auth</span> <span class="hljs-string">--resolve-image</span> <span class="hljs-string">always</span> <span class="hljs-string">swarm</span><br>    <span class="hljs-attr">when:</span><br>      <span class="hljs-attr">branch:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">飞书通知</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">ydq1234/drone-lark</span><br>    <span class="hljs-attr">settings:</span><br>      <span class="hljs-attr">webhook:</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">feishu_token</span><br>      <span class="hljs-attr">secret:</span><br>        <span class="hljs-attr">from_secret:</span> <span class="hljs-string">feishu_secret</span><br>      <span class="hljs-attr">debug:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">when:</span><br>        <span class="hljs-attr">status:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">success</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">failure</span><br><br>  <span class="hljs-comment"># - name: 邮箱通知 # 邮件通知</span><br>  <span class="hljs-comment">#   pull: if-not-exists # 如果镜像不存在则拉取,免去每次都要重新下载</span><br>  <span class="hljs-comment">#   image: drillster/drone-email</span><br>  <span class="hljs-comment">#   settings:</span><br>  <span class="hljs-comment">#     recipients_only: true # 只发送给指定邮件收件人，不默认发送给流水线创建人</span><br>  <span class="hljs-comment">#     host: smtp.qq.com #SMTP服务器 例如 smtp.qq.com</span><br>  <span class="hljs-comment">#     port: 465 #SMTP服务端口  例如QQ邮箱端口465</span><br>  <span class="hljs-comment">#     subject: "Drone Build Notification!"</span><br>  <span class="hljs-comment">#     username: #邮箱用户名</span><br>  <span class="hljs-comment">#       from_secret: email_username</span><br>  <span class="hljs-comment">#     password: #邮箱密码</span><br>  <span class="hljs-comment">#       from_secret: email_passwd</span><br>  <span class="hljs-comment">#     from:</span><br>  <span class="hljs-comment">#       from_secret: email_username</span><br>  <span class="hljs-comment">#     recipients:</span><br>  <span class="hljs-comment">#       - 13728656748@163.com #收件人邮箱</span><br>  <span class="hljs-comment">#       - chendujin@zujibao.net</span><br>  <span class="hljs-comment">#   when:</span><br>  <span class="hljs-comment">#     status:</span><br>  <span class="hljs-comment">#       - success</span><br>  <span class="hljs-comment">#       - failure</span><br><br>  <span class="hljs-comment"># - name: 企微通知</span><br>  <span class="hljs-comment">#   pull: if-not-exists</span><br>  <span class="hljs-comment">#   image: plugins/webhook</span><br>  <span class="hljs-comment">#   settings:</span><br>  <span class="hljs-comment">#     urls:</span><br>  <span class="hljs-comment">#       from_secret: wechat_webhook_url</span><br>  <span class="hljs-comment">#     content_type: application/json</span><br>  <span class="hljs-comment">#     template: |</span><br>  <span class="hljs-comment">#       {</span><br>  <span class="hljs-comment">#         "msgtype": "markdown",</span><br>  <span class="hljs-comment">#         "markdown": {</span><br>  <span class="hljs-comment">#             "content": "{{#success build.status}}✅{{else}}❌{{/success}}**{{ repo.owner }}/{{ repo.name }}** (Build #{{build.number}})\n</span><br>  <span class="hljs-comment">#                         &gt;**构建结果**: {{ build.status }}</span><br>  <span class="hljs-comment">#                         &gt;**构建耗时**: {{since build.started}}</span><br>  <span class="hljs-comment">#                         &gt;**构建详情**: [点击查看]({{ build.link }})</span><br>  <span class="hljs-comment">#                         &gt;**代码分支**: {{ build.branch }}</span><br>  <span class="hljs-comment">#                         &gt;**提交标识**: {{ build.commit }}</span><br>  <span class="hljs-comment">#                         &gt;**提交发起**: ${DRONE_COMMIT_AUTHOR_NAME}</span><br>  <span class="hljs-comment">#                         &gt;**提交信息**: {{ build.message }}</span><br>  <span class="hljs-comment">#       "</span><br>  <span class="hljs-comment">#         }</span><br>  <span class="hljs-comment">#       }</span><br>  <span class="hljs-comment">#   when:</span><br>  <span class="hljs-comment">#     status:</span><br>  <span class="hljs-comment">#       - success</span><br>  <span class="hljs-comment">#       - failure</span><br><br></code></pre></td></tr></tbody></table></figure><p><a name="dXCkb"></a></p><h2 id="配置-Drone-CICD-流水线的秘钥"><a href="#配置-Drone-CICD-流水线的秘钥" class="headerlink" title="配置 Drone CICD 流水线的秘钥"></a>配置 Drone CICD 流水线的秘钥</h2><blockquote><p>注：在 Drone 管理面板配置以下 secret</p></blockquote><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">registry_url=registry.cn-shenzhen.aliyuncs.com</span><br><span class="hljs-string">registry_repo=registry.cn-shenzhen.aliyuncs.com/xxxx-hub/laravel-xxxx</span><br><span class="hljs-string">registry_user_name=1096xxxxxx@qq.com</span><br><span class="hljs-string">registry_password=xxxxxxx</span><br><span class="hljs-string">registry_cache=registry.cn-shenzhen.aliyuncs.com/xxxx-hub/laravel-xxxx:cache</span><br><span class="hljs-string">feishu_token=https://open.feishu.cn/open-apis/bot/v2/hook/759xxx1e-xxx-49df-xxx-4290cxxxxd858</span><br><span class="hljs-string">feishu_secret=Ya4CTxxxxxxxxxxptJRf</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717401077614-88d34964-ca4c-4d06-8d20-be597e66c827.png#averageHue=%23111619&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=471&amp;id=u324d0222&amp;originHeight=941&amp;originWidth=2464&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=108273&amp;status=done&amp;style=none&amp;taskId=u850d1b4b-ed69-43e7-befa-73d9df96bde&amp;title=&amp;width=1232" alt="image.png"><br><a name="L8NsS"></a></p><h2 id="触发流水示例"><a href="#触发流水示例" class="headerlink" title="触发流水示例"></a>触发流水示例</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717401425958-83e71d4e-7067-4f65-a827-7006222e0a72.png#averageHue=%230a0b0e&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=277&amp;id=u0fe49d44&amp;originHeight=554&amp;originWidth=1465&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=122515&amp;status=done&amp;style=none&amp;taskId=u6d4a3bd9-d0fc-475a-a894-c7b4ec5600b&amp;title=&amp;width=732.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717401455586-72d1131c-0908-40ab-9b2d-d0e66f4aff3e.png#averageHue=%2308090c&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=638&amp;id=u0559dbea&amp;originHeight=1275&amp;originWidth=1730&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=310713&amp;status=done&amp;style=none&amp;taskId=ua63fe41d-0d67-450d-a523-30efba896cd&amp;title=&amp;width=865" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717401477943-89735081-5545-401d-9c17-b7312f842ce2.png#averageHue=%230a0b0e&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=466&amp;id=u538036e2&amp;originHeight=931&amp;originWidth=1609&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=239153&amp;status=done&amp;style=none&amp;taskId=u0d9f9744-458f-45e0-8d2d-a5f7d257dfc&amp;title=&amp;width=804.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1669076/1717401498322-8089d543-682f-4bc8-9b82-c1da5f3e0d70.png#averageHue=%230d0e11&amp;clientId=ua18e34a7-f845-4&amp;from=paste&amp;height=259&amp;id=uadc127bf&amp;originHeight=518&amp;originWidth=2476&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=218784&amp;status=done&amp;style=none&amp;taskId=uece88265-5808-451b-8a58-454dda8de7f&amp;title=&amp;width=1238" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Drone CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel依赖注入原理和控制反转原理</title>
      <link href="/posts/88ff6cd3.html"/>
      <url>/posts/88ff6cd3.html</url>
      
        <content type="html"><![CDATA[<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Laravel 依赖注入是一种设计模式，旨在减少代码重复和提高可维护性。它允许开发人员通过将对象的实例化过程分离出来，使得代码更加灵活，并且可以通过配置文件或其他方式动态地改变对象的行为。<br>Laravel 的依赖注入是通过服务容器实现的。服务容器是一个管理类依赖关系和执行依赖注入的工具。当我们需要一个类的实例时，服务容器会自动解析该类的构造函数，找到并解决所需的依赖项，然后返回创建好的实例。这个过程是递归的，因为依赖项本身可能也有自己的依赖项。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面是一个简单的例子来说明 Laravel 的依赖注入原理：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span></span><br><span class="hljs-class"></span>{<br>  <span class="hljs-keyword">protected</span> <span class="hljs-variable">$userRepository</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">UserRepository <span class="hljs-variable">$userRepository</span></span>)</span><br><span class="hljs-function">  </span>{<br>    <span class="hljs-variable language_">$this</span>-&gt;userRepository = <span class="hljs-variable">$userRepository</span>;<br>  }<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">  </span>{<br>    <span class="hljs-variable">$users</span> = <span class="hljs-variable language_">$this</span>-&gt;userRepository-&gt;<span class="hljs-title function_ invoke__">getAllUsers</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">view</span>(<span class="hljs-string">'users.index'</span>, <span class="hljs-title function_ invoke__">compact</span>(<span class="hljs-string">'users'</span>));<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在上面的代码中，UserController 中的构造函数需要一个 UserRepository 实例。当我们从路由调用 index 方法时，Laravel 的服务容器会自动解析 UserRepository，并将其作为参数传递给构造函数。<br>假设我们已经注册了 UserRepository 的绑定：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable language_">$this</span>-&gt;app-&gt;<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-title class_">UserRepository</span>::<span class="hljs-variable language_">class</span>, function (<span class="hljs-variable">$app</span>) {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DbUserRepository</span>;<br>});<br></code></pre></td></tr></tbody></table></figure><p>这个绑定告诉 Laravel 当需要 UserRepository 实例时，使用 DbUserRepository 类来创建它。因此，在 UserController 的构造函数中，$userRepository 参数将会是一个 DbUserRepository 实例。<br>在实际开发中，我们可能不止需要一个 UserRepository 实现类。为了增加灵活性，Laravel 允许我们根据不同的情况绑定不同的实现类。例如，我们可以根据当前环境来注册不同的绑定。<br>总之，Laravel 依赖注入原理是通过服务容器来管理类依赖关系和执行依赖注入的过程。通过将对象的实例化过程分离出来，使得我们的代码更加灵活，并且可以动态地改变对象的行为。</p><h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在 Laravel 中，控制反转（Inversion of Control，IoC）是一个设计模式，它使得应用程序可以更加灵活、可维护和可扩展。控制反转可以帮助我们将业务逻辑与底层实现解耦，从而提高代码的可测试性和可读性。<br>在 Laravel 中，控制反转基于依赖注入（Dependency Injection，DI）实现。依赖注入是指，我们不需要手动创建对象或者管理对象之间的依赖关系，而是通过容器（Container）自动管理对象的创建和依赖项的注入。这样就可以减少代码的重复性，提高代码的可维护性。<br>Laravel 的控制反转原理可以概括为以下几个步骤：</p><ol><li>定义接口或者抽象类，描述需要实现的功能或者服务。</li><li>创建具体实现类，实现接口或者抽象类定义的功能或者服务。</li><li>在服务提供者（ServiceProvider）中注册服务，并且告诉 Laravel 如何创建该服务的实例。</li><li>在需要使用该服务的地方，在构造函数或者方法参数上声明对应的接口或者抽象类类型，Laravel 就会自动将该服务的实例注入进来。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面是一个简单的示例：<br>定义接口：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// app/Contracts/Logger.php</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Contracts</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Logger</span></span><br><span class="hljs-class"></span>{<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"><span class="hljs-variable">$message</span></span>)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>定义具体实现类：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// app/Services/FileLogger.php</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Services</span>;<br><br><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Contracts</span>\<span class="hljs-title">Logger</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Logger</span></span><br><span class="hljs-class"></span>{<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"><span class="hljs-variable">$message</span></span>)</span><br><span class="hljs-function">  </span>{<br>    <span class="hljs-comment">// 写入文件日志的逻辑</span><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在服务提供者中注册服务：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// app/Providers/AppServiceProvider.php</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Providers</span>;<br><br><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">ServiceProvider</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Services</span>\<span class="hljs-title">FileLogger</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Contracts</span>\<span class="hljs-title">Logger</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppServiceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceProvider</span></span><br><span class="hljs-class"></span>{<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">  </span>{<br>    <span class="hljs-variable language_">$this</span>-&gt;app-&gt;<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-title class_">Logger</span>::<span class="hljs-variable language_">class</span>, function () {<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLogger</span>();<br>    });<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在需要使用该服务的地方，自动注入实例：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// app/Http/Controllers/UserController.php</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Http</span>\<span class="hljs-title class_">Controllers</span>;<br><br><span class="hljs-keyword">use</span> <span class="hljs-title">App</span>\<span class="hljs-title">Contracts</span>\<span class="hljs-title">Logger</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span></span><br><span class="hljs-class"></span>{<br>  <span class="hljs-keyword">protected</span> <span class="hljs-variable">$logger</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">Logger <span class="hljs-variable">$logger</span></span>)</span><br><span class="hljs-function">  </span>{<br>    <span class="hljs-variable language_">$this</span>-&gt;logger = <span class="hljs-variable">$logger</span>;<br>  }<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">  </span>{<br>    <span class="hljs-variable language_">$this</span>-&gt;logger-&gt;<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">'User list page visited.'</span>);<br>    <span class="hljs-comment">// ...</span><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><blockquote><p><strong>通过依赖注入，我们可以将控制权从程序员手中转移到框架中</strong>，使得应用程序变得更加灵活、可维护和可扩展。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose进阶使用</title>
      <link href="/posts/9869a5f0.html"/>
      <url>/posts/9869a5f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><blockquote><p>docker-compose 项目是docker官方的开源项目， 负责实现对docker容器集群的快速编排，来轻松高效的管理容器，定义运行多个容器。</p></blockquote><ul><li>docker-compose将所管理的容器分为三层， <strong>分别是工程（project）</strong>，<strong>服务（service）</strong>以及<strong>容器（containner）</strong></li><li>docker-compose运行目录下的所有文件（docker-compose.yml文件、extends文件或环境变量等）组成一个工程，如无特殊指定，工程名即为当前目录名。</li><li>一个工程当中，可以包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖。</li><li>一个服务中可以包括多个容器实例，docker-compose并没有解决负载均衡的问题。因此需要借助其他工具实现服务发现及负载均衡，比如consul。</li><li>docker-compose的工程配置文件默认为 docker-compose.yml。可以通过环境变量COMPOSE_FILE -f 参数自定义配置文件，其自定义多个有依赖关系的服务及每个人服务运行的容器。<blockquote><p>官方文档：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a><br>GitHub：<a href="https://github.com/docker/compose/releases/">https://github.com/docker/compose/releases/</a></p></blockquote></li></ul><p><img src="https://cdn.l2xy.com/post_img/docker_compose_img/docker-compose-01.png"></p><h1 id="二、Compose-和-Docker-兼容性"><a href="#二、Compose-和-Docker-兼容性" class="headerlink" title="二、Compose 和 Docker 兼容性"></a>二、Compose 和 Docker 兼容性</h1><p>Compose 文件格式有多个版本：1、2、2.x、和 3.x。下面的表格是 Compose 文件所支持的指定的 docker 发行版：<br><img src="https://cdn.l2xy.com/post_img/docker_compose_img/docker-compose-02.png"></p><h1 id="三、安装-docker"><a href="#三、安装-docker" class="headerlink" title="三、安装 docker"></a>三、安装 docker</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装yum-config-manager配置工具</span><br>yum -y install yum-utils<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建议使用阿里云yum源：（推荐）</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装docker-ce版本</span><br>yum install -y docker-ce<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动并开机启动</span><br>systemctl enable --now docker<br>docker --version<br></code></pre></td></tr></tbody></table></figure><h1 id="四、安装-docker-compose"><a href="#四、安装-docker-compose" class="headerlink" title="四、安装 docker-compose"></a>四、安装 docker-compose</h1><p>官方安装地址教程：<a href="https://docs.docker.com/compose/install/other/">https://docs.docker.com/compose/install/other/</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -SL https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose<br><br>chmod +x /usr/bin/docker-compose<br>docker-compose --version<br></code></pre></td></tr></tbody></table></figure><h1 id="五、环境变量"><a href="#五、环境变量" class="headerlink" title="五、环境变量"></a>五、环境变量</h1><p>Docker Compose 允许你使用多种方法为服务设置环境变量。这些环境变量可以用来配置你的应用程序或将敏感信息传递给你的容器。<br>下面是一些设置 Docker Compose 环境变量的方法：</p><h2 id="1）在-docker-compose-yml-文件中设置环境变量"><a href="#1）在-docker-compose-yml-文件中设置环境变量" class="headerlink" title="1）在 docker-compose.yml 文件中设置环境变量"></a>1）在 docker-compose.yml 文件中设置环境变量</h2><p>你可以在 docker-compose.yml 文件中为每个服务设置环境变量。在服务配置中，使用 environment 关键字，并在其中列出需要设置的环境变量和其值。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MY_VAR:</span> <span class="hljs-string">my_value</span><br></code></pre></td></tr></tbody></table></figure><h2 id="2）从-env-文件中读取环境变量"><a href="#2）从-env-文件中读取环境变量" class="headerlink" title="2）从 .env 文件中读取环境变量"></a>2）从 .env 文件中读取环境变量</h2><p>你可以将环境变量存储在一个 .env 文件中，并让 Docker Compose 读取它。在 docker-compose.yml 文件中，使用 env_file 关键字并指定 .env 文件的路径。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">env_file:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">.env</span><br></code></pre></td></tr></tbody></table></figure><h2 id="3）使用-shell-环境变量"><a href="#3）使用-shell-环境变量" class="headerlink" title="3）使用 shell 环境变量"></a>3）使用 shell 环境变量</h2><p>你也可以在启动 docker-compose 命令时，使用 shell 环境变量传递环境变量值。例如：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> MY_VAR=my_value</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose up</span><br></code></pre></td></tr></tbody></table></figure><p>在 docker-compose.yml 文件中使用 ${MY_VAR} 语法来引用 shell 环境变量。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MY_VAR:</span> <span class="hljs-string">${MY_VAR}</span><br></code></pre></td></tr></tbody></table></figure><p>使用环境变量可以使你的应用程序更具灵活性，并且可以方便地管理敏感信息。</p><h1 id="六、编排中的字段详解"><a href="#六、编排中的字段详解" class="headerlink" title="六、编排中的字段详解"></a>六、编排中的字段详解</h1><p>在 Docker Compose 编排文件中，有一些重要的字段需要了解：</p><h2 id="1）version"><a href="#1）version" class="headerlink" title="1）version"></a>1）version</h2><p>version 字段指定了 Docker Compose 编排文件的版本。当前最新版本是 3。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br></code></pre></td></tr></tbody></table></figure><h2 id="2）services"><a href="#2）services" class="headerlink" title="2）services"></a>2）services</h2><p>services 字段指定了在 Docker Compose 编排中要运行的服务。每个服务都有一个名称，并指定要使用的镜像和容器的配置选项。以下是一个简单的 services 配置的示例：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">"5000:5000"</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">"redis:alpine"</span><br></code></pre></td></tr></tbody></table></figure><h2 id="3）build-与-image"><a href="#3）build-与-image" class="headerlink" title="3）build 与 image"></a>3）build 与 image</h2><h3 id="1、build"><a href="#1、build" class="headerlink" title="1、build"></a>1、build</h3><p>build 字段允许在 Docker Compose 编排中指定 Dockerfile 的位置，从而可以使用 Docker Compose 构建镜像。例如，以下是使用本地 Dockerfile 的示例：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br></code></pre></td></tr></tbody></table></figure><p>也可以指定一个包含 Dockerfile 的目录：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./my-web-app</span><br></code></pre></td></tr></tbody></table></figure><h3 id="2、image"><a href="#2、image" class="headerlink" title="2、image"></a>2、image</h3><p>image 字段指定要使用的 Docker 镜像。例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></tbody></table></figure><p>【温馨提示】build 和 image 二选一即可，也可以同时写，但是一般只选择image吧。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.8'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./web</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp/web:latest</span><br></code></pre></td></tr></tbody></table></figure><p>上面的配置指定了服务名称为web，Dockerfile路径为./web，镜像名称为 myapp/web，标签为 latest。在运行docker-compose build 命令时，会自动构建名为 myapp/web:latest 的镜像。</p><h2 id="4）networks"><a href="#4）networks" class="headerlink" title="4）networks"></a>4）networks</h2><p>networks 字段指定了要使用的网络。默认情况下，Docker Compose 创建一个名为 default 的网络。以下是一个使用自定义网络的示例：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">my-network:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></tbody></table></figure><h2 id="5）volumes"><a href="#5）volumes" class="headerlink" title="5）volumes"></a>5）volumes</h2><p>volumes 字段指定了要使用的数据卷。以下是一个使用数据卷的示例（下面会细讲）：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">my-volume:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span><br></code></pre></td></tr></tbody></table></figure><h2 id="6）environment-与-environment-file"><a href="#6）environment-与-environment-file" class="headerlink" title="6）environment 与 environment_file"></a>6）environment 与 environment_file</h2><h3 id="1、environment"><a href="#1、environment" class="headerlink" title="1、environment"></a>1、environment</h3><p>environment 字段指定了要设置的环境变量。以下是一个使用环境变量的示例：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">environment:</span><br>  <span class="hljs-attr">MY_VAR:</span> <span class="hljs-string">my_value</span><br></code></pre></td></tr></tbody></table></figure><h3 id="2、environment-file"><a href="#2、environment-file" class="headerlink" title="2、environment_file"></a>2、environment_file</h3><p>environment_file：指定从文件中读取环境变量。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">environment_file:</span> <span class="hljs-string">.env</span><br></code></pre></td></tr></tbody></table></figure><h2 id="7）ports-与-expose"><a href="#7）ports-与-expose" class="headerlink" title="7）ports 与 expose"></a>7）ports 与 expose</h2><h3 id="1、ports"><a href="#1、ports" class="headerlink" title="1、ports"></a>1、ports</h3><p>ports 字段指定了要宿主机映射到容器的端口（<strong>宿主机端口:容器端口</strong>）。以下是一个使用端口映射的示例：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">"8080:80"</span><br></code></pre></td></tr></tbody></table></figure><h3 id="2、expose"><a href="#2、expose" class="headerlink" title="2、expose"></a>2、expose</h3><p>expose 字段是用于在 Docker 容器内部暴露端口的选项，可以让其他容器连接到这些端口，但不会将它们映射到 Docker 主机上。<br>在 docker-compose.yml 文件中使用 expose 选项来指定容器内部需要暴露的端口。例如，以下示例定义了一个 web 服务，它暴露了 8000 和 8080 端口：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">expose:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">"8000"</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">"8080"</span><br></code></pre></td></tr></tbody></table></figure><p>当您使用 expose 选项时，其他容器可以使用 Docker 的内部网络进行连接。例如，如果您有另一个服务 worker，它需要连接到 web 服务的 8000 端口，则可以在 worker 服务的 docker-compose.yml 文件中使用 links 选项：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">worker:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myworker:latest</span><br>    <span class="hljs-attr">links:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">web</span><br></code></pre></td></tr></tbody></table></figure><h2 id="8）depends-on"><a href="#8）depends-on" class="headerlink" title="8）depends_on"></a>8）depends_on</h2><p>depends_on 字段指定了服务之间的依赖关系。例如，如果 web 服务依赖于 db 服务，则可以使用以下示例：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">depends_on:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br></code></pre></td></tr></tbody></table></figure><h2 id="9）restart"><a href="#9）restart" class="headerlink" title="9）restart"></a>9）restart</h2><p>Docker Compose 提供了几种重启策略，以便在容器出现故障时自动重启它们。以下是可用的重启策略：</p><ul><li>no: 不重启任何容器。如果容器停止，Compose 不会尝试自动重启它们。（<strong>默认策略</strong>）</li><li>always: 如果容器停止，Compose 将自动重启它。（<strong>常用</strong>）</li><li>on-failure: 只有在容器因非 0 退出码而停止时才会重启。</li><li>unless-stopped: 除非手动停止，否则始终重启容器。这相当于使用 docker run 命令时使用的 –restart=unless-stopped 标志。</li></ul><p>这些策略可以在 docker-compose.yml 文件中通过 restart 键指定，例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></tbody></table></figure><p>这个示例使用 always 策略，这意味着如果 web 容器停止，Compose 将自动重启它。</p><h2 id="10）command"><a href="#10）command" class="headerlink" title="10）command"></a>10）command</h2><p>command 字段可以使用多种写法来指定容器启动时要执行的命令，具体取决于您的需求和偏好。以下是一些常见的写法示例：</p><h3 id="1、字符串形式"><a href="#1、字符串形式" class="headerlink" title="1、字符串形式"></a>1、字符串形式</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">python</span> <span class="hljs-string">manage.py</span> <span class="hljs-string">runserver</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:8000</span><br></code></pre></td></tr></tbody></table></figure><p>在这个示例中，command 字段的值是一个字符串，表示要执行的命令和参数。</p><h3 id="2、列表形式"><a href="#2、列表形式" class="headerlink" title="2、列表形式"></a>2、列表形式</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">python</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">manage.py</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">runserver</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:8000</span><br></code></pre></td></tr></tbody></table></figure><p>在这个示例中，command 字段的值是一个列表，每个元素都表示要执行的命令或参数。</p><h3 id="3、Shell-命令形式"><a href="#3、Shell-命令形式" class="headerlink" title="3、Shell 命令形式"></a>3、Shell 命令形式</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-comment"># 两种写法</span><br>    <span class="hljs-comment"># command: sh -c "python manage.py runserver 0.0.0.0:8000"</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">"sh"</span>,<span class="hljs-string">"-c"</span>,<span class="hljs-string">"python manage.py runserver 0.0.0.0:8000"</span>]<br></code></pre></td></tr></tbody></table></figure><h3 id="4、使用环境变量形式"><a href="#4、使用环境变量形式" class="headerlink" title="4、使用环境变量形式"></a>4、使用环境变量形式</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ENVIRONMENT=production</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">python</span> <span class="hljs-string">manage.py</span> <span class="hljs-string">runserver</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:${PORT}</span><br></code></pre></td></tr></tbody></table></figure><p>在这个示例中，command 字段中的 ${PORT} 将被替换为 web 服务的环境变量 PORT 的值。</p><h2 id="11）healthcheck"><a href="#11）healthcheck" class="headerlink" title="11）healthcheck"></a>11）healthcheck</h2><p>healthcheck：指定容器健康检查配置。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-f"</span>, <span class="hljs-string">"http://localhost/health"</span>]<br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>上面的例子中，配置容器健康检查命令为 “curl -f <a href="http://localhost/health&quot;%EF%BC%8C**%E6%AF%8F">http://localhost/health"，**每</a> 30 秒检查一次**，超时时间为 10 秒，最多重试 3 次。</p><h2 id="12）configs-与-secrets"><a href="#12）configs-与-secrets" class="headerlink" title="12）configs 与 secrets"></a>12）configs 与 secrets</h2><h3 id="1、configs"><a href="#1、configs" class="headerlink" title="1、configs"></a>1、configs</h3><p>configs：指定容器使用的配置文件。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">source:</span> <span class="hljs-string">my-config</span><br>    <span class="hljs-attr">target:</span> <span class="hljs-string">/etc/nginx/conf.d/default.conf</span><br></code></pre></td></tr></tbody></table></figure><p>上面的例子中，将名为 my-config 的配置文件复制到容器的 /etc/nginx/conf.d/default.conf 目录下。</p><h3 id="2、secrets"><a href="#2、secrets" class="headerlink" title="2、secrets"></a>2、secrets</h3><p>secrets：指定容器使用的机密数据。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">secrets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">db_password</span><br></code></pre></td></tr></tbody></table></figure><h2 id="13）hostname-与-container-name"><a href="#13）hostname-与-container-name" class="headerlink" title="13）hostname 与 container_name"></a>13）hostname 与 container_name</h2><p>hostname 和 container_name 都是用来定义 Docker 容器的标识符，但是它们的含义不同。</p><h3 id="1、hostname"><a href="#1、hostname" class="headerlink" title="1、hostname"></a>1、hostname</h3><p>hostname 用于设置容器的主机名，也就是在容器内部可以使用的名称。例如，如果您在容器内部使用 ping hostname 命令，它将解析为容器的 IP 地址。可以使用以下格式设置主机名：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">myapp</span><br></code></pre></td></tr></tbody></table></figure><p>在这个示例中，web 服务的容器主机名被设置为 myapp。</p><h3 id="2、container-name"><a href="#2、container-name" class="headerlink" title="2、container_name"></a>2、container_name</h3><p>container_name 用于给容器命名，也就是在 Docker 主机上使用的名称。可以使用以下格式设置容器名称：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">myapp</span><br></code></pre></td></tr></tbody></table></figure><p>在这个示例中，web 服务的容器名称被设置为 myapp。<br>总之，hostname 和 container_name 都是用于定义容器的标识符，但是 hostname 用于容器内部的标识，container_name 用于 Docker 主机上的标识。</p><h2 id="14）user"><a href="#14）user" class="headerlink" title="14）user"></a>14）user</h2><p>在 Docker Compose 中，可以使用 user 字段来指定容器中运行的进程的用户和用户组。它的语法与 docker run 命令的 –user 选项类似，有以下三种形式：</p><h3 id="1、user-group（推荐）"><a href="#1、user-group（推荐）" class="headerlink" title="1、user:group（推荐）"></a>1、user:group（推荐）</h3><p>以 user 用户和 group 用户组的身份运行容器中的进程，例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">nginx:nginx</span><br></code></pre></td></tr></tbody></table></figure><h3 id="2、uid-gid"><a href="#2、uid-gid" class="headerlink" title="2、uid:gid"></a>2、uid:gid</h3><p>以 uid 用户 ID 和 gid 用户组 ID 的身份运行容器中的进程，例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">"1000:1000"</span><br></code></pre></td></tr></tbody></table></figure><h3 id="3、user"><a href="#3、user" class="headerlink" title="3、user"></a>3、user</h3><p>以 user 用户的身份运行容器中的进程，例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></tbody></table></figure><p>需要注意的是，如果在 Docker Compose 中使用了 user 字段，则容器中的所有进程都将以指定的用户身份运行，而<strong>不是默认的 root 用户身份运行</strong>。这可以提高容器的安全性，<strong>避免在容器中使用 root 用户造成潜在的安全风险</strong>。</p><h2 id="15）deploy"><a href="#15）deploy" class="headerlink" title="15）deploy"></a>15）deploy</h2><p>deploy：指定服务部署配置。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">limits:</span><br>      <span class="hljs-attr">cpus:</span> <span class="hljs-string">'0.5'</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">'256M'</span><br>    <span class="hljs-attr">reservations:</span><br>      <span class="hljs-attr">cpus:</span> <span class="hljs-string">'0.25'</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">'128M'</span><br></code></pre></td></tr></tbody></table></figure><p>上面的例子中，配置服务的副本数量为 3，限制每个副本使用的 CPU 和内存资源，并保留一部分资源供其他服务使用。</p><h1 id="七、port-和-expose-区别"><a href="#七、port-和-expose-区别" class="headerlink" title="七、port 和 expose 区别"></a>七、port 和 expose 区别</h1><p>ports 和 expose 是两个不同的 Docker Compose 字段，用于在容器中暴露端口。</p><ul><li><p>ports 字段用于将<strong>容器内部的端口</strong>映射到<strong>宿主机上的端口</strong>，以便外部网络可以通过宿主机上的端口与容器中运行的应用程序进行通信。这个字段的语法如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">"8080:80"</span><br></code></pre></td></tr></tbody></table></figure><p>这个例子中，容器中运行的 nginx 进程监听的是容器内部的 80 端口，而 ports 字段将宿主机上的 8080 端口映射到了容器内部的 80 端口，这样外部网络就可以通过访问宿主机上的 8080 端口来访问容器中运行的 nginx 应用程序。</p></li><li><p>expose 与 ports 不同的是，expose 字段仅仅是<strong>将容器内部的端口暴露给其他容器使用</strong>，而不是直接映射到宿主机上的端口。这个字段的语法如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">expose:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">"3306"</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">expose:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">"80"</span><br></code></pre></td></tr></tbody></table></figure><p>这个例子中，db 和 web 两个容器分别暴露了它们内部的 3306 和 80 端口，其他容器可以使用这些端口来与它们通信。但是，由于这些端口没有被映射到宿主机上，因此外部网络无法直接访问它们。如果要从外部网络访问这些容器，需要使用 ports 字段将它们映射到宿主机上的端口。</p><h1 id="八、configs-与-secrets-区别"><a href="#八、configs-与-secrets-区别" class="headerlink" title="八、configs 与 secrets 区别"></a>八、configs 与 secrets 区别</h1><p>configs 和 secrets 是 Docker Compose 和 Docker Swarm 中用于管理容器配置和敏感数据的两个不同的功能。它们的区别如下：</p></li><li><p><strong>用途不同</strong>：configs 用于管理容器应用程序的<strong>配置文件</strong>，例如 nginx 的配置文件、MySQL 的配置文件等，而 secrets 则用于管理<strong>敏感数据</strong>，例如数据库的密码、API 密钥等。</p></li><li><p><strong>存储位置不同</strong>：configs 存储在 Docker 主机的文件系统中，可以是本地文件系统、NFS 文件系统或远程 S3 存储等，而 secrets 存储在 Docker Swarm 的安全存储中，该存储是加密的、高度安全的，并且只能由授权的 Docker 服务和节点访问。</p></li><li><p><strong>访问方式不同</strong>：configs 可以通过文件挂载或 Docker Compose 文件中的 configs 字段来访问，而 secrets 可以通过文件挂载、Docker Compose 文件中的 secrets 字段、Docker CLI 的 docker secret 命令或容器内部的文件系统来访问。</p></li><li><p><strong>生命周期不同</strong>：configs 的生命周期是独立于服务的，当服务停止时，配置文件<strong>仍然可以保留在主机上</strong>，而 secrets 的生命周期是<strong>与服务绑定</strong>的，当服务被删除时，敏感数据也会被删除。</p></li><li><p><strong>更新方式不同</strong>：configs 的更新是通过重新部署服务来实现的，而 secrets 的更新是通过 Docker CLI 的 docker secret 命令或容器内部的文件系统来实现的。</p></li></ul><p>以下是一个使用 configs 和 secrets 的 Docker Compose 文件的示例：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.7'</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">source:</span> <span class="hljs-string">nginx_conf</span><br>        <span class="hljs-attr">target:</span> <span class="hljs-string">/etc/nginx/nginx.conf</span><br>    <span class="hljs-attr">secrets:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">source:</span> <span class="hljs-string">db_password</span><br>        <span class="hljs-attr">target:</span> <span class="hljs-string">/run/secrets/db_password</span><br><br><span class="hljs-attr">configs:</span><br>  <span class="hljs-attr">nginx_conf:</span><br>    <span class="hljs-attr">file:</span> <span class="hljs-string">./nginx.conf</span><br><br><span class="hljs-attr">secrets:</span><br>  <span class="hljs-attr">db_password:</span><br>    <span class="hljs-attr">file:</span> <span class="hljs-string">./db_password.txt</span><br></code></pre></td></tr></tbody></table></figure><p>在上面的示例中，我们定义了一个 web 服务，该服务使用了 nginx:latest 镜像，并将容器内的 80 端口映射到 Docker 主机的 80 端口。此外，我们还定义了两个配置：configs 和 secrets。</p><ul><li>configs 定义了一个名为 nginx_conf 的配置，该配置从<strong>本地</strong>的 nginx.conf 文件中读取配置，并将其挂载到<strong>容器内的</strong> /etc/nginx/nginx.conf 路径。这样，我们就可以使用自定义的 nginx.conf 配置文件来配置 nginx 服务。</li><li>secrets 定义了一个名为 db_password 的<strong>敏感数据</strong>，该数据从本地的 db_password.txt文件中读取，并将其挂载到容器内的 /run/secrets/db_password 路径。这样，我们就可以在容器内部安全地访问数据库密码，而不必担心密码泄露的风险。</li></ul><p>在上述示例中，我们使用了文件挂载来访问 configs 和 secrets。这是最常见的访问方式，但并不是唯一的方式。secrets 还可以通过 Docker CLI 的 docker secret 命令或容器内部的文件系统来访问。</p><h1 id="九、挂载"><a href="#九、挂载" class="headerlink" title="九、挂载"></a>九、挂载</h1><p>在 Docker Compose 中，可以通过挂载主机目录或文件来访问容器内部的文件或目录，以便在容器内外共享数据或配置文件。Docker Compose 支持两种方式进行挂载：</p><h2 id="1）命名卷挂载"><a href="#1）命名卷挂载" class="headerlink" title="1）命名卷挂载"></a>1）命名卷挂载</h2><p>命名卷是由 Docker 创建和管理的卷，它们可以用于存储持久化数据，并可以在多个容器之间共享。在 Docker Compose 中，可以通过 volumes 字段来定义命名卷的挂载路径和主机目录的映射关系。示例例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.7"</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">myapp_data:/app/data</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">myapp_data:</span><br></code></pre></td></tr></tbody></table></figure><p>在上述示例中，我们定义了一个 myapp 服务，该服务使用了 myapp:latest 镜像，并将命名卷 myapp_data 挂载到容器内的 /app/data 目录。</p><h2 id="2）主机目录挂载"><a href="#2）主机目录挂载" class="headerlink" title="2）主机目录挂载"></a>2）主机目录挂载</h2><p>主机目录挂载允许将 Docker 主机上的目录或文件夹挂载到容器内部，以便在容器内外共享数据。在 Docker Compose 中，可以通过 volumes 字段来定义主机目录的挂载路径和主机目录的映射关系。例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3.7"</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/host/data:/app/data</span><br></code></pre></td></tr></tbody></table></figure><p>在上述示例中，我们定义了一个 myapp 服务，该服务使用了 myapp:latest 镜像，并将<strong>宿主机</strong>上的 /host/data目录挂载到<strong>容器内</strong>的 /app/data 目录。</p><blockquote><p>【注意】在 Docker Compose 中，如果使用主机目录挂载，则要求主机目录必须存在且具有正确的权限。否则，容器将无法访问该目录。此外，在使用主机目录挂载时，请注意挂载的目录是否包含敏感数据，以避免数据泄露的风险。</p></blockquote><h1 id="十、网络"><a href="#十、网络" class="headerlink" title="十、网络"></a>十、网络</h1><p>Docker Compose 中的网络可以用于在多个容器之间建立通信。通过定义网络，可以让容器之间相互通信，同时将它们与主机网络隔离开来，提高容器应用的安全性。<br>Docker Compose 提供了三种网络类型：<strong>bridge</strong>、<strong>host</strong> 和 <strong>none</strong>，每种类型都适用于不同的场景。</p><h2 id="1）bridge-网络类型"><a href="#1）bridge-网络类型" class="headerlink" title="1）bridge 网络类型"></a>1）bridge 网络类型</h2><p>bridge 网络类型是默认的网络类型，它创建一个桥接网络，允许容器之间进行通信。每个容器都有自己的 IP 地址，并且可以通过容器名称来相互访问。如果<strong>没有指定网络类型</strong>，Docker Compose 将<strong>使用 bridge 网络类型</strong>。<br>在 bridge 网络类型中，Docker Compose 会为每个服务创建一个容器，并为每个容器分配一个 IP 地址。<strong>在同一个网络中的容器可以相互访问</strong>。</p><blockquote><p>【请注意】如果您使用了Docker Compose的网络功能（默认情况下会创建一个网络），则可以在同一网络中的任何容器中使用容器名称来访问服务。如果您没有使用Docker Compose网络功能，则需要手动创建网络，并将所有容器添加到同一网络中。</p></blockquote><p>【示例】假设我们有两个服务：web 和 db。在默认情况下，Docker Compose 使用 bridge 网络类型，我们可以不用特别指定网络类型。以下是一个示例的 docker-compose.yml 文件：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">"80:80"</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">example</span><br></code></pre></td></tr></tbody></table></figure><p>在上述示例中，web 服务将使用本地 Dockerfile 构建，并将容器端口 80 映射到主机端口 80。db 服务将使用 MySQL 5.7 镜像，并设置 MySQL 的 root 用户密码为 example。<br>通过 docker-compose up 命令启动这个示例，Docker Compose 将为每个服务创建一个容器，并自动创建一个默认的 bridge 网络来使它们互相通信。</p><h2 id="2）host-网络类型"><a href="#2）host-网络类型" class="headerlink" title="2）host 网络类型"></a>2）host 网络类型</h2><p>host 网络类型让容器共享主机的网络栈，这意味着容器将与主机具有相同的 IP 地址和网络接口。这样可以提高容器的网络性能和可访问性，但是容器之间不能互相访问，因为它们共享同一个网络栈。<br>在 host 网络类型中，Docker Compose 会将每个服务直接放在主机网络中，容器将与主机共享 IP 地址和网络接口，因此可以通过主机 IP 地址来访问容器中运行的服务。<br>【示例】假设我们有一个服务，它需要使用主机网络接口。以下是一个示例的 docker-compose.yml 文件：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">host</span><br></code></pre></td></tr></tbody></table></figure><p>在上述示例中，我们使用 build 关键字来指定构建上下文，并使用 network_mode 关键字将服务 web 的网络模式设置为 host。这样，web 服务将与主机共享 IP 地址和网络接口，可以通过主机 IP 地址来访问服务。</p><h2 id="3）none-网络类型"><a href="#3）none-网络类型" class="headerlink" title="3）none 网络类型"></a>3）none 网络类型</h2><p>none 网络类型表示不为容器分配任何网络资源，容器将没有网络接口。这通常用于某些特殊的容器场景，例如一些只需要与主机交互而不需要网络连接的容器。<br>在 none 网络类型中，Docker Compose 会将每个服务放在一个单独的网络命名空间中，容器将没有任何网络资源，无法进行网络通信。<br>【示例】假设我们有一个服务，它不需要任何网络连接。以下是一个示例的 docker-compose.yml 文件：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">worker:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">none</span><br></code></pre></td></tr></tbody></table></figure><p>在上述示例中，我们使用 build 关键字来指定构建上下文，并使用 network_mode 关键字将服务 worker 的网络模式设置为 none。这样，worker 服务将<strong>没有任何网络资源</strong>，无法进行网络通信。</p><h2 id="4）自定义网络"><a href="#4）自定义网络" class="headerlink" title="4）自定义网络"></a>4）自定义网络</h2><p>Docker Compose<strong>默认会为每个Compose项目创建一个网络</strong>。这个网络的名称会以Compose项目的目录名作为前缀，例如，如果您的Compose项目目录名为myproject，则默认创建的网络名称为myproject_default。</p><ul><li>在这个<strong>默认创建的网络中</strong>，所有的<strong>服务和容器都可以通过它们的服务名称或容器名称进行通信</strong>。这些名称在默认情况下都是唯一的，因此可以避免名称冲突和混乱。</li><li>如果您需要访问不同的网络或自定义网络，则可以使用Docker Compose的networks属性来创建自定义网络。例如，以下是一个Docker Compose文件，其中定义了一个名为my_network的自定义网络：<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my_network</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">my_network:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></tbody></table></figure>在这个示例中，web服务将被连接到my_network网络中，而不是默认创建的网络。该网络的驱动程序为bridge，这是Docker Compose默认使用的网络驱动程序。<blockquote><p><strong>Compose项目目录名解释</strong>：Compose项目目录名是指包含Docker Compose文件的目录的名称。Docker Compose文件（通常命名为docker-compose.yml）描述了Docker Compose应该如何构建和运行Docker容器应用程序。该文件通常存储在Compose项目目录的根目录中。</p></blockquote></li></ul><p>例如，如果您正在开发一个名为myapp的应用程序，并使用Docker Compose来管理它的容器化部署，那么您可能会在以下目录结构中存储您的Docker Compose文件：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">myapp/</span><br><span class="hljs-string">├──</span> <span class="hljs-string">docker-compose.yml</span><br><span class="hljs-string">├──</span> <span class="hljs-string">app/</span><br><span class="hljs-string">│</span>   <span class="hljs-string">├──</span> <span class="hljs-string">Dockerfile</span><br><span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-string">app.py</span><br><span class="hljs-string">└──</span> <span class="hljs-string">data/</span><br></code></pre></td></tr></tbody></table></figure><p>在这个例子中，myapp是Compose项目目录名，docker-compose.yml是Compose文件的名称，并存储在myapp目录的根目录中。myapp目录还包含了应用程序的代码和数据目录。</p><h1 id="十一、域名解析-DNS"><a href="#十一、域名解析-DNS" class="headerlink" title="十一、域名解析 DNS"></a>十一、域名解析 DNS</h1><blockquote><p>Docker Compose中的容器可以使用容器名称或服务名称来相互访问，而不需要使用IP地址。这是因为Docker Compose会为每个服务创建一个DNS记录，这些记录由默认的DNS解析器处理。</p></blockquote><p><strong>默认情况下</strong>，Docker Compose会创建一个名为”projectname_default”的网络，并将所有服务连接到该网络中。该网络<strong>使用Docker内置的DNS解析器</strong>，为每个服务和容器分配一个DNS名称。例如，如果您的Compose项目名为”myproject”，那么您可以使用以下命令查看所有服务的DNS名称：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">docker-compose</span> <span class="hljs-string">run</span> <span class="hljs-string">&lt;service&gt;</span> <span class="hljs-string">nslookup</span> <span class="hljs-string">&lt;service&gt;</span><br><br></code></pre></td></tr></tbody></table></figure><p>例如，如果您的服务名称为”web”，则可以使用以下命令查看web服务的DNS名称：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">docker-compose</span> <span class="hljs-string">run</span> <span class="hljs-string">web</span> <span class="hljs-string">nslookup</span> <span class="hljs-string">web</span><br></code></pre></td></tr></tbody></table></figure><p>这将输出web服务的DNS记录，包括IP地址和DNS名称。例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Server:</span>    <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.11</span><br><span class="hljs-attr">Address 1:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.11</span><br><br><span class="hljs-attr">Name:</span>      <span class="hljs-string">web</span><br><span class="hljs-attr">Address 1:</span> <span class="hljs-number">172.18</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><br></code></pre></td></tr></tbody></table></figure><p>在这个例子中，web服务的DNS名称为”web”，IP地址为172.18.0.2。您可以使用该名称（”web”）来访问该服务，而无需使用IP地址。</p><h1 id="十二、健康检查"><a href="#十二、健康检查" class="headerlink" title="十二、健康检查"></a>十二、健康检查</h1><p>Docker Compose 支持为服务定义健康检查，用于检查服务是否正常运行。健康检查可以是一个命令、一个 HTTP 请求或者一个 TCP 端口。如果健康检查失败，Docker Compose 将尝试重新启动服务，直到达到最大重试次数或者服务成功运行。</p><h2 id="1）健康检查语法"><a href="#1）健康检查语法" class="headerlink" title="1）健康检查语法"></a>1）健康检查语法</h2><p>在 Docker Compose 中，可以通过 healthcheck 关键字来定义健康检查。具体语法如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD-SHELL"</span>, <span class="hljs-string">"command"</span>]<br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">interval</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">timeout</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-string">retries</span><br></code></pre></td></tr></tbody></table></figure><p>参数解释：</p><ul><li>test 是健康检查的命令或者请求。</li><li>interval 是检查健康状态的时间间隔，单位为秒，默认为 30s。</li><li>timeout 是检查健康状态的超时时间，单位为秒，默认为 30s。</li><li>retries 是健康检查失败时的重试次数，默认为 3。<h2 id="2）健康检查写法"><a href="#2）健康检查写法" class="headerlink" title="2）健康检查写法"></a>2）健康检查写法</h2>包括以下几种写法：<br><strong>1、字符串形式的命令</strong><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> <span class="hljs-string">curl</span> <span class="hljs-string">--fail</span> <span class="hljs-string">http://localhost:80</span> <span class="hljs-string">||</span> <span class="hljs-string">exit</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure>在上述示例中，healthcheck 字段的 test 属性是一个字符串，表示需要执行的健康检查命令。在这个示例中，我们使用 curl 命令来测试 localhost:80 是否能够访问。如果健康检查命令返回状态码 0，则表示服务正常，否则表示服务异常。在这个示例中，如果健康检查失败，Docker Compose 将在每 30 秒尝试重新运行健康检查，最多重试 5 次。<br><strong>2、数组形式的命令</strong><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">CMD</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">curl</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--fail</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">http://localhost:80</span><br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure></li></ul><p><strong>3、自定义命令</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD-SHELL"</span>, <span class="hljs-string">"curl --fail http://localhost:80 || exit 1"</span>]<br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p>在上述示例中，healthcheck 字段的 test 属性是一个数组，其中第一个元素是 CMD-SHELL，表示使用 shell 执行命令。第二个元素是一个自定义的命令，与前面的示例相同。</p><h2 id="3）CMD-SHELL-与-CMD"><a href="#3）CMD-SHELL-与-CMD" class="headerlink" title="3）CMD-SHELL 与 CMD"></a>3）CMD-SHELL 与 CMD</h2><p>CMD-SHELL 和 CMD 都是 Dockerfile 中 RUN 指令以及 Docker Compose 中 healthcheck 指令中常用的命令格式，两者之间的区别如下：</p><ul><li>CMD-SHELL（这里推荐）：表示使用 shell 执行命令。在 Docker Compose 中，健康检查的 test 属性中可以使用 CMD-SHELL` 来执行自定义的 shell 命令。</li><li>CMD：表示执行指定的命令或者命令参数。在 Dockerfile 中，CMD 常用于指定容器启动时需要执行的命令，而在 Docker Compose 中，CMD 常用于指定服务启动时需要执行的命令或者命令参数。</li></ul><p>两者的使用方式不同，但都可以用于执行命令或者命令参数。在 Dockerfile 中，CMD-SHELL 并不是一个有效的指令，而在 Docker Compose 中，CMD 用于定义服务的启动命令，而 healthcheck 中的 test 属性可以使用 CMD-SHELL 来执行自定义的 shell 命令。其实CMD在docker compose healthcheck 也是可以使用的。只是更建议使用CMD-SHELL。</p><h2 id="4）示例讲解"><a href="#4）示例讲解" class="headerlink" title="4）示例讲解"></a>4）示例讲解</h2><p>以下是一个简单的Docker Compose文件，其中定义了一个健康检查：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">"80:80"</span><br>    <span class="hljs-attr">healthcheck:</span><br>      <span class="hljs-comment">#test: ["CMD", "curl", "-f", "http://localhost"]</span><br>      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD-SHELL"</span>, <span class="hljs-string">"curl -f http://localhost"</span>]<br>      <span class="hljs-attr">interval:</span> <span class="hljs-string">1m</span><br>      <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>在这个例子中，web服务使用nginx镜像，并将端口80映射到主机上的端口80。此外，它定义了一个健康检查，该检查将定期运行curl命令来测试服务是否响应HTTP请求。具体来说，该检查将每隔1分钟运行一次，超时时间为10秒，并尝试重试3次。<br>您可以使用以下命令启动该服务：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 也通过-f指定docker-compose文件</span><br><span class="hljs-string">docker-compose</span> <span class="hljs-string">up</span><br></code></pre></td></tr></tbody></table></figure><p>在服务启动后，Compose将定期运行健康检查，并根据检查结果重启服务。您可以使用以下命令查看服务的健康状态：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">docker-compose</span> <span class="hljs-string">ps</span><br></code></pre></td></tr></tbody></table></figure><p>此命令将显示服务的健康状态，例如：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml">   <span class="hljs-string">Name</span>           <span class="hljs-string">Command</span>              <span class="hljs-string">State</span>          <span class="hljs-string">Ports</span>        <br><span class="hljs-string">-------------------------------------------------------------------</span><br><span class="hljs-string">webapp_web_1</span>   <span class="hljs-string">nginx</span> <span class="hljs-string">-g</span> <span class="hljs-string">daemon</span> <span class="hljs-string">off;</span>   <span class="hljs-string">Up</span> <span class="hljs-string">(healthy)</span>   <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:80-&gt;80/tcp</span><br></code></pre></td></tr></tbody></table></figure><p>在这个例子中，服务的健康状态为”Up (healthy)”，这表示服务正在运行并且健康检查通过。</p><h1 id="十三、常用命令"><a href="#十三、常用命令" class="headerlink" title="十三、常用命令"></a>十三、常用命令</h1><p>以下是Docker Compose中一些常用的命令：</p><ul><li>docker-compose up：启动Compose文件中定义的服务，创建并启动所有容器。</li><li>docker-compose down：停止Compose文件中定义的服务，删除所有容器和网络。</li><li>docker-compose ps：显示Compose文件中定义的所有容器的状态。</li><li>docker-compose logs：显示Compose文件中定义的所有容器的日志。</li><li>docker-compose build：根据Compose文件中定义的Dockerfile构建所有服务的镜像。</li><li>docker-compose pull：拉取Compose文件中定义的所有服务的镜像。</li><li>docker-compose restart：重启Compose文件中定义的所有服务。</li><li>docker-compose stop：停止Compose文件中定义的所有服务。</li><li>docker-compose start：启动Compose文件中定义的所有服务。</li><li>docker-compose exec：在Compose文件中定义的容器中执行命令。</li><li>docker-compose run：在Compose文件中定义的容器中运行命令。</li><li>docker-compose config：检查Compose文件的语法，并显示Compose文件中定义的所有服务的配置。</li></ul><p>这些是Docker Compose中一些常用的命令，您可以根据需要使用它们来管理和操作Compose项目。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发系统设计的15个方向</title>
      <link href="/posts/3fece8a5.html"/>
      <url>/posts/3fece8a5.html</url>
      
        <content type="html"><![CDATA[<p>一道场景设计题目：<strong>如何设计一个高并发系统</strong>。<br><img src="https://cdn.l2xy.com/post_img/system_design_img/system_design_01.png"></p><h1 id="如何理解高并发系统"><a href="#如何理解高并发系统" class="headerlink" title="如何理解高并发系统"></a>如何理解高并发系统</h1><p>所谓设计<strong>高并发</strong>系统，就是设计一个系统，保证它<strong>整体可用</strong>的同时，能够<strong>处理很高的并发用户请求</strong>，能够承受<strong>很大的流量冲击</strong>。<br>我们要设计高并发的系统，那就需要处理好一些常见的系统瓶颈问题，如<strong>内存不足、磁盘空间不足，连接数不够，网络宽带不够</strong>等等，以应对突发的流量洪峰。</p><h1 id="1-分而治之，横向扩展"><a href="#1-分而治之，横向扩展" class="headerlink" title="1. 分而治之，横向扩展"></a>1. 分而治之，横向扩展</h1><p>如果你<strong>只部署一个应用，只部署一台服务器</strong>，那抗住的流量请求是非常有限的。并且，单体的应用，有单点的风险，如果它挂了，那服务就不可用了。<br>因此，设计一个高并发系统，我们可以<strong>分而治之，横向扩展</strong>。也就是说，采用分布式部署的方式，部署多台服务器，把流量分流开，让每个服务器都承担一部分的并发和流量，提升<strong>整体系统的并发能力</strong>。</p><h1 id="2-微服务拆分（系统拆分）"><a href="#2-微服务拆分（系统拆分）" class="headerlink" title="2. 微服务拆分（系统拆分）"></a>2. 微服务拆分（系统拆分）</h1><p>要提高系统的吞吐，提高系统的处理并发请求的能力。除了采用<strong>分布式部署的方式</strong>外，还可以做<strong>微服务拆分</strong>，这样就可以达到分摊请求流量的目的，提高了并发能力。<br>所谓的<strong>微服务拆分</strong>，其实就是把一个单体的应用，按功能单一性，拆分为多个服务模块。<strong>比如一个电商系统，拆分为用户系统、订单系统、商品系统等等</strong>。<br><img src="https://cdn.l2xy.com/post_img/system_design_img/system_design_02.png"></p><h1 id="3-分库分表"><a href="#3-分库分表" class="headerlink" title="3. 分库分表"></a>3. 分库分表</h1><p>当业务量暴增的话，MySQL单机<strong>磁盘容量会撑爆</strong>。并且，我们知道数据库连接数是有限的。<strong>在高并发的场景下</strong>，大量请求访问数据库，MySQL单机是扛不住的！高并发场景下，会出现too many connections报错。<br>所以高并发的系统，<strong>需要考虑拆分为多个数据库，来抗住高并发的毒打</strong>。而假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做<strong>分表</strong>了。一般千万级别数据量，就需要<strong>分表</strong>，每个表的数据量少一点，提升SQL查询性能。<br>当面试官问要求你设计一个高并发系统的时候，一般都要说到<strong>分库分表</strong>这个点。</p><h1 id="4-池化技术"><a href="#4-池化技术" class="headerlink" title="4. 池化技术"></a>4. 池化技术</h1><p>在高并发的场景下，<strong>数据库连接数</strong>可能成为瓶颈，因为连接数是有限的。<br>我们的请求调用数据库时，都会先获取数据库的连接，然后依靠这个连接来查询数据，搞完收工，最后关闭连接，释放资源。如果我们不用数据库连接池的话，每次执行SQL，都要创建连接和销毁连接，这就会导致每个查询请求都变得更慢了，相应的，系统处理用户请求的能力就降低了。<br>因此，需要使用池化技术，即<strong>数据库连接池、HTTP 连接池、Redis 连接池</strong>等等。使用数据库连接池，可以避免每次查询都新建连接，减少不必要的资源开销，通过复用连接池，<strong>提高系统处理高并发请求的能力</strong>。<br>同理，我们使用线程池，也能<strong>让任务并行处理，更高效地完成任务</strong>。</p><h1 id="5-主从分离"><a href="#5-主从分离" class="headerlink" title="5. 主从分离"></a>5. 主从分离</h1><p>通常来说，一台单机的MySQL服务器，可以支持500左右的TPS和10000左右的QPS，即单机支撑的<strong>请求访问是有限</strong>的。因此你做了分布式部署，部署了多台机器，部署了主数据库、从数据库。<br>但是，如果双十一搞活动，流量肯定会猛增的。如果所有的查询请求，都走主库的话，主库肯定扛不住，因为查询请求量是非常非常大的。因此一般都要求做<strong>主从分离</strong>，然后实时性要求不高的读请求，都去读从库，<strong>写的请求或者实时性要求高的请求，才走主库</strong>。这样就很好保护了主库，也提高了系统的吞吐。<br>当然，如果回答了主从分离，面试官可能扩展开问你<strong>主从复制原理，问你主从延迟问题</strong>等等，这块大家需要<strong>全方位复习好</strong>哈。</p><h1 id="6-使用缓存"><a href="#6-使用缓存" class="headerlink" title="6. 使用缓存"></a>6. 使用缓存</h1><p>无论是操作系统，浏览器，还是一些复杂的中间件，你都可以看到缓存的影子。我们使用缓存，主要是提升系统接口的性能，这样高并发场景，你的系统就可以支持更多的用户同时访问。<br>常用的缓存包括：Redis缓存，JVM本地缓存，memcached等等。就拿Redis来说，它单机就能轻轻松松应对几万的并发，你读场景的业务，可以用缓存来抗高并发。<br>缓存虽然用得爽，但是要<strong>注意缓存使用的一些问题</strong>：</p><ul><li>缓存与数据库的一致性问题</li><li>缓存雪崩</li><li>缓存穿透</li><li>缓存击穿</li></ul><h1 id="7-CDN，加速静态资源访问"><a href="#7-CDN，加速静态资源访问" class="headerlink" title="7. CDN，加速静态资源访问"></a>7. CDN，加速静态资源访问</h1><p>商品图片，icon等等静态资源，可以对页面做<strong>静态化处理，减少访问服务端的请求</strong>。如果用户分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到页面，可以使用CDN。CDN可以让用户就近获取所需内容。<br>什么是CDN？<br><code>Content Delivery Network/Content Distribution Network</code>,翻译过来就是内容分发网络，它表示将静态资源分发到位于多个地理位置机房的服务器，可以做到数据就近访问，加速了静态资源的访问速度，因此让系统更好处理正常别的动态请求。</p><h1 id="8-消息队列，削锋"><a href="#8-消息队列，削锋" class="headerlink" title="8. 消息队列，削锋"></a>8. 消息队列，削锋</h1><p>我们搞一些双十一、双十二等运营活动时，需要<strong>避免流量暴涨，打垮应用系统的风险</strong>。因此一般会引入消息队列，来应对<strong>高并发的场景</strong>。<br><img src="https://cdn.l2xy.com/post_img/system_design_img/system_design_03.png"><br>假设你的应用系统每秒最多可以处理2k个请求，每秒却有5k的请求过来，可以引入消息队列，应用系统每秒从消息队列拉2k请求处理得了。<br>有些伙伴担心这样可能会出现<strong>消息积压</strong>的问题：</p><ul><li>首先，搞一些运营活动，不会每时每刻都那么多请求过来你的系统（<strong>除非有人恶意攻击</strong>），高峰期过去后，积压的请求可以慢慢处理；</li><li>其次，如果消息队列长度超过最大数量，可以直接抛弃用户请求或跳转到错误页面；</li></ul><h1 id="9-ElasticSearch"><a href="#9-ElasticSearch" class="headerlink" title="9. ElasticSearch"></a>9. ElasticSearch</h1><p>Elasticsearch，大家都使用得比较多了吧，<strong>一般搜索功能都会用到它</strong>。它是一个分布式、高扩展、高实时的搜索与数据分析引擎，简称为ES。<br>我们在聊高并发，为啥聊到ES呢？因为ES可以扩容方便，天然支撑高并发。<strong>当数据量大的时候，不用动不动就加机器扩容，分库等等</strong>，可以考虑用ES来支持简单的查询搜索、统计类的操作。</p><h1 id="10-降级熔断"><a href="#10-降级熔断" class="headerlink" title="10. 降级熔断"></a>10. 降级熔断</h1><p><strong>熔断降级</strong>是保护系统的一种手段。当前互联网系统一般都是分布式部署的。而分布式系统中偶尔会出现某个基础服务不可用，最终导致整个系统不可用的情况, 这种现象被称为<strong>服务雪崩效应</strong>。<br>比如分布式调用链路A-&gt;B-&gt;C….，下图所示：<br><img src="https://cdn.l2xy.com/post_img/system_design_img/system_design_04.jpeg"></p><blockquote><p>如果服务C出现问题，比如是因为慢SQL导致调用缓慢，那将导致B也会延迟，从而A也会延迟。堵住的A请求会消耗占用系统的线程、IO、CPU等资源。当请求A的服务越来越多，占用计算机的资源也越来越多，最终会导致系统瓶颈出现，造成其他的请求同样不可用，最后导致业务系统崩溃。</p></blockquote><p>为了应对服务雪崩, 常见的做法是<strong>熔断和降级</strong>。最简单是加开关控制，当下游系统出问题时，开关打开降级，不再调用下游系统。还可以选用开源组件Hystrix来支持。<br>你要保证设计的系统能应对<strong>高并发场景</strong>，那肯定要考虑<strong>熔断降级</strong>逻辑进来。</p><h1 id="11-限流"><a href="#11-限流" class="headerlink" title="11. 限流"></a>11. 限流</h1><p>限流也是我们应对高并发的一种方案。我们当然希望，在高并发大流量过来时，系统能全部请求都正常处理。但是有时候没办法，系统的CPU、网络带宽、内存、线程等资源都是有限的。因此，我们要考虑限流。<br>如果你的系统每秒扛住的请求是一千，<strong>如果一秒钟来了十万请求呢</strong>？换个角度就是说，高并发的时候，流量洪峰来了，超过系统的承载能力，怎么办呢？<br>这时候，我们可以采取限流方案。就是为了保护系统，多余的请求，直接丢弃。</p><blockquote><p><strong>什么是限流</strong>：在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。</p></blockquote><p>可以使用Guava的RateLimiter单机版限流，也可以使用Redis分布式限流，还可以使用阿里开源组件sentinel限流。</p><h1 id="12-异步"><a href="#12-异步" class="headerlink" title="12. 异步"></a>12. 异步</h1><blockquote><p>回忆一下什么是同步，什么是异步呢？以方法调用为例，它代表调用方要阻塞等待被调用方法中的逻辑执行完成。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。</p></blockquote><p>因此，设计一个高并发的系统，<strong>需要在恰当的场景使用异步</strong>。如何使用异步呢？后端可以借用消息队列实现。比如在海量秒杀请求过来时，先放到消息队列中，快速响应用户，告诉用户请求正在处理中，这样就可以释放资源来处理更多的请求。秒杀请求处理完后，通知用户秒杀抢购成功或者失败。</p><h1 id="13-接口的常规优化"><a href="#13-接口的常规优化" class="headerlink" title="13. 接口的常规优化"></a>13. 接口的常规优化</h1><p>设计一个高并发的系统，需要设计接口的性能足够好，这样系统在相同时间，就可以处理更多的请求。当说到这里的话，可以跟面试官说说接口优化的一些方案了。<br><img src="https://cdn.l2xy.com/post_img/system_design_img/system_design_05.png"></p><h1 id="14-压力测试确定系统瓶颈"><a href="#14-压力测试确定系统瓶颈" class="headerlink" title="14. 压力测试确定系统瓶颈"></a>14. 压力测试确定系统瓶颈</h1><p>设计高并发系统，离不开最重要的一环，<strong>就是压力测试</strong>。就是在系统上线前，需要对系统进行压力测试，测清楚你的系统支撑的最大并发是多少，确定系统的瓶颈点，让自己心里有底，最好预防措施。<br>压测完要分析整个调用链路，性能可能出现问题是网络层（如带宽）、Nginx层、服务层、还是数据路缓存等中间件等等。<br>loadrunner是一款不错的压力测试工具，jmeter则是接口性能测试工具，都可以来做下压测。</p><h1 id="15-应对突发流量峰值：扩容-切流量"><a href="#15-应对突发流量峰值：扩容-切流量" class="headerlink" title="15. 应对突发流量峰值：扩容+切流量"></a>15. 应对突发流量峰值：扩容+切流量</h1><p>如果是突发的流量高峰，除了降级、限流保证系统不跨，我们可以采用这两种方案，保证系统尽可能服务用户请求：</p><ul><li>扩容：<strong>比如增加从库、提升配置的方式</strong>，提升系统/组件的流量承载能力。比如增加MySQL、Redis从库来处理查询请求。</li><li>切流量：<strong>服务多机房部署</strong>，如果高并发流量来了，把流量从一个机房切换到另一个机房。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker和K8S架构和实践</title>
      <link href="/posts/41482089.html"/>
      <url>/posts/41482089.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Kubernetes的由来"><a href="#1-Kubernetes的由来" class="headerlink" title="1. Kubernetes的由来"></a>1. Kubernetes的由来</h1><p>Kubernetes的名字来自希腊，意思是“舵手”或“领航员”。简称K8S，是用8代替名字中间的8个字符“ubernete”而成的缩写。所以，我们说K8S也就是说Kubernetes。在行业内，我们更习惯说K8S，而不是Kubernetes。<br>Google公司在10多年前开始采用的容器化基础架构——borg。随着Docker的大规模应用，Google采用Go语言对Borg框架进行了重写，开发出了Kubernetes。Google 于 2014 年开源了 Kubernetes 项目。<br>2015年4月，Borg论文《Large-scale cluster management at Google with Borg》伴随Kubernetes的高调宣传被Google首次公开，人们终于有缘得窥其全貌。<br>在Google内部，Kubernetes的原始代号曾经是Serven of Nine，即星际迷航中友好的“Borg”角色，它标识中的舵轮有七个轮辐就是对该项目代号的致意，如图所示。<br><img src="https://cdn.l2xy.com/post_img/k8s_img/k8s-01.png"><br>Kubernetes v1.0于2015年7月21日发布，紧随其后，Google与Linux基金会合作组建了Cloud Native Computing Foundation（云原生计算基金会，简称为CNCF），并将Kubernetes作为种子技术予以提供。这之后，Kubernetes进入了版本快速迭代期，从此不断地融入着新功能，如Federation、Network Policy API、RBAC、CRD和CSI，等等，并增加了对Windows系统的支持。<br>那K8S到底是做什么的呢？在说它之前我们少不了要对Docker进行一番概述。</p><h1 id="2-什么是Docker"><a href="#2-什么是Docker" class="headerlink" title="2. 什么是Docker"></a>2. 什么是Docker</h1><p><img src="https://cdn.l2xy.com/post_img/k8s_img/k8s-02.png"><br>Docker 公司的前身是 DotCloud，2010年成立，2013年更名 Docker，同年发布了 Docker-compose 组件提供容器的编排工具。2014年 Docker 发布1.0版本，2015年Docker 提供 Docker-machine，支持 windows 平台。<br>Docker基于Go 语言开发并遵从 Apache2.0 协议开源。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）<br><strong>那到底什么是Docker？</strong><br>Docker是一个C/S架构的系统，Docker守护进程运行在<strong>主机</strong>上， 然后通过Socket连接从<strong>客户端</strong>访问Docker守护进程。Docker守护进程从客户端接受命令，并按照命令，管理运行在主机上的<strong>容器</strong>。<br><strong>一个Docker是一个运行时的环境，简单理解为进程运行的集装箱。</strong><br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。Docker容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h2 id="2-1-Docker-VS-KVM"><a href="#2-1-Docker-VS-KVM" class="headerlink" title="2.1 Docker VS KVM"></a>2.1 Docker VS KVM</h2><p>Docker有着比虚拟机更少的抽象层。Docker利用的是宿主机的内核，VM需要的是Guest OS，分层架构如下：<br><img src="https://cdn.l2xy.com/post_img/k8s_img/k8s-03.png"><br>二者的架构不同：</p><ul><li>VM在宿主机操作系统的基础上创建虚拟层、虚拟化的操作系统和虚拟化的仓库，然后再安装应用；</li><li>Container(Docker容器)，在宿主机的操作系统上创建Docker引擎，在引擎的基础上再安装应用。</li></ul><p>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势：</p><ul><li>Docker 容器很快，启动和停止可以在秒级实现。</li><li>Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器。</li><li>Docker 通过类似Git的操作来方便用户获取、分发和更新应用镜像。</li><li>Docker 通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。</li><li>Docker 容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销。</li><li>Docker 利用Linux系统上的多种防护机制实现了严格可靠的隔离。从1.3版本开始，Docker引入了安全选项和镜像签名机制，极大地提高了使用Docker的安全性。<table><thead><tr><th><strong>特性</strong></th><th><strong>容器</strong></th><th><strong>虚拟机</strong></th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table></li></ul><h2 id="2-2-Docker-架构"><a href="#2-2-Docker-架构" class="headerlink" title="2.2 Docker 架构"></a>2.2 Docker 架构</h2><p>Docker 包括三个基本概念:</p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><h1 id="3-Kubernetes架构"><a href="#3-Kubernetes架构" class="headerlink" title="3. Kubernetes架构"></a>3. Kubernetes架构</h1><p>Docker不具备自动扩容、负载均衡以及分布式集群部署的能力。Kubernetes是容器集群的编排系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。它是基于容器（通常是Docker）之上的。<br>K8S是一个编排容器的工具，其实也是管理应用的全生命周期的一个工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，都非常的方便，而且可以做到故障自愈。<br>我们从整体架构来入手，来看看K8s架构。<br><img src="https://cdn.l2xy.com/post_img/k8s_img/k8s-04.png"></p><h2 id="3-1-组件"><a href="#3-1-组件" class="headerlink" title="3.1 组件"></a>3.1 组件</h2><p><strong>一个K8S集群包含一个master节点和一群node节点</strong></p><ul><li><p>Mater节点负责管理和控制</p></li><li><p>Node节点是工作负载节点，里面是具体的容器，容器中部署的是具体的服务。</p><h3 id="3-1-1-Master"><a href="#3-1-1-Master" class="headerlink" title="3.1.1 Master"></a>3.1.1 Master</h3><p>用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此。Mater节点包括API Server、Scheduler、Controller Manager、etcd。</p></li><li><p>API Server：整个集群的对外接口，供客户端和其他组件调用。</p></li><li><p>Scheduler：负责集群内部资源调度</p></li><li><p>Controller Manager：负责管理控制器。</p></li><li><p>etcd：用于保存集群中所有网络配置和对象状态信息。</p></li></ul><p>下面详细介绍下master组件<br><strong>1、API Server</strong><br>API Server是整个集群的统一入口，各组件的协调者，以HTTP的API形式对外提供服务，所有对象资源的增删改查和监听操作都交给API Server处理后再提交给etcd进行存储。<br><strong>2、Scheduler</strong><br>Scheduler负责集群内部资源调度，根据调度算法为新创建的pod选择一个node节点，Scheduler在整个集群中起到了承上启下的重要功能，承上是指负责接收Controller Manager创建的新的pod，为其安排一个node节点，启下是指当为pod选定node节点后，目标Node上的kubelet服务进程会接管该pod。<br><img src="https://cdn.l2xy.com/post_img/k8s_img/k8s-05.png"><br>简单描述下创建Pod的流程：</p><ul><li>通过kubectl发送创建pod的请求，命令会先被apiserver拦截，再把创建的pod存储到etcd的podQueue中</li><li>Scheduler发起调用请求，命令被apiserver拦截，获取etcd中podQueue.NodeList，使用调度算法（调度算法：预选调度、优选策略）选择一个合适的node节点</li><li>把确定了的合适的pod、node存储到etcd中</li><li>node节点上的Kubelet进程发送请求获取pod、node对应创建资源</li><li>node发现pod是本node需要创建的，kubelet就开始创建pod</li></ul><p><strong>3、Controller Manager</strong><br>每个资源都对应一个控制器（Kubernets Controller），用来处理集群中常规的后台任务，而Controller Manager是用来负责管理控制器的。<br>K8S集群有以下控制器：</p><ul><li>Replication/ReplicationSet Controller：保证RC中定义的副本数量与实际运行的pod数量一致。</li><li>Node Controller：管理维护Node，定期检查Node节点的健康状态，标识出失效和未失效的Node节点。</li><li>Namespace Controller：管理维护Namespace，定期清理无效的Namespace，包括Namespace下的API对象，例如pod和service等</li><li>Service Controller：管理维护Service，提供负载以及服务代理。</li><li>Endpoints Controller：管理维护Endpoints，即维护关联service和pod的对应关系，其对应关系通过Label来进行关联的</li><li>Service Account Controller：管理维护Service Account，为每个Namespace创建默认的Service Account，同时为Service Account创建Service Account Secret。</li><li>Persistent Volume Controller：持久化数据控制器，用来部署有状态服务</li><li>Deamon Set Controller：让每一个Node节点都运行相同的服务</li><li>Deployment Controller：无状态服务部署控制器</li><li>StateFulSet Controller：有状态服务部署控制器</li><li>Job Controller：管理维护Job，为Job创建一次性任务Pod，保证完成Job指定完成的任务数目。</li><li>Pod Autoscaler Controller：实现pod的自动伸缩，定时获取监控数据，进行策略匹配，当满足条件时执行pod的伸缩动作。</li></ul><p><strong>4、etcd</strong><br>etcd是一个第三方的服务，提供分布式键值对存储，用于保存网络配置、集群状态等信息。K8S中有两个服务需要用到etcd来协调和存储数据：网络插件flannel和K8S本身状态，其中flannel使用etcd存储网络配置信息，K8S本身使用etcd存储各种对象的状态和元信息配置。</p><h3 id="3-1-2-Node"><a href="#3-1-2-Node" class="headerlink" title="3.1.2 Node"></a>3.1.2 Node</h3><p>node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选）、pod<br><img src="https://cdn.l2xy.com/post_img/k8s_img/k8s-06.png"><br><strong>1、kubelet</strong><br>kubelet是Mater在Node节点上的代理，每个Node节点都会启动一个kubelet进程，用来处理Mater节点下发到Node节点的任务，管理本机运行容器的生命周期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点的状态等工作，kubelet将每个pod转换成一组容器。<br>kubelet默认监听四个端口：4194、10250、10255、10248</p><ul><li>4194端口：kubelet通过该端口可以获取到该节点的环境信息以及node上运行的容器状态等内容，访问 <a href="http://localhost:4194/">http://localhost:4194</a> 可以看到 cAdvisor 的管理界面,通过 kubelet 的启动参 数 –cadvisor-port 可以指定启动的端口。</li><li>10250端口：kubelet API的端口，也就是kubelet server与api server的通讯端口，定期请求apiserver获取自己所应当处理的任务，通过该端口可以访问和获取node资源及状态。</li><li>10248端口：健康检查的端口，通过访问该端口可以判断kubelet是否正常工作，可以通过 kubelet 的启动 参数 –healthz-port 和 –healthz-bind-address 来指定监听的地址和端口</li><li>10255端口：提供了pod和node的信息，接口以只读形式暴露出去，访问该端口不需要认证和鉴权。</li></ul><p><strong>2、kube-proxy</strong><br>在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作，kube-proxy本质上类似于一个反向代理，我们可以把每个节点上运行的kube-proxy看作是service的透明代理兼LB。<br>kube-proxy监听apiserver中service与endpoints的信息，配置iptables规则，请求通过iptables直接转发给pod。<br><img src="https://cdn.l2xy.com/post_img/k8s_img/k8s-07.png"><br><strong>3、docker</strong><br>运行容器的引擎，pod内部运行的都是容器，这个容器是由Docker引擎创建的，Docker引擎是node节点的基础服务。<br><strong>4、pod</strong><br>pod是最小的部署单元，一个pod由一个或多个容器组成，pod中共享存储和网络，在同一个Docker主机上运行。pod内部可以运行一个或多个容器，一般情况下，为了便于管理，一个pod下只运行一个容器。常用于sidercar服务部署。</p><h3 id="3-1-3-Pod"><a href="#3-1-3-Pod" class="headerlink" title="3.1.3 Pod"></a>3.1.3 Pod</h3><p>pod：负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制，被部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将网络和存储从底层容器中抽象出来。<br>pod是一个大的容器，由K8S创建，pod内部的是docker容器，由Docker引擎创建。K8S不会直接管理容器，而是管理Pod。pod内部封装了docker容器，同时拥有自己的ip地址，也有用自己的HostName，Pod就像一个物理机一样，实际上Pod就是一个虚拟化的容器（进程），pod中运行的是一个或者多个容器。<br><img src="https://cdn.l2xy.com/post_img/k8s_img/k8s-08.png"><br>pod的作用是管理线上运行的应用程序，在通常情况下，在服务上线部署的时候，pod通常被用来部署一组相关的服务。而一个调用链上的服务就叫做一组相关的服务。但是实际生产上一般是一个Pod对应一个服务，不会在一个Pod上部署太多的服务。<br>K8S中的pause容器主要为每个业务容器提供以下功能，从而对各个Pod进行了隔离：</p><ul><li>PID命名空间隔离：pod中不同的应用程序可以看到其他应用程序的进程ID</li><li>网络命名空间隔离：Pod中多个容器能够访问同一个IP和端口范围</li><li>IPC命名空间隔离：Pod中多个容器能够使用System VIPC或POSIX消息队列进行通信</li><li>UTS命名空间隔离：pod中多个容器共享一个主机名和挂在卷</li><li>Pod中各个容器可以访问在Pod级别定义的Volumes</li></ul><p>一个Pod创建的过程：首先kubelet会先创建一个pod，然后立马会创建一个pause容器，pause容器是默认创建的，然后再创建内部其他的业务容器。</p><h3 id="3-1-4复制控制器（Replication-controller）"><a href="#3-1-4复制控制器（Replication-controller）" class="headerlink" title="3.1.4复制控制器（Replication controller）"></a>3.1.4复制控制器（Replication controller）</h3><p>用于控制应在集群某处运行的完全相同的容器集副本数量。</p><h3 id="3-1-5-服务（Service）"><a href="#3-1-5-服务（Service）" class="headerlink" title="3.1.5 服务（Service）"></a>3.1.5 服务（Service）</h3><p>将工作内容与容器集分离。Kubernetes 服务代理会自动将服务请求分发到正确的容器集——无论这个容器集会移到集群中的哪个位置，甚至可以被替换掉。</p><h3 id="3-1-6-Kubelet"><a href="#3-1-6-Kubelet" class="headerlink" title="3.1.6 Kubelet"></a>3.1.6 Kubelet</h3><p>运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。</p><h3 id="3-1-7-kubectl"><a href="#3-1-7-kubectl" class="headerlink" title="3.1.7 kubectl"></a>3.1.7 kubectl</h3><p>Kubernetes 的命令行配置工具。</p><h2 id="3-2-控制器实例"><a href="#3-2-控制器实例" class="headerlink" title="3.2 控制器实例"></a>3.2 控制器实例</h2><p>kubernetes中建立了很多的controller（控制器），这相当于一个控制机，来管理pod的状态和行为。<br>Pod分为自主式Pod和控制器管理的Pod。类型：</p><ul><li>ReplicationController和ReplicaSet（无状态服务RS-Deployment）</li><li>Deployment 无状态负载</li><li>DaemonSet 守护进程集（以Node为节点部署）</li><li>StateFulSet 有状态负载（有状态服务）</li><li>Job/cronJob 普通任务/计划任务（批处理任务部署）</li><li>Horizontal Pod Autoscaling 自动扩展（根据利用率平滑扩，可以理解为并不是一个控制器，而是一个控制器的附属品，以其他控制器作为模板）</li></ul><h3 id="3-2-1-ReplicationController-RC"><a href="#3-2-1-ReplicationController-RC" class="headerlink" title="3.2.1 ReplicationController(RC)"></a>3.2.1 ReplicationController(RC)</h3><p>ReplicationController用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收。在新版本的Kubernetes 中建议使用ReplicaSet来取代ReplicationControlle，如果集群的资源不够，会动态的显示可用的pod。<br><strong>ReplicaSet(RS)</strong><br>ReplicaSet跟ReplicationController只是名字不一样，并且ReplicaSet支持集合式的selector，通过标签（matchLabels）来管理 Pod。虽然ReplicaSet 可以独立使用，但一般还是建议使用Deployment 来自动管理ReplicaSet，避免不兼容问题(比如ReplicaSet不支持rolling update但Deployment 支持)。<br>基本的yaml配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>  <span class="hljs-comment">#api版本定义</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span>  <span class="hljs-comment">#定义资源类型为ReplicaSet</span><br><span class="hljs-attr">metadata:</span>  <span class="hljs-comment">#元数据定义</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span>  <span class="hljs-comment"># ReplicaSet的规格定义</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>  <span class="hljs-comment">#定义副本数量为3个</span><br>  <span class="hljs-attr">selector:</span>  <span class="hljs-comment">#标签选择器，定义匹配Pod的标签</span><br>    <span class="hljs-attr">matchLabels:</span>  <span class="hljs-comment"># RS通过labels来确定某个Pod是否归该RS管，即RS通过标签来监控Pod</span><br>      <span class="hljs-attr">tier:</span> <span class="hljs-string">test</span><br>  <span class="hljs-attr">template:</span>  <span class="hljs-comment">#Pod的模板定义，与上面Pod的定义一致</span><br>    <span class="hljs-attr">metadata:</span>  <span class="hljs-comment">#Pod的元数据定义</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">app-pod</span>  <span class="hljs-comment">#自定义Pod的名称</span><br>      <span class="hljs-attr">labels:</span>  <span class="hljs-comment">#定义Pod的标签，需要和上面的标签选择器内匹配规则中定义的标签一致，可以多出其他标签</span><br>        <span class="hljs-attr">tier:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">spec:</span>  <span class="hljs-comment">#Pod的规格定义</span><br>      <span class="hljs-attr">containers:</span>  <span class="hljs-comment">#容器定义</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>  <span class="hljs-comment">#容器名称</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">hub.org/library/nginx:v1</span>  <span class="hljs-comment">#容器镜像</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>  <span class="hljs-comment">#拉取镜像的规则</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">GET_HOSTS_FROM</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">dns</span><br>        <span class="hljs-attr">ports:</span>  <span class="hljs-comment">#暴露端口</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>  <span class="hljs-comment">#端口名称</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></tbody></table></figure><p>创建并查看RS：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 RS</span><br>[root@k8s-master01 yaml]# kubectl create -f rs.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看创建的 rs</span><br>[root@k8s-master01 yaml]# kubectl get rs<br>NAME       DESIRED   CURRENT   READY   AGE<br>frontend   3         3         3       25m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看rs创建的 3 个 Pod，</span><br>[root@k8s-master01 yaml]# kubectl get pod<br>NAME             READY   STATUS    RESTARTS   AGE<br>frontend-cbhjc   1/1     Running   0          25m<br>frontend-dffcd   1/1     Running   0          25m<br>frontend-qmugq   1/1     Running   0          25m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除 Pod后，RS会自动重建 Pod，维持设置的副本数（3），通过 Pod 后的随机值可以看出，Pod是重新创建的</span><br>[root@k8s-master01 yaml]# kubectl delete pod --all<br>pod "frontend-cbhjc" deleted<br>pod "frontend-dffcd" deleted<br>pod "frontend-qmugq" deleted<br>[root@k8s-master01 yaml]# kubectl get pod<br>NAME             READY   STATUS    RESTARTS   AGE<br>frontend-5lgj9   1/1     Running   0          19s<br>frontend-gxhrv   1/1     Running   0          19s<br>frontend-rwhc5   1/1     Running   0          19s<br></code></pre></td></tr></tbody></table></figure><p>修改pod的labels：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod的标签</span><br>[root@k8s-master01 yaml]# kubectl get pod --show-labels<br>NAME             READY   STATUS    RESTARTS   AGE     LABELS<br>frontend-5lgj9   1/1     Running   0          9m20s   tier=test<br>frontend-gxhrv   1/1     Running   0          9m20s   tier=test<br>frontend-rwhc5   1/1     Running   0          9m20s   tier=test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改其中一个Pod的标签</span><br>[root@k8s-master01 yaml]# kubectl label pod frontend-5lgj9 tier=new --overwrite=true<br>pod/frontend-5lgj9 labeled<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RS会通过匹配 labels 来确定哪些 Pod 是自己管理的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当改变了 frontend-5lgj9 的 labels 时，该 Pod 已经不归 frontend 这个 RS 管了，所以 RS 又重新创建了一个Pod</span><br>[root@k8s-master01 yaml]# kubectl get pod --show-labels<br>NAME             READY   STATUS    RESTARTS   AGE   LABELS<br>frontend-5lgj9   1/1     Running   0          84m   tier=test<br>frontend-7fbp8   1/1     Running   0          4s    tier=new<br>frontend-gxhrv   1/1     Running   0          84m   tier=test<br>frontend-rwhc5   1/1     Running   0          84m   tier=test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除RS，Pod也会被删除</span><br>[root@k8s-master01 yaml]# kubectl delete rs test<br>[root@k8s-master01 yaml]# kubectl get pod --show-labels<br>NAME             READY   STATUS    RESTARTS   AGE   LABELS<br>frontend-5lgj9   1/1     Running   0          98m   tier=new<br></code></pre></td></tr></tbody></table></figure><h3 id="3-2-2-Deployment"><a href="#3-2-2-Deployment" class="headerlink" title="3.2.2 Deployment"></a>3.2.2 Deployment</h3><p>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义 (declarative) 方法,用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括:</p><ul><li>定义 Deployment 来创建 ReplicaSet和Pod</li><li>滚动升级和回滚应用</li><li>扩容和缩容</li><li>暂停和继续 Deployment</li></ul><p>Deployment是通过管理RS来管理Pod的。<br>滚动更新：更新V1到V2，新建一个RS然后创建1个V2，删除1个V1：达到滚动更新，此时RS，停用、保留，可以回滚：<br><strong>创建并查看</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>  <span class="hljs-comment">#api版本定义</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>  <span class="hljs-comment">#定义资源类型为Deploymant</span><br><span class="hljs-attr">metadata:</span>  <span class="hljs-comment">#元数据定义</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-test</span> <span class="hljs-comment">#deployment控制器名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>  <span class="hljs-comment">#名称空间</span><br><span class="hljs-attr">spec:</span>  <span class="hljs-comment">#deployment控制器的规格定义</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>  <span class="hljs-comment">#定义deployment副本数量为2个</span><br>  <span class="hljs-attr">selector:</span>  <span class="hljs-comment">#标签选择器，定义匹配Pod的标签</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-test</span><br>  <span class="hljs-attr">template:</span>  <span class="hljs-comment">#Pod的模板定义</span><br>    <span class="hljs-attr">metadata:</span>  <span class="hljs-comment">#Pod的元数据定义</span><br>      <span class="hljs-attr">labels:</span>  <span class="hljs-comment">#定义Pod的标签，和上面的标签选择器标签一致，可以多出其他标签</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-test</span><br>    <span class="hljs-attr">spec:</span>  <span class="hljs-comment">#Pod的规格定义</span><br>      <span class="hljs-attr">containers:</span>  <span class="hljs-comment">#容器定义</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>  <span class="hljs-comment">#容器名称</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">hub.org/library/nginx:v1</span>  <span class="hljs-comment">#容器镜像</span><br>        <span class="hljs-attr">ports:</span>  <span class="hljs-comment">#暴露端口</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>  <span class="hljs-comment">#端口名称</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></tbody></table></figure><p>创建Deployment并查看：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建Deployment对象</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--record 可以方便的查看 revision 的变化（roolout 被触发（spec.template被更改）就会创建一个 revision）</span><br>kubectl apply -f deployment.yaml --record<br><br>[root@k8s-master01 yaml]# kubectl get deployment<br>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br>nginx-deployment   3/3     3            3           8m30s<br>[root@k8s-master01 yaml]# kubectl get rs<br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-645ccc47cc   3         3         3       9m32s<br>[root@k8s-master01 yaml]# kubectl get pod<br>NAME                                READY   STATUS    RESTARTS   AGE<br>nginx-deployment-645ccc47cc-885sz   1/1     Running   0          9m37s<br>nginx-deployment-645ccc47cc-k5jcm   1/1     Running   0          9m37s<br>nginx-deployment-645ccc47cc-rwnk5   1/1     Running   0          9m37s<br></code></pre></td></tr></tbody></table></figure><p>kubectl get deployment 命令所显示的字段有：</p><ul><li>NAME：Deployment 的名称。</li><li>READY：显示应用程序的可用的副本数。显示的模式是“就绪个数/期望个数”。</li><li>UP-TO-DATE：显示为了达到期望状态已经更新的副本数。</li><li>AVAILABLE：显示应用可供用户使用的副本数。</li><li>AGE：显示应用程序正常运行的时间。</li></ul><p><strong>扩容</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale deployment nginx-test --replicas=5<br></code></pre></td></tr></tbody></table></figure><p><strong>更新</strong><br>修改 Pod 模板相关的配置参数便能完成 Deployment 控制器资源的更新。<br>更新容器的镜像：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl set image deployment/[deployment名称] [容器名称]=[镜像名称]<br></code></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl set image deployment/nginx-test nginx=myapp:v2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看到原来的 RS 已经停用并做为备份，并创建了新的 RS</span><br>[root@k8s-master01 yaml]# kubectl get rs<br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-645ccc47cc   0         0         0       4h45m<br>nginx-deployment-6c67f64d64   5         5         4       8s<br></code></pre></td></tr></tbody></table></figure><p><strong>回滚</strong><br>可以通过设置 .spec.revisonHistoryLimit 项来指定 deployment 最多保留多少 revision 历史记录。默认的会保留所有的 revision；如果将该项设置为 0，Deployment 就不允许回退了</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">回到上一个版本</span><br>kubectl rollout undo deployment/nginx-test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前的更新状态</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果 rollout 成功完成， 该命令将返回一个 0 值的 Exit Code</span><br>kubectl rollout status deployments/nginx-test<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> $?<span class="hljs-comment"># 输出 0</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前版本（自定义 Pod 的输出）</span><br>kubectl get pods -o custom-columns=Name:metadata.name,Image:spec.containers[0].image<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过该命令查看更新历史记录，Pod 模板被修改就会创建一个 revision</span><br>kubectl rollout history deployment/nginx-test<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询结果，创建 Deployment 时加上 --record 才会显示CHANGE-CAUSE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">REVISION  CHANGE-CAUSE</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1         kubectl apply --filename=deployment.yaml --record=<span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2         kubectl apply --filename=deployment.yaml --record=<span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">回滚到指定版本</span><br>kubectl rollout undo deployment/nginx-deployment --to-revision=1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">暂停 deployment 的更新</span><br>kubectl rollout pause deployment/nginx-test<br></code></pre></td></tr></tbody></table></figure><p><strong>更新策略</strong><br>Deployment 可确保在更新时仅关闭一定数量的 Pod。默认情况下，它确保至少所需 Pods 75% 处于运行状态（最大不可用比例为 25%），这个参数可以自定义。<br>Deployment 还确保创建 Pod 数量只可能比期望 Pods 数高一点点。 默认情况下，它可确保启动的 Pod 个数比期望个数最多多出 25%（最大峰值 25%）。<br>如果旧的 Pod 创建还没有达到期望数时（如期望数是 5，但现在只创建了3个），就更新了 Pod。在这种情况下，Deployment 会立即杀掉已创建的旧 Pod，并开始创建新 Pod。它不会等到所有的旧 Pod 都创建完成后才开始创建新 Pod。<br>例如，如果仔细查看上述 Deployment （kubectl describe deployment），将看到它首先创建了一些新的 Pod，然后删除了一些旧的 Pods。并且创建新的 Pods 创建没有到达 25% ，它不会杀死老 Pods，直到有足够的数量新的 Pods 已经出现。 然后开始杀死老 Pods ，在足够数量的旧 Pods 被杀死前并没有创建新 Pods。它确保至少 4 个 Pod 可用，同时最多总共 7 个 Pod 可用。</p><h3 id="3-2-3-Horizontal-Pod-Autoscaling-HPA"><a href="#3-2-3-Horizontal-Pod-Autoscaling-HPA" class="headerlink" title="3.2.3 Horizontal Pod Autoscaling(HPA)"></a>3.2.3 Horizontal Pod Autoscaling(HPA)</h3><p>HPA根据利用率平滑扩展，仅适用于Deployment 和ReplicaSet ，在V1版本中仅支持根据Pod的CPU利用率扩所容，在vlalpha 版本中，支持根据内存和用户自定义的metric扩缩容。<br>HPA基于RS定义，并且监控V2Pod的资源利用率：<br>当符合条件后，会创建Pod：<br>每次创建后判断条件，符合后继续创建，直到最大值。使用率小就回收，直到最小值，实现水平自动扩展（弹性伸缩）。</p><h3 id="3-3-4-StatefulSet"><a href="#3-3-4-StatefulSet" class="headerlink" title="3.3.4 StatefulSet"></a>3.3.4 StatefulSet</h3><p>StatefulSet是为了解决有状态服务的问题(对应Deployments 和Repl icaSets是为无状态服务而设计)，其应用场景包括:</p><ul><li>稳定的持久化存储，即Pod重新调度(比如删除后重新创建)后还是能访问到相同的持久化数据，基于PVC来实现</li><li>稳定的网络标志，即Pod重新调度后其PodName 和HostName 不变，基于Headless Service(即没有Cluster IP的Service )来实现</li><li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候**要依据定义的顺序依次依次进行(**即从0到N-1,在下一个Pod运行之前所有之前的Pod必须都是Running 和Ready状态)，基于init containers来实现有序收缩，有序删除(即从N-1到0)</li><li>部署顺序和收缩顺序是相反的。</li></ul><p>一个完整的 StatefulSet 应用由三个部分组成： headless service（无头服务）、StatefulSet controller、volumeClaimTemplate(PVC)。</p><ul><li>Headless Service：定义 Pod 网络标识( DNS domain)；</li><li>volumeClaimTemplates ：存储卷申请模板，创建 PVC。指定 pvc 名称大小，将自动创建 pvc，且 pvc 必须由存储类供应；</li><li>StatefulSet ：定义具体应用，名为 APP，有三个 Pod 副本，并为每个 Pod 定义了一个域名部署 statefulset。</li></ul><p><strong>为什么需要 headless service 无头服务？</strong><br>在用 Deployment 时，每一个 Pod 名称是没有顺序的，是随机字符串，因此是 Pod 名称是无序的，但是在 statefulset 中要求必须是有序 ，每一个 pod 不能被随意取代，pod 重建后 pod 名称还是一样的。而 pod IP 是变化的，所以是以 Pod 名称来识别。pod 名称是 pod 唯一性的标识符，必须持久稳定有效。这时候要用到无头服务，它可以给每个 Pod 一个唯一的名称 。<br>除此之外，StatefulSet 在 Headless Service 的基础上又为 StatefulSet 控制的每个 Pod 副本创建了一个 DNS 域名，这个域名的格式为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">(podname).(headless server name)</span><br>FQDN：$(podname).(headless server name).namespace.svc.cluster.local<br></code></pre></td></tr></tbody></table></figure><p><strong>为什么需要 volumeClaimTemplate？</strong><br>对于有状态的副本集都会用到持久存储，对于分布式系统来讲，它的最大特点是数据是不一样的，所以各个节点不能使用同一存储卷，每个节点有自已的专用存储，但是如果在 Deployment 中的 Pod template 里定义的存储卷，是所有副本集共用一个存储卷，数据是相同的，因为是基于模板来的；而 statefulset 中每个 Pod 都要自已的专有存储卷，所以 statefulset 的存储卷就不能再用 Pod 模板来创建了，于是 statefulSet 使用 volumeClaimTemplate，称为卷申请模板，它会为每个 Pod 生成不同的 pvc，并绑定 pv，从而实现各 pod 有专用存储。这就是为什么要用 volumeClaimTemplate 的原因。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># headless service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><span class="hljs-comment"># 通过指定 clusterIP 为 None 实现 headless service</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><span class="hljs-comment"># (A) A，B，C 三处要相同，根据 label 来匹配哪些 pod 归无头服务管</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">app</span><span class="hljs-comment"># (B) A，B，C 三处要相同，根据 label 匹配决定哪些 pod 归StatefulSet管</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">"app"</span><span class="hljs-comment"># 指定 Service 名称（上面创建的，一定要是个无头服务）</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><span class="hljs-comment"># 副本数</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><span class="hljs-comment"># (C) A，B，C 三处要相同，label标签</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><span class="hljs-comment"># 容器信息</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">docer/myapp:v2</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><span class="hljs-comment"># 释放的端口</span><br>              <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><span class="hljs-comment"># 端口名字</span><br>          <span class="hljs-attr">volumeMounts:</span><span class="hljs-comment"># 挂载</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span> <span class="hljs-comment"># 容器内目录</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><span class="hljs-comment"># 卷请求声明模板(pvc模板)</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>      <span class="hljs-attr">spec:</span><br>        <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">"ReadWriteOnce"</span> ]<span class="hljs-comment"># 指定要请求的卷的访问模式</span><br>        <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">"nfs"</span><span class="hljs-comment"># 指定要请求的卷的类名，只有与 PV 中的storageClassName 相同时，才会匹配</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><span class="hljs-comment"># 指定要请求的卷大小必须满足 1G</span><br></code></pre></td></tr></tbody></table></figure><h3 id="3-3-5-DaemonSet"><a href="#3-3-5-DaemonSet" class="headerlink" title="3.3.5 DaemonSet"></a>3.3.5 DaemonSet</h3><p>DaemonSet确保全部(或者一些) Node上运行一个Pod的副本（同一个 Node 上运行多个 Pod 需要多个 DaemonSet）。当有Node加入集群时，也会为他们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收。删除DaemonSet 将会删除它创建的所有Pod。使用DaemonSet的–些典型用法:</p><ul><li><p>运行集群存储daemon, 例如在每个Node上运行glusterd、 ceph；</p></li><li><p>在每个Node上运行日志收集daemon, 例如fluentd、 logstash；</p></li><li><p>在每个Node上运行监控daemon, 例如Prometheus Node Exporter。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>             <span class="hljs-comment">#api版本定义</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span>                 <span class="hljs-comment">#定义资源类型为DaemonSet</span><br><span class="hljs-attr">metadata:</span>                       <span class="hljs-comment">#元数据定义</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">daemonset-nginx</span>         <span class="hljs-comment">#daemonset控制器名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>            <span class="hljs-comment">#名称空间</span><br>  <span class="hljs-attr">labels:</span>                       <span class="hljs-comment">#设置daemonset的标签</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">daemonset</span><br><span class="hljs-attr">spec:</span>                           <span class="hljs-comment">#DaemonSet控制器的规格定义</span><br>  <span class="hljs-attr">selector:</span>                     <span class="hljs-comment">#指定匹配pod的标签</span><br>    <span class="hljs-attr">matchLabels:</span>                <span class="hljs-comment">#指定匹配pod的标签</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">daemonset-APP</span>      <span class="hljs-comment">#注意：这里需要和template中定义的标签一样</span><br>  <span class="hljs-attr">template:</span>                     <span class="hljs-comment">#Pod的模板定义</span><br>    <span class="hljs-attr">metadata:</span>                   <span class="hljs-comment">#Pod的元数据定义</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>      <span class="hljs-attr">labels:</span>                   <span class="hljs-comment">#定义Pod的标签，需要和上面的标签一致，可以多出其他标签</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">daemonset-app</span><br>    <span class="hljs-attr">spec:</span>                       <span class="hljs-comment">#Pod的规格定义</span><br>      <span class="hljs-attr">containers:</span>               <span class="hljs-comment">#容器定义</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app-pod</span>         <span class="hljs-comment">#容器名字</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">hub.org/library/nginx:v1</span>     <span class="hljs-comment">#容器镜像</span><br>        <span class="hljs-attr">ports:</span>                  <span class="hljs-comment">#暴露端口</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>            <span class="hljs-comment">#端口名称</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>     <span class="hljs-comment">#暴露的端口</span><br></code></pre></td></tr></tbody></table></figure><p>可以看到两个节点上各运行一个：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@k8s-master01</span> <span class="hljs-string">yaml</span>]<span class="hljs-comment"># kubectl get pod -o wide</span><br><span class="hljs-string">NAME</span>                                <span class="hljs-string">READY</span>   <span class="hljs-string">STATUS</span>    <span class="hljs-string">RESTARTS</span>   <span class="hljs-string">AGE</span>    <span class="hljs-string">IP</span>            <span class="hljs-string">NODE</span>         <span class="hljs-string">NOMINATED</span> <span class="hljs-string">NODE</span>   <span class="hljs-string">READINESS</span> <span class="hljs-string">GATES</span><br><span class="hljs-string">daemonset-nginx-js4tyu</span>             <span class="hljs-number">1</span><span class="hljs-string">/1</span>     <span class="hljs-string">Running</span>   <span class="hljs-number">0</span>          <span class="hljs-string">82s</span>    <span class="hljs-number">10.244</span><span class="hljs-number">.1</span><span class="hljs-number">.21</span>   <span class="hljs-string">k8s-node01</span>   <span class="hljs-string">&lt;none&gt;</span>           <span class="hljs-string">&lt;none&gt;</span><br><span class="hljs-string">daemonset-nginx-kkc5nb</span>              <span class="hljs-number">1</span><span class="hljs-string">/1</span>     <span class="hljs-string">R</span><br></code></pre></td></tr></tbody></table></figure><h3 id="3-2-6-Job"><a href="#3-2-6-Job" class="headerlink" title="3.2.6 Job"></a>3.2.6 Job</h3><p>job负责一次性的批处理任务，即仅执行一次的任务，他保证批处理任务的一个或者多个Pod成功结束。<br>随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。如 删除 Job ，会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><span class="hljs-comment"># kubectl explain job 查看 job 版本</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pi</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">pi</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pi</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">perl</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">"python"</span>,<span class="hljs-string">"-Mbignum=bpi"</span>,<span class="hljs-string">"-wle"</span><span class="hljs-string">print</span> <span class="hljs-string">bpi(2000)"</span>]  <span class="hljs-comment"># 通过 python 进行圆周率计算，输出小数点后2000位</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><span class="hljs-comment"># 重启策略</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>spec.template 格式同 Pod</p></li><li><p>容器的 restartPolicy 仅支持 Never 或 OnFailure，因为 Job 就是批处理任务，执行完自动退出，如果是 Always，那么就会不断的执行</p></li><li><p>单个 Pod 时，默认 Pod 成功运行后（返回码为 0） Job 即结束</p></li><li><p>spec.completions：标志Job结束需要成功运行的 Pod 个数，默认为 1</p></li><li><p>spec.parallelism：标志并行运行的 Pod 的个数，默认为 1</p></li><li><p>spec.activeDeadlineSeconds：标志失败 Pod 的重试最大时间，超过这个时间不会继续重试</p></li></ul><p><strong>Cronjob</strong><br>Cronjob管理基于时间的Job，即在给定时间点运行一次或周期性地在给定时间点运行Job。<br>创建 Job 操作应该是幂等的。CronJob 仅负责创建与其调度时间相匹配的 Job，而 Job 又负责管理其代表的 Pod。<br>CronJob 的参数</p><ul><li>spec.schedule：调度指定任务运行周期，格式同 Cron，必填</li><li>spec.jobTemplate：Job 模板指定需要运行的任务，格式同 Job，必填</li><li>spec.startingDeadlineSeconds：启动 Job 的期限（秒级别），可选字段。如果因为任何原因而错过了被调度的时间，那么错过执行时间的 Job 将被认为是失败的。如果没有指定，则没有期限</li><li>spec.concurrencyPolicy：并发策略，可选字段。它指定了如何处理被 Cron Job 创建的 Job 的并发执行。只允许指定下面策略中的一种：Allow （默认）：允许并发执行运行 Job；Forbid ：禁止并发运行，如果前一个还没有完成，则直接跳过下一个，需配置；Replace ：取消当前正在运行的 Job，用一个新的来替换，需配置。注意：当前策略只能应用于同一个 Cron Job 创建的 Job。如果存在多个 Cron Job，它们创建的 Job 之间总是允许并发运行。</li><li>spec.suspend：挂起，可选字段。如果设置为 true ，后续所有执行都会被挂起。它对已经开始执行的 Job 不起作用。默认值为 false 。</li><li>spec.successfulJobsHistoryLimit 和 .spec.failedJobsHistoryLimit：历史限制，可选字段。它们指定了可以保留多少完成和失败的 Job。默认情况下，它们分别设置为 3 和 1 。设置限制的值为 0 ，相关类型的 Job 完成后将不会被保留。<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1beta1</span> <br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span> <br><span class="hljs-attr">metadata:</span> <br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello</span> <br><span class="hljs-attr">spec:</span> <br>  <span class="hljs-attr">schedule:</span> <span class="hljs-string">"*/1 16 * * *"</span> <br>  <span class="hljs-attr">jobTemplate:</span> <br>    <span class="hljs-attr">spec:</span> <br>      <span class="hljs-attr">template:</span> <br>        <span class="hljs-attr">spec:</span> <br>          <span class="hljs-attr">containers:</span> <br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">go</span> <br>            <span class="hljs-attr">image:</span> <span class="hljs-string">ubox</span> <br>            <span class="hljs-attr">args:</span> <span class="hljs-comment"># 运行命令，输出当前时间</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span> <br>            <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span> <br>            <span class="hljs-bullet">-</span> <span class="hljs-string">date;</span> <span class="hljs-string">echo</span> <span class="hljs-string">Hello</span> <span class="hljs-string">from</span> <span class="hljs-string">the</span> <span class="hljs-string">Kubernetes</span> <span class="hljs-string">cluster</span> <br>          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span> <br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@k8s-master01</span> <span class="hljs-string">yaml</span>]<span class="hljs-comment"># kubectl get cronjob</span><br><span class="hljs-string">NAME</span>    <span class="hljs-string">SCHEDULE</span>      <span class="hljs-string">SUSPEND</span>   <span class="hljs-string">ACTIVE</span>   <span class="hljs-string">LAST</span> <span class="hljs-string">SCHEDULE</span>   <span class="hljs-string">AGE</span><br><span class="hljs-string">go</span>   <span class="hljs-string">*/1</span> <span class="hljs-string">*</span> <span class="hljs-string">*</span> <span class="hljs-string">*</span> <span class="hljs-string">*</span>   <span class="hljs-literal">False</span>     <span class="hljs-number">0</span>        <span class="hljs-string">&lt;none&gt;</span>          <span class="hljs-string">29s</span><br><br>[<span class="hljs-string">root@k8s-master01</span> <span class="hljs-string">yaml</span>]<span class="hljs-comment"># kubectl get job</span><br><span class="hljs-string">NAME</span>               <span class="hljs-string">COMPLETIONS</span>   <span class="hljs-string">DURATION</span>   <span class="hljs-string">AGE</span><br><span class="hljs-string">go-1603320660</span>   <span class="hljs-number">1</span><span class="hljs-string">/1</span>           <span class="hljs-string">108s</span>       <span class="hljs-string">2m4s</span><br><span class="hljs-string">go-1603320720</span>   <span class="hljs-number">0</span><span class="hljs-string">/1</span>           <span class="hljs-string">61s</span>        <span class="hljs-string">61s</span><br><span class="hljs-string">go-1603320780</span>   <span class="hljs-number">0</span><span class="hljs-string">/1</span>           <span class="hljs-string">34s</span>         <span class="hljs-string">34s</span><br><br><span class="hljs-comment"># 删除 CronJob</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">delete</span> <span class="hljs-string">deployment/nginx-test</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h1 id="4-高频操作"><a href="#4-高频操作" class="headerlink" title="4. 高频操作"></a>4. 高频操作</h1><p>集群信息的各种查看基本上是在Master节点操作<br>1、 查看集群的配置信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl cluster-info<br></code></pre></td></tr></tbody></table></figure><p>2、查看 Node的状态</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get nodes<br>kubectl get node [IP] //节点IP可以用空格隔开写多个<br>kubectl describe node [IP]<br>kubectl delete node [IP]<br></code></pre></td></tr></tbody></table></figure><p>3、查看 Service 基本信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get service<br></code></pre></td></tr></tbody></table></figure><p>4、查看POD的状态</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods --all-namespaces or kubectl get pods -A<br>kubectl get po --namespace=default<br>kubectl get po --namespace={default,kube-system}<br></code></pre></td></tr></tbody></table></figure><p>5、同时查看多种资源信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pod,svc -n kube-system<br></code></pre></td></tr></tbody></table></figure><p>6、查看资源类型所对应的Apiversion</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl explain pod<br></code></pre></td></tr></tbody></table></figure><p>7、查看字段帮助信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl explain deployment<br>kubectl explain deployment.spec<br>kubectl explain deployment.spec.replicas<br></code></pre></td></tr></tbody></table></figure><p>8、 查看一个Servcie 的pod配置和参数</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pod -l name=[service-name] -o wide<br>kubectl get rc<br>kubectl get cm<br>kubectl get rc [service-name] -o yaml<br>kubectl get cm [service-name] -o yaml<br></code></pre></td></tr></tbody></table></figure><p>9、锁定资源，不被调度</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl uncordon/cordon [node-ip]<br></code></pre></td></tr></tbody></table></figure><p>10、添加污点控制调度</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl taint node [node-ip] dedicate=standalone:NoSchedule //增加污点<br>kubectl taint node [node-ip] dedicate=standalone:NoSchedule- //删除污点：key=value:affect<br></code></pre></td></tr></tbody></table></figure><p>11、修改label，pod资源分割</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl label nodes [node-ip] type=[name] --overwrite<br></code></pre></td></tr></tbody></table></figure><h1 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5. 参考文章"></a>5. 参考文章</h1><ul><li><a href="http://docs.kubernetes.org.cn/227.html">http://docs.kubernetes.org.cn/227.html</a></li><li><a href="https://www.jianshu.com/p/20e8a74e3a73">https://www.jianshu.com/p/20e8a74e3a73</a></li><li><a href="https://www.jianshu.com/p/a73c33283de8">https://www.jianshu.com/p/a73c33283de8</a></li><li><a href="https://www.jianshu.com/p/8e077225e">https://www.jianshu.com/p/8e077225e</a></li><li><a href="https://blog.csdn.net/qq_44766883/article/details/126549043">https://blog.csdn.net/qq_44766883/article/details/126549043</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文掌握MySQL日志</title>
      <link href="/posts/b7b2c450.html"/>
      <url>/posts/b7b2c450.html</url>
      
        <content type="html"><![CDATA[<p>在MySQL 中我们经常会接触到三个核心日志，它们分别是：binlog 、redo log、undo log。<br>很多人对于它们可能并不陌生，但是具体区分起来各自的功能用途以及实现原理，那可能认知就会比较模糊了，今天就跟大家一起，来清晰明了的介绍一下这些日志的核心思想和功能原理。</p><h1 id="1-binlog"><a href="#1-binlog" class="headerlink" title="1. binlog"></a>1. binlog</h1><h2 id="1-1-binlog-设计目标"><a href="#1-1-binlog-设计目标" class="headerlink" title="1.1 binlog 设计目标"></a>1.1 binlog 设计目标</h2><p>binlog 记录了对MySQL数据库执行更改的所有的写操作，包括所有对数据库的数据、表结构、索引等等变更的操作。</p><blockquote><p>注意：这其中不包含SELECT、SHOW等，因为对数据没有修改</p></blockquote><p>只要是对数据库有变更的操作都会记录到binlog里面来，我们可以把数据库的数据看做银行账户里的余额，而binlog就相当于我们银行卡的流水记录。账户余额只是一个结果，至于这个结果怎么来的，那就必须得看流水了。<br>在实际应用中， binlog 的主要应用场景分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong>。</p><ol><li><strong>主从复制</strong> ：在 Master 端开启 binlog ，然后将 binlog 发送到各个 Slave 端， Slave 端重放 binlog 来达到主从数据一致。</li><li><strong>数据恢复</strong> ：通过使用 mysqlbinlog 工具来恢复数据。<h2 id="1-2-binlog-数据格式"><a href="#1-2-binlog-数据格式" class="headerlink" title="1.2 binlog 数据格式"></a>1.2 binlog 数据格式</h2>binlog 日志有三种格式，分别为 STATMENT 、 ROW 和 MIXED。<blockquote><p>在 MySQL 5.7.7 之前，默认的格式是 STATEMENT ， MySQL 5.7.7 之后，默认值是 ROW。日志格式通过 binlog-format 指定。</p></blockquote></li></ol><ul><li><p><strong>ROW</strong>：基于行的复制（row-based replication, RBR），不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了。如果一个update语句修改一百行数据，那么这种模式下就会记录100行对应的记录日志。</p><blockquote><p>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题；<br>缺点：会产生大量的日志，尤其是 alter table 的时候会让日志暴涨。</p></blockquote></li><li><p><strong>STATMENT</strong>：基于SQL语句的复制( statement-based replication, SBR )，每一条会修改数据的SQL语句会记录到 binlog 中 。相对于ROW模式，STATEMENT模式下只会记录这个 update 的语句，所以此模式下会非常节省日志空间，也避免着大量的IO操作。</p><blockquote><p>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO , 从而提高了性能；<br>缺点：在某些情况下会导致主从数据不一致，比如执行sysdate() 、 sleep() 等 。</p></blockquote></li><li><p><strong>MIXED</strong>：基于 STATMENT 和 ROW 两种模式的混合复制（mixed-based replication, MBR），一般的复制使用 STATEMENT 模式保存 binlog ，对于一些函数，STATEMENT 模式无法复制的操作使用 ROW 模式保存 binlog。</p></li></ul><p>基于这三种模式需要注意的是：<br>1）使用 row 格式的 binlog 时，在进行数据同步或恢复的时候不一致的问题更容易被发现，因为它是基于数据行记录的。<br>2）使用 mixed 或者 statement 格式的 binlog 时，很多事务操作都是基于SQL逻辑记录，我们都知道一个SQL在不同的时间点执行它们产生的数据变化和影响是不一样的，所以这种情况下，数据同步或恢复的时候就容易出现不一致的情况。</p><h2 id="1-3-binlog-写入策略"><a href="#1-3-binlog-写入策略" class="headerlink" title="1.3 binlog 写入策略"></a>1.3 binlog 写入策略</h2><p>对于 InnoDB 存储引擎而言，在进行事务的过程中，首先会把binlog 写入到binlog cache中（因为写入到cache中会比较快，一个事务通常会有多个操作，避免每个操作都直接写磁盘导致性能降低），只有在事务提交时才会记录 binlog ，此时记录还在内存中，那么 binlog 是什么时候刷到磁盘中的呢？<br>MySQL 其实是通过 sync_binlog 参数控制 binlog 的刷盘时机，取值范围是 0-N：</p><ul><li><strong>0</strong>：每次提交事务binlog不会马上写入到磁盘，而是先写到page cache。不去强制要求，由系统自行判断何时写入磁盘，在Mysql 崩溃的时候会有丢失日志的风险；</li><li><strong>1</strong>：每次提交事务都会执行 fsync 将 binlog 写入到磁盘；</li><li><strong>N</strong>：每次提交事务都先写到page cach，只有等到积累了N个事务之后才 fsync 将 binlog 写入到磁盘，在 MySQL 崩溃的时候会有丢失N个事务日志的风险。</li></ul><p>很显然三种模式下，sync_binlog=1 是强一致的选择，选择0或者N的情况下在极端情况下就会有丢失日志的风险，具体选择什么模式还是得看系统对于一致性的要求。</p><h1 id="2-redo-log"><a href="#2-redo-log" class="headerlink" title="2. redo log"></a>2. redo log</h1><h2 id="2-1-redo-log-设计目标"><a href="#2-1-redo-log-设计目标" class="headerlink" title="2.1 redo log 设计目标"></a>2.1 redo log 设计目标</h2><p>redo log 是属于引擎层(innodb)的日志，称为<strong>重做日志</strong> ，当MySQL服务器意外崩溃或者宕机后，<strong>保证已经提交的事务</strong>持久化到磁盘中（<strong>持久性</strong>）。<br>它能保证对于已经COMMIT的事务产生的数据变更，即使是系统宕机崩溃也可以通过它来进行数据重做，达到数据的持久性，一旦事务成功提交后，不会因为异常、宕机而造成数据错误或丢失。</p><h2 id="2-2-redo-log-数据格式"><a href="#2-2-redo-log-数据格式" class="headerlink" title="2.2 redo log 数据格式"></a>2.2 redo log 数据格式</h2><p>redo log 包括两部分：</p><ul><li>内存中的<strong>日志缓冲</strong>（redo log buffer）: 内存层面，默认16M，通过innodb_log_buffer_size参数可修改</li><li>磁盘上的<strong>日志文件</strong>（redo log file）: 持久化的，磁盘层面</li></ul><p>MySQL 每执行一条 DML 语句，先将记录写入 redo log buffer，后续某个时间点再一次性将多个操作记录写到 redo log file。</p><blockquote><p>通常所说的<strong>Write-Ahead Log</strong>(预先日志持久化)指的是<strong>在持久化一个数据页之前，先将内存中相应的日志页持久化。</strong></p></blockquote><p>在计算机操作系统中，用户空间( user space )下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( kernel space )缓冲区( OS Buffer )。<br>因此， redo log buffer 写入 redo log file 实际上是先写入 OS Buffer ，然后再通过系统调用 fsync() 将其刷到 redo log file中，过程如下：<br><img src="https://cdn.l2xy.com/post_img/mysql_img/mysql-log-01.jpeg"><br><strong>修改数据的操作流程：</strong><br><img src="https://cdn.l2xy.com/post_img/mysql_img/mysql-log-02.png"></p><ol><li>先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝，产生脏数据</li><li>生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</li><li>默认在事务提交后将redo log buffer中的内容刷新到redo log file，对redo log file采用追加写的方式</li><li>定期将内存中修改的数据刷新到磁盘中（这里说的是那些还没及时被后台线程刷盘的脏数据）<h2 id="2-3-关于-redo-log-的几点疑惑"><a href="#2-3-关于-redo-log-的几点疑惑" class="headerlink" title="2.3 关于 redo log 的几点疑惑"></a>2.3 关于 redo log 的几点疑惑</h2>读到这里，相必有同学会有如下疑问：</li></ol><p><strong>Q1：为什么不直接修改磁盘中的数据？</strong><br>因为直接修改磁盘数据的话，它是随机IO，修改的数据分布在磁盘中不同的位置，需要来回的查找，所以命中率低，消耗大，而且一个小小的修改就不得不将整个页刷新到磁盘，利用率低；<br>与之相对的是顺序IO，磁盘的数据分布在磁盘的一块，所以省去了查找的过程，节省寻道时间。<br>使用后台线程以一定的频率去刷新磁盘可以降低随机IO的频率，增加吞吐量，这是使用buffer pool的根本原因。<br><strong>Q2：同为操作数据变更的日志，有了binlog为什么还要redo log？</strong><br>我认为最核心的一点就是<strong>两者记录的数据变更粒度是不一样</strong>的。<br>以修改数据为例，binlog 是以表为记录主体，在ROW模式下，binlog保存的表的每行变更记录。<br>MySQL 是以页为单位进行刷盘的，每一页的数据单位为16K，所以在刷盘的过程中需要把数据刷新到磁盘的多个扇区中去。而把16K数据刷到磁盘的每个扇区里这个过程是无法保证原子性的，如果数据库宕机，那么就可能会造成一部分数据成功，而一部分数据失败的情况。而通过 binlog 这种级别的日志是无法恢复的，因为一个update可能更改了多个磁盘区域的数据，所以这个时候得需要通过redo log这种记录到磁盘数据级别的日志进行数据恢复。<br><img src="https://cdn.l2xy.com/post_img/mysql_img/mysql-log-03.png"><br>由以上两者的对比可知：binlog 日志只用于归档，只依靠 binlog 是没有 crash-safe 能力的。<br>同样只有 redo log 也不行，因为 redo log 是 InnoDB特有的，且日志上的记录落盘后会被覆盖掉。因此需要 binlog和 redo log二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。<br><strong>Q3：redo log一定能保证事务的持久性吗？</strong><br>不一定，这要根据redo log的刷盘策略决定，因为redo log buffer同样是在内存中，如果提交事务之后，redo log buffer还没来得及将数据刷新到redo log file进行持久化，此时发生宕机照样会丢失数据。<br>那该如何解决呢？刷盘写入策略。</p><h2 id="2-4-redo-log-写入策略"><a href="#2-4-redo-log-写入策略" class="headerlink" title="2.4 redo log 写入策略"></a>2.4 redo log 写入策略</h2><p>当redo log空间满了之后又会从头开始以循环的方式进行覆盖式的写入。MySQL 支持三种将 redo log buffer 写入 redo log file 的时机，可以通过 innodb_flush_log_at_trx_commit 参数配置，各参数含义如下：</p><ul><li><strong>0（延迟写）</strong>：表示每次事务提交时都只是把 redo log 留在 redo log buffer 中，开启一个后台线程，每<strong>1s</strong>刷新一次到磁盘中 ;</li><li><strong>1（实时写，实时刷）</strong>：表示每次事务提交时都将 redo log 直接持久化到磁盘，真正保证数据的持久性；</li><li><strong>2（实时写，延迟刷）</strong>：表示每次事务提交时都只是把 redo log 写到 page cache，具体的刷盘时机不确定。</li></ul><p>除了上面几种机制外，还有其它两种情况会把redo log buffer中的日志刷到磁盘。</p><ul><li><strong>定时处理</strong>：有线程会定时(每隔 1 秒)把redo log buffer中的数据刷盘。</li><li><strong>根据空间处理</strong>：redo log buffer 占用到了一定程度( innodb_log_buffer_size 设置的值一半)占，这个时候也会把redo log buffer中的数据刷盘。<h1 id="3-undo-log"><a href="#3-undo-log" class="headerlink" title="3. undo log"></a>3. undo log</h1><h2 id="3-1-undo-log设计目标"><a href="#3-1-undo-log设计目标" class="headerlink" title="3.1 undo log设计目标"></a>3.1 undo log设计目标</h2>redo log 是也属于引擎层(innodb)的日志，从上面的redo log介绍中我们就已经知道了，redo log 和undo log的核心是为了保证innodb事务机制中的持久性和原子性，事务提交成功由redo log保证数据持久性，而事务可以进行回滚从而保证事务操作原子性则是通过undo log 来保证的。</li></ul><p><strong>原子性 是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。<br>undo log 的主要应用场景分别：</p><ol><li><strong>事务回滚</strong> ：前面提到过，后台线程会不定时的去刷新buffer pool中的数据到磁盘，但是如果该事务执行期间出现各种错误(宕机)或者执行rollback语句，那么前面刷进去的操作都是需要回滚的，保证原子性，undo log就是提供事务回滚的。</li><li><strong>MVCC</strong>：当读取的某一行被其他事务锁定时，可以从undo log中分析出该行记录以前的数据版本是怎样的，从而让用户能够读取到当前事务操作之前的数据——快照读。<h2 id="3-2-undo-log-数据格式"><a href="#3-2-undo-log-数据格式" class="headerlink" title="3.2 undo log 数据格式"></a>3.2 undo log 数据格式</h2>undo log 数据主要分两类：</li></ol><ul><li><strong>insert undo log</strong></li></ul><p>insert 操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li><strong>update undo log</strong></li></ul><p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。<br>在InnoDB存储引擎中，undo log使用rollback segment回滚段进行存储，每隔回滚段包含了1024个undo log segment。MySQL5.5之后，一共有128个回滚段。即总共可以记录128 * 1024个undo操作。</p><blockquote><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></blockquote><h2 id="3-3-undo-log-操作实例"><a href="#3-3-undo-log-操作实例" class="headerlink" title="3.3 undo log 操作实例"></a>3.3 undo log 操作实例</h2><p><strong>1、首先准备一张原始原始数据表（user_info）</strong><br>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p><ul><li><strong>DB_ROW_ID</strong>∶记录的主键id。</li><li><strong>DB_TRX_ID</strong>：事务ID，当对某条记录发生修改时，就会将这个事务的Id记录其中。</li><li><strong>DB_ROLL_PTR</strong>︰回滚指针，版本链中的指针。</li></ul><p><img src="https://cdn.l2xy.com/post_img/mysql_img/mysql-log-04.jpeg"><br><strong>2、开启一个事务A</strong><br>对 user_info 表执行如下SQL：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> user_info <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span>“李四”<span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p>将会进行如下流程操作：<br>1、首先获得一个事务编号 104<br>2、把user_info表修改前的数据拷贝到undo log<br>3、修改user_info表 id=1的数据<br>4、把修改后的数据事务版本号改成 当前事务版本号，并把DB_ROLL_PTR 地址指向undo log数据地址。<br><strong>3、最后执行结束</strong><br>结果如下所示：<br><img src="https://cdn.l2xy.com/post_img/mysql_img/mysql-log-05.jpeg"><br>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log，undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到我们的原始数据了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>binlog 是MySQL server层的日志，而redo log 和undo log都是引擎层（InnoDB）的日志，要换其他数据引擎那么就未必有redo log和undo log了。<br>它的设计目标是支持innodb的“事务”的特性，事务ACID特性分别是原子性、一致性、隔离性、持久性， 一致性是事务的最终追求的目标，隔离性、原子性、持久性是达成一致性目标的手段，根据的之前的介绍我们已经知道隔离性是通过锁机制来实现的，而事务的原子性和持久性则是通过redo log 和undo log来保障的。</p><h3 id="写入策略"><a href="#写入策略" class="headerlink" title="写入策略"></a>写入策略</h3><p>事务执行过程中，先把日志写到bin log cache ，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。<br><img src="https://cdn.l2xy.com/post_img/mysql_img/mysql-log-06.png"><br><strong>binlog vs redo log</strong></p><ul><li><strong>redo log 物理日志</strong>：记录内容是“在xx数据页做了xx修改”，属于InnoDB存储引擎层产生的。</li><li><strong>binlog 逻辑日志</strong>：记录内容是语句的原始逻辑，类似于给ID=2这一行的c字段加1，属于服务层。</li></ul><p>两个侧重点也不同， redo log让InnoDB有了崩溃恢复的能力，binlog保证了MySQL集群架构的数据一致性。<br><img src="https://cdn.l2xy.com/post_img/mysql_img/mysql-log-07.png"><br>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 的 defer 关键字使用注意事项</title>
      <link href="/posts/96a822e5.html"/>
      <url>/posts/96a822e5.html</url>
      
        <content type="html"><![CDATA[<p>Golang 提供了 <code>defer</code> 关键字，用于函数退出前执行收尾工作，基本的使用方法就不再赘述了。总结了一些可能踩坑的地方。</p><h2 id="defer-执行顺序"><a href="#defer-执行顺序" class="headerlink" title="defer 执行顺序"></a>defer 执行顺序</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> {<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        fmt.Println(<span class="hljs-string">"A"</span>)<br>    }()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        fmt.Println(<span class="hljs-string">"B"</span>)<br>    }()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        fmt.Println(<span class="hljs-string">"C"</span>)<br>    }()<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>TestFunc()<br>}<br></code></pre></td></tr></tbody></table></figure><p>执行结果是：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">C<br>B<br>A<br></code></pre></td></tr></tbody></table></figure><p>即 <code>defer</code> 执行先后顺序与代码顺序是相反的，是<strong>后进先出</strong>的顺序。</p><h2 id="defer-与-return-执行顺序"><a href="#defer-与-return-执行顺序" class="headerlink" title="defer 与 return 执行顺序"></a>defer 与 return 执行顺序</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferFunc</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> {<br>    fmt.Println(<span class="hljs-string">"defer func running"</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnFunc</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> {<br>    fmt.Println(<span class="hljs-string">"return func running"</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> {<br>    <span class="hljs-keyword">defer</span> deferFunc()<br>    <span class="hljs-keyword">return</span> returnFunc()<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    TestFunc()<br>}<br></code></pre></td></tr></tbody></table></figure><p>执行结果是：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">running</span></span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">running</span></span><br></code></pre></td></tr></tbody></table></figure><p>可以看到 return 语句先执行，defer 的函数后执行。</p><h2 id="defer-影响返回值"><a href="#defer-影响返回值" class="headerlink" title="defer 影响返回值"></a>defer 影响返回值</h2><p>既然 defer 执行的函数在 return 语句之后执行。那么 defer 是否可以改变函数返回值？来看下面的例子：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> (result <span class="hljs-type">int</span>) {<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        result = <span class="hljs-number">1024</span><br>    }()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2048</span><br><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    fmt.Println(TestFunc())<br>}<br></code></pre></td></tr></tbody></table></figure><p>执行结果是 1024。return 的是 2048，即 defer 确实可以改变函数返回值。再看个类似的例子：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> {<br>    result := <span class="hljs-number">1024</span><br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        result = <span class="hljs-number">2048</span><br>    }()<br><br>    <span class="hljs-keyword">return</span> result<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    fmt.Println(TestFunc())<br>}<br></code></pre></td></tr></tbody></table></figure><p>执行结果是 1024。这时 <code>defer func</code> 虽然更新了 result 的值，但并没有对函数返回值造成影响。原因是该函数的 <code>int</code> 类型返回值未命名（即匿名返回值），所以 <code>defer func</code> 无法修改该返回值，只是修改了 result 变量值。</p><h2 id="defer-函数预计算参数值"><a href="#defer-函数预计算参数值" class="headerlink" title="defer 函数预计算参数值"></a>defer 函数预计算参数值</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"time"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> {<br>    startedAt := time.Now()<br>    <span class="hljs-keyword">defer</span> fmt.Println(time.Since(startedAt))<br><br>    time.Sleep(time.Second)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    TestFunc()<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个例子是计算函数的执行时间，sleep 1s 作为模拟，然后执行结果是：199ns，显然这不是预期的结果。期望的执行时间应该是大于 1s 的。那么问题出在哪里？<br>由于调用 defer 时会预计算函数参数值，即预计算 <code>time.Since(startedAt)</code> 这个参数的值，而不是 sleep 执行完结束后计算的。可以这样改符合预期：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">"fmt"</span><br>    <span class="hljs-string">"time"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> {<br>    startedAt := time.Now()<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        fmt.Println(time.Since(startedAt))<br>    }()<br><br>    time.Sleep(time.Second)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    TestFunc()<br>}<br></code></pre></td></tr></tbody></table></figure><p>defer 后面跟匿名函数即可，符合我们的期望。执行结果是：1.003861399s。</p><h2 id="defer-与-panic"><a href="#defer-与-panic" class="headerlink" title="defer 与 panic"></a>defer 与 panic</h2><p>触发 defer 执行的时机有三个：</p><ul><li>包裹 defer 的函数遇到 return</li><li>包裹 defer 的函数执行到最后</li><li>发生 panic</li></ul><p>来看下 defer 与 panic 相遇时会发生什么。</p><h3 id="发生-panic-时在-defer-中不捕获异常"><a href="#发生-panic-时在-defer-中不捕获异常" class="headerlink" title="发生 panic 时在 defer 中不捕获异常"></a>发生 panic 时在 defer 中不捕获异常</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> {<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        fmt.Println(<span class="hljs-string">"A"</span>)<br>    }()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        fmt.Println(<span class="hljs-string">"B"</span>)<br>    }()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">"panic occurred"</span>)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    TestFunc()<br>}<br></code></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">B<br>A<br><span class="hljs-built_in">panic</span>: <span class="hljs-built_in">panic</span> occurred<br>... <span class="hljs-comment">// panic 堆栈信息</span><br></code></pre></td></tr></tbody></table></figure><h3 id="发生-panic-时在-defer-中捕获异常"><a href="#发生-panic-时在-defer-中捕获异常" class="headerlink" title="发生 panic 时在 defer 中捕获异常"></a>发生 panic 时在 defer 中捕获异常</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> {<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        fmt.Println(<span class="hljs-string">"A"</span>)<br>    }()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        fmt.Println(<span class="hljs-string">"B"</span>)<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> {<br>            fmt.Println(<span class="hljs-string">"catch panic"</span>)<br>        }<br>    }()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">"panic occurred"</span>)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    TestFunc()<br>}<br></code></pre></td></tr></tbody></table></figure><p>执行结果是：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">B<br>catch <span class="hljs-built_in">panic</span><br>A<br></code></pre></td></tr></tbody></table></figure><p>这个例子执行结果没什么可说的，发生 panic，可以在 defer 函数中捕获处理。</p><h3 id="defer-中发生-panic"><a href="#defer-中发生-panic" class="headerlink" title="defer 中发生 panic"></a>defer 中发生 panic</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFunc</span><span class="hljs-params">()</span></span> {<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> {<br>            fmt.Printf(<span class="hljs-string">"catch %s panic\n"</span>, err)<br>        }<br>    }()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"inner"</span>)<br>    }()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">"outer"</span>)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    TestFunc()<br>}<br></code></pre></td></tr></tbody></table></figure><p>执行结果是：<code>catch inner panic</code>。即外层发生 <code>panic(“outer”)</code>，触发 defer 执行，执行 defer 中又发生 <code>panic(“inner”)</code>，最后一个 defer 中捕获 panic，捕获到的是最后一个 panic。</p><p>另外，尽量不要使用 panic，仅在发生不可恢复的错误或程序启动时发生意外才使用 panic。</p>]]></content>
      
      
      <categories>
          
          <category> Go入门基础 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go入门基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/posts/cb625b07.html"/>
      <url>/posts/cb625b07.html</url>
      
        <content type="html"><![CDATA[<p><a name="Am4tQ"></a></p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><strong>计数排序(Counting sort)</strong> 是一种稳定的线性时间排序算法.计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序使用一个额外的数组C,其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C 来将A中的元素排到正确的位置。<br><a name="aTQps"></a></p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>计数排序的算法原理：</p><ul><li>找出待排序的数组中最大和最小的元素.</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项.</li><li>对所有的计数累加(从C中的第一个元素开始，每一项和前一项相加).</li><li>反向填充目标数组：将每个元素 i放在新数组的第C[i]项，每放一个元素就将C[i]减去1.</li></ul><p><img src="https://cdn.l2xy.com/post_img/sort_img/counting_sort.gif"><br>计数排序算法实现:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-comment">// 计数排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountingSort</span><span class="hljs-params">(data []<span class="hljs-type">int</span>)</span></span>  {<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &lt;= <span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">return</span><br>    }<br><br>    min, max := CountMaxMin(data)<br><br>    temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, max+<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(data); i++ {<br>        temp[data[i]]++<br>    }<br><br>    <span class="hljs-keyword">var</span> index <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := min; i &lt; <span class="hljs-built_in">len</span>(temp); i++ {<br>        <span class="hljs-keyword">for</span> j := temp[i]; j &gt; <span class="hljs-number">0</span> ; j-- {<br>            data[index] = i<br>            index++<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountMaxMin</span><span class="hljs-params">(data []<span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) {<br>    min, max := data[<span class="hljs-number">0</span>], data[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(data); i++ {<br>        <span class="hljs-keyword">if</span> min &gt; data[i] {<br>            min = data[i]<br>        }<br><br>        <span class="hljs-keyword">if</span> max &lt; data[i] {<br>            max = data[i]<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> min, max<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  {<br>    arr := []<span class="hljs-type">int</span>{<span class="hljs-number">33</span>,<span class="hljs-number">11</span>,<span class="hljs-number">55</span>,<span class="hljs-number">7</span>,<span class="hljs-number">44</span>,<span class="hljs-number">1</span>}<br>    CountingSort(arr)<br>    fmt.Println(arr)<br>}<br></code></pre></td></tr></tbody></table></figure><p>运行结果:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">countingSort: [<span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">11</span> <span class="hljs-number">33</span> <span class="hljs-number">44</span> <span class="hljs-number">55</span>]<br></code></pre></td></tr></tbody></table></figure><p>计数排序在特定的情况下，排序效率极高，但是如果排序的计数空间范围过大，而实际元素个数非常小的情况，效率就会非常差，比如，我只有3个元素，3，1，500000，这样的情况其实是不适合用计数排序的，这一点需要注意。<br><a name="rlUFQ"></a></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>最佳情况：$T(n) = O(n+k)$</li><li>最坏情况：$T(n) = O(n+k)$</li><li>平均情况：$T(n) = O(n+k)$</li><li>空间复杂度：$O(k)$</li><li>稳定性：稳定</li><li>排序方式：Out-place</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/posts/c2a5fdc5.html"/>
      <url>/posts/c2a5fdc5.html</url>
      
        <content type="html"><![CDATA[<p><a name="FU31z"></a></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>堆排序(Heapsort)</strong> 是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列.</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列.</li></ul><p>如下图： <br><img src="https://cdn.l2xy.com/post_img/sort_img/heap_sort1.png"></p><p>因为我们常用数组来存储完全二叉树，所以我们也可以用数组来存储堆。<br>堆在数组中的<strong>存储</strong>图如下：</p><p><img src="https://cdn.l2xy.com/post_img/sort_img/heap_sort2.png"></p><p>由上图我们可以看出对于堆中元素下标为<strong>i</strong>的点:</p><ul><li><p>2*i+1为它的左子节点</p></li><li><p>2*i+2为它的右子节点</p></li><li><p>i/2是它的前继节点<br><a name="FqDZZ"></a></p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>堆排序的算法原理:</p></li><li><p>创建一个堆 H[0……n-1].</p></li><li><p>把堆首（最大值）和堆尾互换.</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置.</p></li><li><p>重复步骤2，直到堆的尺寸为 1.<img src="https://cdn.l2xy.com/post_img/sort_img/heap_sort.gif" alt="Heap Sort"></p></li></ul><p>堆排序算法实现:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  {<br>    array := []<span class="hljs-type">int</span>{<span class="hljs-number">52</span>,<span class="hljs-number">16</span>,<span class="hljs-number">37</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">32</span>,<span class="hljs-number">12</span>,<span class="hljs-number">27</span>,<span class="hljs-number">19</span>,<span class="hljs-number">42</span>,<span class="hljs-number">29</span>,<span class="hljs-number">13</span>,<span class="hljs-number">37</span>,<span class="hljs-number">12</span>,<span class="hljs-number">9</span>}<br>    HeapSort(array)<br>    fmt.Println(<span class="hljs-string">"HeapSort:"</span>,array)<br>}<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(array []<span class="hljs-type">int</span>)</span></span> {<br>    m := <span class="hljs-built_in">len</span>(array)<br>    s := m/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i := s; i &gt; <span class="hljs-number">-1</span>; i-- {<br>        heap(array, i, m<span class="hljs-number">-1</span>)<br>    }<br>    <span class="hljs-keyword">for</span> i := m<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i-- {<br>        array[i], array[<span class="hljs-number">0</span>] = array[<span class="hljs-number">0</span>], array[i]<br>        heap(array, <span class="hljs-number">0</span>, i<span class="hljs-number">-1</span>)<br>    }<br>}<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heap</span><span class="hljs-params">(array []<span class="hljs-type">int</span>, i, end <span class="hljs-type">int</span>)</span></span>{<br>    l := <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> l &gt; end {<br>        <span class="hljs-keyword">return</span><br>    }<br>    n := l<br>    r := <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> r &lt;= end &amp;&amp; array[r]&gt;array[l]{<br>        n = r<br>    }<br>    <span class="hljs-keyword">if</span> array[i] &gt; array[n]{<br>        <span class="hljs-keyword">return</span><br>    }<br>    array[n], array[i] = array[i], array[n]<br>    heap(array, n, end)<br>}<br></code></pre></td></tr></tbody></table></figure><p>运行结果:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">HeapSort: [<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">16</span> <span class="hljs-number">19</span> <span class="hljs-number">27</span> <span class="hljs-number">29</span> <span class="hljs-number">32</span> <span class="hljs-number">37</span> <span class="hljs-number">37</span> <span class="hljs-number">42</span> <span class="hljs-number">52</span>]<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序</title>
      <link href="/posts/9fe164cc.html"/>
      <url>/posts/9fe164cc.html</url>
      
        <content type="html"><![CDATA[<p><a name="xAPiy"></a></p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p><strong>桶排序(Bucket sort)</strong>,工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量.</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中.<br><a name="eXoKq"></a><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4>桶排序的算法原理：</li></ol><ul><li>设置一个定量的数组当作空桶子.</li><li>寻访序列，并且把项目一个一个放到对应的桶子去.</li><li>对每个不是空的桶子进行排序.</li><li>从不是空的桶子里把项目再放回原来的序列中.</li></ul><p><img src="https://cdn.l2xy.com/post_img/sort_img/bucket_sort.gif" alt="Bucket Sort"></p><p>桶排序算法实现:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  {<br>    array := []<span class="hljs-type">int</span>{<span class="hljs-number">31</span>,<span class="hljs-number">16</span>,<span class="hljs-number">37</span>,<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">32</span>,<span class="hljs-number">10</span>,<span class="hljs-number">27</span>,<span class="hljs-number">7</span>,<span class="hljs-number">42</span>,<span class="hljs-number">29</span>,<span class="hljs-number">18</span>,<span class="hljs-number">28</span>,<span class="hljs-number">12</span>,<span class="hljs-number">9</span>,}<br>    BucketSort(array)<br>    fmt.Println(<span class="hljs-string">"BucketSort:"</span>,array)<br>}<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortInBucket</span><span class="hljs-params">(bucket []<span class="hljs-type">int</span>)</span></span> {<span class="hljs-comment">//此处实现插入排序方式，其实可以用任意其他排序方式</span><br>    length := <span class="hljs-built_in">len</span>(bucket)<br>    <span class="hljs-keyword">if</span> length == <span class="hljs-number">1</span> {<span class="hljs-keyword">return</span>}<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; length; i++ {<br>        backup := bucket[i]<br>        j := i <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//将选出的被排数比较后插入左边有序区</span><br>        <span class="hljs-keyword">for</span>  j &gt;= <span class="hljs-number">0</span> &amp;&amp; backup &lt; bucket[j] {<span class="hljs-comment">//注意j &gt;= 0必须在前边，否则会数组越界</span><br>            bucket[j+<span class="hljs-number">1</span>] = bucket[j]<span class="hljs-comment">//移动有序数组</span><br>            j -- <span class="hljs-comment">//反向移动下标</span><br>        }<br>        bucket[j + <span class="hljs-number">1</span>] = backup <span class="hljs-comment">//插队插入移动后的空位</span><br>    }<br>}<br><span class="hljs-comment">//获取数组最大值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaxInArr</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br>    max := arr[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ {<br>        <span class="hljs-keyword">if</span> arr[i] &gt; max{ max = arr[i]}<br>    }<br>    <span class="hljs-keyword">return</span> max<br>}<br><span class="hljs-comment">//桶排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BucketSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {<br>    <span class="hljs-comment">//桶数</span><br>    num := <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-comment">//k（数组最大值）</span><br>    max := getMaxInArr(arr)<br>    <span class="hljs-comment">//二维切片</span><br>    buckets := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, num)<br>    <span class="hljs-comment">//分配入桶</span><br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ {<br>        index = arr[i] * (num<span class="hljs-number">-1</span>) /max<span class="hljs-comment">//分配桶index = value * (n-1) /k</span><br>        buckets[index] = <span class="hljs-built_in">append</span>(buckets[index], arr[i])<br>    }<br>    <span class="hljs-comment">//桶内排序</span><br>    tmpPos := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ {<br>        bucketLen := <span class="hljs-built_in">len</span>(buckets[i])<br>        <span class="hljs-keyword">if</span> bucketLen &gt; <span class="hljs-number">0</span>{<br>            sortInBucket(buckets[i])<br>            <span class="hljs-built_in">copy</span>(arr[tmpPos:], buckets[i])<br>            tmpPos += bucketLen<br>        }<br>    }<br>        <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">BucketSort: [<span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">16</span> <span class="hljs-number">18</span> <span class="hljs-number">27</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">37</span> <span class="hljs-number">42</span>]<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/posts/ff8068c0.html"/>
      <url>/posts/ff8068c0.html</url>
      
        <content type="html"><![CDATA[<p><a name="wy3W5"></a></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>归并排序算法虽好，但是不是原地排序算法，需要消耗额外的内存空间，今天我们要介绍的是常规排序里综合排名最高的排序算法：快速排序，江湖人称「快排」。<br>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br><strong>快速排序算法其实很简单，采用分治策略。步骤如下：</strong></p><ol><li>选取一个基准元素（pivot）</li><li>比pivot小的放到pivot左边，比pivot大的放到pivot右边</li><li>对pivot左边的序列和右边的序列分别递归的执行步骤1和步骤2</li></ol><p>快排的核心思想：<br>如果要排序数据序列中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点），假设对应下标是 q。<br>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数据序列 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。<br>图示如下：<br><img src="https://cdn.l2xy.com/post_img/sort_img/quick_sort1.png"><br>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了，而且你可以看到我们不需要像归并排序那样做合并操作，也就不需要额外的内存空间，在时间复杂度和归并排序一样的情况下，有着更好的空间复杂度表现。<br>快速排序首先要找到分区点 pivot，一般我们会将数据序列最后一个元素或者第一个元素作为 pivot。假设我们以最后一个元素作为分区点，然后通过两个变量 i 和 j 作为下标来遍历数据序列，当下标 j 对应数据小于 pivot 时，交换 i 和 j 对应的数据，并且将 i 的指针往后移动一位，否则 i 不动。下标 j 是始终往后移动的，j 到达终点后，将 pivot 与下标 i 对应数据交换，这样最终将 pivot 置于数据序列中间，[0…i-1] 区间的数据都比 pivot 小，[i+1…j] 之间的数据都比 pivot 大，我们以递归的方式处理该流程，最终整个数据序列都会变成有序的，对应的算法操作流程如下：<br><img src="https://cdn.l2xy.com/post_img/sort_img/quick_sort2.png"><br><a name="qz087"></a></p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p>快速排序的算法原理:</p><ul><li>从数列中挑出一个元素，称为 “基准”(pivot).</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作.</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序.</li></ul><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。<br><img src="https://cdn.l2xy.com/post_img/sort_img/quick_sort.gif" alt="Quick Sort"><br><a name="mZaE2"></a></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>将上述流程转化为 Go 代码实现如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-comment">// 快速排序入口函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, p <span class="hljs-type">int</span>, r <span class="hljs-type">int</span>)</span></span> {<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> p &gt;= r {<br>        <span class="hljs-keyword">return</span><br>    }<br>    <span class="hljs-comment">// 获取分区位置</span><br>    q := partition(nums, p, r)<br>    <span class="hljs-comment">// 递归分区（排序是在定位 pivot 的过程中实现的）</span><br>    quickSort(nums, p, q - <span class="hljs-number">1</span>)<br>    quickSort(nums, q + <span class="hljs-number">1</span>, r)<br>}<br><br><span class="hljs-comment">// 定位 pivot</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, p <span class="hljs-type">int</span>, r <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br>    <span class="hljs-comment">// 以当前数据序列最后一个元素作为初始 pivot</span><br>    pivot := nums[r]<br>    <span class="hljs-comment">// 初始化 i、j 下标</span><br>    i := p<br>    <span class="hljs-comment">// 后移 j 下标的遍历过程</span><br>    <span class="hljs-keyword">for</span> j := p; j &lt; r; j++ {<br>        <span class="hljs-comment">// 将比 pivot 小的数丢到 [p...i-1] 中，剩下的 [i...j] 区间都是比 pivot 大的</span><br>        <span class="hljs-keyword">if</span> nums[j] &lt; pivot {<br>            <span class="hljs-comment">// 互换 i、j 下标对应数据</span><br>            nums[i], nums[j] = nums[j], nums[i]<br>            <span class="hljs-comment">// 将 i 下标后移一位</span><br>            i++<br>        }<br>    }<br><br>    <span class="hljs-comment">// 最后将 pivot 与 i 下标对应数据值互换</span><br>    <span class="hljs-comment">// 这样一来，pivot 就位于当前数据序列中间，i 也就是 pivot 值对应的下标</span><br>    nums[i], nums[r] = pivot, nums[i]<br>    <span class="hljs-comment">// 返回 i 作为 pivot 分区位置</span><br>    <span class="hljs-keyword">return</span> i<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    nums := []<span class="hljs-type">int</span>{<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>}<br>    quickSort(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>    fmt.Println(nums)<br>}<br></code></pre></td></tr></tbody></table></figure><p>运行上述代码，打印结果如下，表明快速排序成功：<br><img src="https://cdn.l2xy.com/post_img/sort_img/quick_sort3.png"><br><a name="nKw7F"></a></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>正如我们前面所说的，快速排序是原地排序算法，时间复杂度和归并排序一样，也是 O(nlogn)，这个时间复杂度数据量越大，越优于 O(n2)。<br>但是快速排序也有其缺点，因为涉及到数据的交换，有可能破坏原来相等元素的位置排序，所以是不稳定的排序算法。<br>尽管如此，凭借其良好的时间复杂度表现和空间复杂度的优势，快速排序在工程实践中应用较多。<br><a name="Q7yJw"></a></p><h2 id="优化改进"><a href="#优化改进" class="headerlink" title="优化改进"></a>优化改进</h2><p><strong>场景分析：</strong> 递归是一种使用相同的方法，通过解决问题的子集以达到解决整个问题的方法，是一种使用有限代码解决“无限”计算的方法。在C/C++语言中递归表现在函数对自身的直接/间接的调用上，在实现上，递归依赖于语言的运行时调用堆栈，使用堆栈来保存每一次递归调用返回时所需要的条件。递归通常具有简洁的编码和清晰的思路，但这种简洁是有代价的。一方面，是函数调用的负担；另一方面，是堆栈占用的负担（堆栈的大小是有限的）。<br><strong>改进思路：</strong>递归转化为迭代。迭代的思想主要在于，在同一栈帧中不断使用现有数据计算出新的数据，然后使用新的数据来替换原有数据。</p>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/posts/1ac49179.html"/>
      <url>/posts/1ac49179.html</url>
      
        <content type="html"><![CDATA[<p><strong>希尔排序(Shell Sort)</strong>,又称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。<br><a name="MbrNZ"></a></p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>希尔排序算法原理：</p><ul><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1.</li><li>按增量序列个数 k，对序列进行 k 趟排序.</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度.</li></ul><p><img src="https://cdn.l2xy.com/post_img/sort_img/shell_sort.gif" alt="Shell Sort"><br>希尔排序算法实现:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    <span class="hljs-keyword">var</span> arr = []<span class="hljs-type">int</span>{<span class="hljs-number">19</span>,<span class="hljs-number">8</span>,<span class="hljs-number">27</span>,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-number">17</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>}<br>    shellSort(arr)<br>    fmt.Println(<span class="hljs-string">"shellSort:"</span>,arr)<br>}<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> {<br>    n := <span class="hljs-built_in">len</span>(arr)<br>    h := <span class="hljs-number">1</span><br>    <span class="hljs-comment">//寻找合适的间隔h</span><br>    <span class="hljs-keyword">for</span> h &lt; n/<span class="hljs-number">3</span> {<br>        h = <span class="hljs-number">3</span>*h +<span class="hljs-number">1</span><br>    }<br>    <span class="hljs-keyword">for</span> h &gt;= <span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">for</span> i := h; i &lt; n; i++ {<br>            <span class="hljs-keyword">for</span> j := i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j<span class="hljs-number">-1</span>]; j -= h {<br>                arr[j], arr[j<span class="hljs-number">-1</span>] = arr[j<span class="hljs-number">-1</span>], arr[j]<br>            }<br>        }<br>        h /= <span class="hljs-number">3</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>运行结果:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">shellSort: [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span> <span class="hljs-number">19</span> <span class="hljs-number">27</span>]<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/posts/1599bffe.html"/>
      <url>/posts/1599bffe.html</url>
      
        <content type="html"><![CDATA[<p><a name="Abrkl"></a></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>今天介绍比前面三种排序算法性能更好的排序算法 —— 归并排序。<br>该算法是利用分治思想解决问题的一个非常典型的应用，归并排序的基本思路就是先把数组一分为二，然后分别把左右数组排好序，再将排好序的左右两个数组合并成一个新的数组，最后整个数组就是有序的了。<br>所谓归并排序，指的是如果要排序一个数据序列，我们可以先把该序列从中间分成前后两部分，然后对这两部分分别做排序操作，再将排好序的两部分合并在一起，这样整个数据序列就都有序了。<br><strong>运用递归法实现归并操作的主要步骤:</strong></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</li><li>比较两个指针所指向的元素，选择较小的元素放入到合并空间，并将指针移动到下一位置。</li><li>重复步骤3直到某一指针到达序列尾，然后将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p>归并排序使用了<strong>分治思想</strong>，分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。说到这里，可能你会联想起我们之前讲到的一个编程技巧 —— <strong>递归</strong>，没错，归并排序就是通过递归来实现的。这个递归的公式是每次都将传入的待排序数据序列一分为二，直到变成不能继续分割的最小区间单元，然后将最小区间单元数据排序后合并起来，最终返回的就是排序好的数据序列了。图示如下：<br><img src="https://cdn.l2xy.com/post_img/sort_img/merge_sort1.png"><br><br><a name="yMs72"></a></p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p>归并排序算法原理：</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列.</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置.</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置.</li><li>重复上一步直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾.</li></ul><p><img src="https://cdn.l2xy.com/post_img/sort_img/merge_sort.gif" alt="Merge Sort"><br><a name="nYioO"></a></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>通过上面的分析，我们知道归并=递归+合并，对应的 Go 实现代码如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">"fmt"</span><br>)<br><br><span class="hljs-comment">// 归并排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">return</span> nums<br>    }<br><br>    <span class="hljs-comment">// 获取分区位置</span><br>    p := <span class="hljs-built_in">len</span>(nums) / <span class="hljs-number">2</span><br>    <span class="hljs-comment">// 通过递归分区</span><br>    left := mergeSort(nums[<span class="hljs-number">0</span>:p])<br>    right := mergeSort(nums[p:])<br>    <span class="hljs-comment">// 排序后合并</span><br>    <span class="hljs-keyword">return</span> merge(left, right)<br>}<br><br><span class="hljs-comment">// 排序合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(left []<span class="hljs-type">int</span>, right []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    m, n := <span class="hljs-built_in">len</span>(left), <span class="hljs-built_in">len</span>(right)<br>    <span class="hljs-comment">// 用于存放结果集</span><br>    <span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> {<br>        <span class="hljs-comment">// 任何一个区间遍历完，则退出</span><br>        <span class="hljs-keyword">if</span> i &gt;= m || j &gt;= n {<br>            <span class="hljs-keyword">break</span><br>        }<br>        <span class="hljs-comment">// 对所有区间数据进行排序</span><br>        <span class="hljs-keyword">if</span> left[i] &lt;= right[j] {<br>            result = <span class="hljs-built_in">append</span>(result, left[i])<br>            i++<br>        } <span class="hljs-keyword">else</span> {<br>            result = <span class="hljs-built_in">append</span>(result, right[j])<br>            j++<br>        }<br>    }<br><br>    <span class="hljs-comment">// 如果左侧区间还没有遍历完，将剩余数据放到结果集</span><br>    <span class="hljs-keyword">if</span> i != m {<br>        <span class="hljs-keyword">for</span> ; i &lt; m; i++ {<br>            result = <span class="hljs-built_in">append</span>(result, left[i])<br>        }<br>    }<br><br>    <span class="hljs-comment">// 如果右侧区间还没有遍历完，将剩余数据放到结果集</span><br>    <span class="hljs-keyword">if</span> j != n {<br>        <span class="hljs-keyword">for</span> ; j &lt; n; j++ {<br>            result = <span class="hljs-built_in">append</span>(result, right[j])<br>        }<br>    }<br><br>    <span class="hljs-comment">// 返回排序后的结果集</span><br>    <span class="hljs-keyword">return</span> result<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    nums := []<span class="hljs-type">int</span>{<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>}<br>    sortedNums := mergeSort(nums)<br>    fmt.Println(sortedNums)<br>}<br></code></pre></td></tr></tbody></table></figure><p>运行上述代码，打印结果如下：<br><img src="https://cdn.l2xy.com/post_img/sort_img/merge_sort2.png"><br><a name="i9rnY"></a></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>最后我们来看下归并排序的性能：</p><ul><li>归并最后到底都是相邻元素之间的比较交换，并不会发生相同元素的相对位置发生变化，故是稳定性算法；</li><li>时间复杂度是 O(nlogn)，要优于冒泡排序和插入排序的 O(n2)；</li><li>归并排序需要额外的空间存放排序数据，不是原地排序，最多需要和待排序数据序列同样大小的空间，所以空间复杂度是 O(n)。<br><a name="WazHr"></a><h3 id="归并排序的时间复杂度推导过程"><a href="#归并排序的时间复杂度推导过程" class="headerlink" title="归并排序的时间复杂度推导过程"></a>归并排序的时间复杂度推导过程</h3>归并的思路时将一个复杂的问题 a 递归拆解为子问题 b 和 c，再将子问题计算结果合并，最终得到问题的答案，这里我们将归并排序总的时间复杂度设为 T(n)，则 T(n) = 2*T(n/2) + n，其中 T(n/2) 是递归拆解的第一步对应子问题的时间复杂度，n 则是排序合并函数的时间复杂度（一个循环遍历），依次类推，我们可以推导 T(n) 的计算逻辑如下：<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">T(n) = <span class="hljs-number">2</span>*T(n/<span class="hljs-number">2</span>) + n<br>        = <span class="hljs-number">2</span>*(<span class="hljs-number">2</span>*T(n/<span class="hljs-number">4</span>) + n/<span class="hljs-number">2</span>) + n = <span class="hljs-number">4</span>*T(n/<span class="hljs-number">4</span>) + <span class="hljs-number">2</span>*n<br>        = <span class="hljs-number">4</span>(<span class="hljs-number">2</span>*T(n/<span class="hljs-number">8</span>) + n/<span class="hljs-number">4</span>) + <span class="hljs-number">2</span>*n = <span class="hljs-number">8</span>*T(n/<span class="hljs-number">8</span>) + <span class="hljs-number">3</span>*n<br>        = ...<br>        = <span class="hljs-number">2</span>^k*T(n/<span class="hljs-number">2</span>^k) + k*n<br></code></pre></td></tr></tbody></table></figure>递归到最后，$T(n/2^k)≈T(1)$，也就是 $n/2^k = 1，$，计算归并排序的时间复杂度，就演变成了计算 k 的值，$2^k = n$，所以 $k=log_2n$，我们把 k 的值带入上述 T(n) 的推导公式，得到：<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">T(n) = n*T(<span class="hljs-number">1</span>) + n*log2n = n(C + log2n)<br></code></pre></td></tr></tbody></table></figure>注：上述公式中 2 是下标，即 $log_2n$。<br>把常量和低阶忽略，所以 $T(n) = nlogn$。<br><a name="Yq3ey"></a><h3 id="优化改进"><a href="#优化改进" class="headerlink" title="优化改进"></a>优化改进</h3>在规模较小时，合并排序可采用直接插入，避免递归调用； 在写法上，可以在生成辅助数组时，俩头小，中间大，这时不需要再在后边加俩个while循环进行判断，只需一次比完。 为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。<br><a name="xvIvL"></a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>归并排序和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/posts/43d00a99.html"/>
      <url>/posts/43d00a99.html</url>
      
        <content type="html"><![CDATA[<p><a name="RLmhH"></a></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br><strong>选择排序的实现过程: 在不断未排序的区间中找到最小的元素，将其放入已排序区间的尾部。</strong><br>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。这样一来，当遍历完未排序区间，就意味着已经完成整个序列的排序了。图示如下：<br><img src="https://cdn.l2xy.com/post_img/sort_img/select_sort1.png"><br><br><a name="sZXrI"></a></p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p>选择排序算法的原理如下：</p><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><p><img src="https://cdn.l2xy.com/post_img/sort_img/selection_sort.gif" alt="Selection Sort"><br><a name="L4nyi"></a></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>选择排序的实现逻辑非常简单，对应的 Go 实现代码如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> {<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">return</span><br>    }<br>    <span class="hljs-comment">// 已排序区间初始化为空，未排序区间初始化待排序切片</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ {<br>        <span class="hljs-comment">// 未排序区间最小值初始化为第一个元素</span><br>        min := i<br>        <span class="hljs-comment">// 从未排序区间第二个元素开始遍历，直到找到最小值</span><br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ {<br>            <span class="hljs-keyword">if</span> nums[j] &lt; nums[min] {<br>                min = j<br>            }<br>        }<br>        <span class="hljs-comment">// 将最小值与未排序区间第一个元素互换位置（等价于放到已排序区间最后一个位置）</span><br>        <span class="hljs-keyword">if</span> min != i {<br>            nums[i],nums[min] = nums[min], nums[i]<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    nums := []<span class="hljs-type">int</span>{<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>}<br>    selectionSort(nums)<br>    fmt.Println(nums)<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于传递到 selectionSort 函数的参数是 []int 类型的切片，而切片是<strong>引用类型</strong>，所以其实不必定义返回值，运行上述代码，打印结果如下：<br><img src="https://cdn.l2xy.com/post_img/sort_img/select_sort1.png"><br>表明排序算法可以正常工作。<br><a name="kjFUH"></a></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>接下来，我们来看看选择排序的性能和稳定性：</p><ul><li>很显然，选择排序的时间复杂度也是 $O(n^2)$；</li><li>由于不涉及额外的存储空间，所以是原地排序；</li><li>由于涉及非相邻元素的位置交换，所以是不稳定的排序算法。</li></ul><p>综合比较前面介绍的三种排序算法，时间复杂度都是一样的，也都是原地排序，但是选择排序是不稳定的排序算法，此外，插入排序和冒泡排序相比较的话，插入排序只需要执行一条语句，而冒泡排序需要三条，因此在同等条件下，或者数据量很大的情况下，插入排序性能是要略优于冒泡排序的，所以综合比较下来，<strong>三者的优先级是插入排序 &gt; 冒泡排序 &gt;&gt; 选择排序</strong>。<br>不过三者的时间复杂度都是 $O(n^2)$，在数据量很大的情况下性能表现其实都不理想，还可以进一步进行优化，这就是我们接下来要介绍的归并排序和快速排序算法。<br><a name="aM4NU"></a></p><h2 id="选择排序与插入排序的区别"><a href="#选择排序与插入排序的区别" class="headerlink" title="选择排序与插入排序的区别"></a>选择排序与插入排序的区别</h2><p>插入排序和选择排序都有两层循环，外循环遍历整个数组，内循环稍有区别：</p><ul><li>选择排序的内循环是遍历一组<strong>未排过序</strong>的数组</li><li>插入排序的内循环是遍历一组<strong>已排过序</strong>的数组</li></ul><p><strong>选择排序原理</strong>：主要在选择上，每一次从无序队列中选择出最小值，然后将其放置在有序队列的末尾，然后在无序队列中将其删除。<br><strong>插入排序原理</strong>：默认第一个元素为有序，后面的逐个向有序中插入，特点就是不断的移动数据，一直到排出序列。</p>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/posts/96555fb2.html"/>
      <url>/posts/96555fb2.html</url>
      
        <content type="html"><![CDATA[<p><a name="mRQQ0"></a></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>插入排序的原理是：我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。<br>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>整体流程如下图所示：<br><img src="https://cdn.l2xy.com/post_img/sort_img/insert_sort1.png"><br></p><p><a name="DQFL8"></a></p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.l2xy.com/post_img/sort_img/insertion_sort.gif" alt="Insertion Sort"><br><a name="ik5o5"></a></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>插入排序也比较简单，对应的 Go 实现代码如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">return</span> nums<br>    }<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ {<br>       <span class="hljs-comment">// 每次从未排序区间取一个数据 value</span><br>        value := nums[i]<br>        <span class="hljs-comment">// 在已排序区间找到插入位置</span><br>        j := i - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> ; j &gt;= <span class="hljs-number">0</span>; j-- {<br>           <span class="hljs-comment">// 如果比 value 大后移</span><br>            <span class="hljs-keyword">if</span> nums[j] &gt; value {<br>                nums[j+<span class="hljs-number">1</span>] = nums[j]<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">break</span><br>            }<br>        }<br>        <span class="hljs-comment">// 插入数据 value</span><br>        nums[j+<span class="hljs-number">1</span>] = value<br>    }<br><br>    <span class="hljs-keyword">return</span> nums<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    nums := []<span class="hljs-type">int</span>{<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>}<br>    nums = insertionSort(nums)<br>    fmt.Println(nums)<br>}<br></code></pre></td></tr></tbody></table></figure><p>运行上述代码，打印结果如下：<br><img src="https://cdn.l2xy.com/post_img/sort_img/insert_sort2.png"><br><a name="CYygp"></a></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>我们来看下插入排序的性能和稳定性：</p><ul><li>插入排序需要两个嵌套的循环，时间复杂度是$O(n^2)$；</li><li>没有额外的存储空间，是原地排序算法；</li><li>不涉及相等元素位置交换，是稳定的排序算法。</li></ul><p>插入排序的时间复杂度和冒泡排序一样，也不是很理想，但是插入排序不涉及数据交换，从更细粒度来区分，性能要略优于冒泡排序。</p>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/posts/14e6f1eb.html"/>
      <url>/posts/14e6f1eb.html</url>
      
        <content type="html"><![CDATA[<p>要给大家介绍的是<strong>基于选择</strong>的排序算法，常见<strong>基于选择</strong>的排序算法有<strong>冒泡排序</strong>、<strong>插入排序</strong>、<strong>选择排序</strong>、<strong>归并排序</strong>和<strong>快速排序</strong>，我们在选择排序算法的时候，通常会根据以下几个维度来考虑：</p><ol><li>时间复杂度</li><li>空间复杂度（对内存空间的消耗）</li><li>算法的稳定性（如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变）</li></ol><p>我们首先从冒泡排序开始。<br><a name="s5WUI"></a></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。<br><strong>冒泡排序是一种交换排序，核心是冒泡，把数组中最小的那个往上冒，冒的过程就是和他相邻的元素交换。</strong><br>重复走访要排序的数列，通过两两比较相邻记录的排序码。排序过程中每次从后往前冒一个最小值，且每次能确定一个数在序列中的最终位置。若发生逆序，则交换；有俩种方式进行冒泡，一种是先把小的冒泡到前边去，另一种是把大的元素冒泡到后边。<br>光看定义有点抽象，我们用图来演示，假设待排序数字是 4、5、6、3、2、1，第一次排序的流程是这样的：<br><img src="https://cdn.l2xy.com/post_img/sort_img/bubble_sort1.png"><br>经过 n 次冒泡，最终完成排序（<strong>所谓冒泡，以升序来看，就是每次把待排序序列中的最大值插到已排序序列的最前面，这个过程就像冒泡一样</strong>）：<br><img src="https://cdn.l2xy.com/post_img/sort_img/bubble_sort2.png"><br><a name="KfKIq"></a></p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.l2xy.com/post_img/sort_img/bubble_sort.gif" alt="Bubble Sort"><br><a name="vyvB8"></a></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>通过两层循环控制： </p><ul><li>第一个循环（外循环），负责把需要冒泡的那个数字排除在外；</li><li>第二个循环（内循环），负责两两比较交换；</li></ul><p>重要的是理解冒泡排序的原理，懂了原理就是把这个排序过程翻译成代码而已，以下是 Go 代码实现的冒泡排序：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> {<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> {<br>        <span class="hljs-keyword">return</span> nums<br>    }<br><br>    <span class="hljs-comment">// 冒泡排序核心实现代码</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ {<br>        flag := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(nums) - i - <span class="hljs-number">1</span>; j++ {<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>] {<br>                nums[j], nums[j+<span class="hljs-number">1</span>] = nums[j+<span class="hljs-number">1</span>], nums[j]<br>                flag = <span class="hljs-literal">true</span><br>            }<br>        }<br>        <span class="hljs-keyword">if</span> !flag {<br>            <span class="hljs-keyword">break</span><br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> nums<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    nums := []<span class="hljs-type">int</span>{<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>}<br>    nums = bubbleSort(nums)<br>    fmt.Println(nums)<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里我们使用切片类型来存储待排序数据序列，并且可以看到，我们对冒泡排序有个小小的优化，就是当某一次遍历的时候发现没有需要交换的元素，则认为整个序列已经排序完成。<br><a name="fgelI"></a></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>最后我们来看下冒泡排序的性能和稳定性：</p><ol><li>时间复杂度： $O(n^2)$</li><li>空间复杂度：只涉及相邻元素的交换，是原地排序算法</li><li>算法稳定性：元素相等不会交换，是稳定的排序算法</li></ol><p>时间复杂度是 $O(n^2)$，看起来性能并不是很好，<strong>所以我们在实践中基本不会选用冒泡算法</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八种排序算法的稳定性分析</title>
      <link href="/posts/124e81d.html"/>
      <url>/posts/124e81d.html</url>
      
        <content type="html"><![CDATA[<p><strong>TIPs</strong>:</p><blockquote><p>一个算法稳定是指，如果A=B，A在B前面，在进行排序算法后，仍然保持A在B前面。</p></blockquote><p><strong>算法分类</strong>：<br><br>常见排序算法可以分为两大类：</p><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li></ul><p><br><img src="https://cdn.l2xy.com/post_img/sort_img/sort.png" alt="算法分类"><br></p><p><strong>算法复杂度</strong>：<br><br><img src="https://cdn.l2xy.com/post_img/sort_img/sort_al.png" alt="算法复杂度"><br></p><p><strong>冒泡排序</strong>：稳定，因为相同的数不会交换位置，只有后面的大于等于前面的数的数才会往后交换位置。也就是说如果A=B,A在B的前面，冒泡排序会将B往后放，A的位置不变。<br><img src="https://cdn.l2xy.com/post_img/sort_img/bubble_sort.gif" alt="冒泡排序"><br><br><strong>选择排序</strong>：不稳定，选择排序遍历数组将选中未排序的数组中最小的数，然后将这个数和未排序的第一个数交换，这样的话可能存在一种情况，如(7) 2 5 9 3 4 [7] 1，其中1会和(7)换位置，所以这种算法不稳定。<br><img src="https://cdn.l2xy.com/post_img/sort_img/selection_sort.gif" alt="选择排序"><br><br><strong>插入排序</strong>：稳定，插入排序会往后遍历未排序的数，然后把这个数插入到前面排序的数组中的合适的排序位置，因此仅仅会产生排序数组的向后一位的移动以及某一个数的向前移动，但是这个数可以控制放入在不超过在他前面被排序的相同数的位置。<br><img src="https://cdn.l2xy.com/post_img/sort_img/insertion_sort.gif" alt="插入排序"><br><br><strong>归并排序</strong>：稳定，因为归并排序遇到两个一样的数的时候，其比较的两个数组是原始顺序（两个数组是对一个数组的两段数组的抽象，如a数组是x索引从0到5的子数组）因此遇到两个相同的数时，处理方式是先把“前面”的一个数组的值放在新的归并数组前面。因此归并排序是稳定的。<br><img src="https://cdn.l2xy.com/post_img/sort_img/merge_sort.gif" alt="归并排序"><br><br><strong>快速排序</strong>：不稳定，一般快排使用交换的方法进行排序，这样就涉及到一个pivot分界元素和其他元素比较的问题，如果这个pivot是随机选取的，那么根据算法实现的不同，有可能会将相同的值和自己的位置交换，从而打乱相同值的原始排序。但是如果使用插入的实现，则可能快排是稳定的排序算法，但是由于数组的插入很慢所以一般不会这样实现。<br><img src="https://cdn.l2xy.com/post_img/sort_img/quick_sort.gif" alt="快速排序"><br><br><strong>堆排序</strong>：不稳定，堆排序首先是大顶堆在建立大顶堆的过程中就可能丢失原始顺序，而如果左子树小于右子树则比较右子树和根节点，那么就存在左右子树相同的情况，那么根据实现就可能丢失左右子树的原始顺序。<br><img src="https://cdn.l2xy.com/post_img/sort_img/heap_sort.gif" alt="堆排序"><br><br><strong>希尔排序</strong>：不稳定，希尔排序是插入排序的变种。可以说是根据不同的间隔将数组分组之后再每个组进行排序，然后不断缩小间隔的过程。相同元素如果分到不同组进行排序，就有可能改变原始排序。因此不稳定。下面是间隔为4的排序。<br><img src="https://cdn.l2xy.com/post_img/sort_img/shell_sort.gif" alt="希尔排序"><br><br><strong>桶排序</strong>（<strong>基数排序</strong>，<strong>计数排序</strong>）：稳定，桶排序是按照数值区间对数组进行划分，每个区间称为桶。基数排序按照数位进行划分，可以看做是多轮桶排序。计数排序则是最大化的桶排序，它适用于相同值很多的数组的排序。他们对数的排序都是按照它在数组中出现的先后进行排序的，所以怎样都是稳定的。<br><img src="https://cdn.l2xy.com/post_img/sort_img/bucket_sort.gif" alt="桶排序"><br><img src="https://cdn.l2xy.com/post_img/sort_img/radix_sort.gif" alt="基数排序"><br><img src="https://cdn.l2xy.com/post_img/sort_img/counting_sort.gif" alt="计数排序"></p>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 常见算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法场景概念解读</title>
      <link href="/posts/329e504d.html"/>
      <url>/posts/329e504d.html</url>
      
        <content type="html"><![CDATA[<p><strong>什么是稳定排序、原地排序、时间复杂度、空间复杂度：</strong></p><ol><li>稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。</li><li>非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序。</li><li>原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</li><li>非原地排序：需要利用额外的数组来辅助排序。</li><li>时间复杂度：一个算法执行所消耗的时间。</li><li>空间复杂度：运行完一个算法所需的内存大小。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现自己的Composer包</title>
      <link href="/posts/5339145e.html"/>
      <url>/posts/5339145e.html</url>
      
        <content type="html"><![CDATA[<p><a name="09RVv"></a></p><h1 id="一、Composer简介"><a href="#一、Composer简介" class="headerlink" title="一、Composer简介"></a>一、Composer简介</h1><p>Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。<br><a name="a0vyx"></a></p><h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><ol><li>一个github账号 </li><li>一个packagist账号 </li><li>一台安装composer的开发机</li></ol><table><thead><tr><th>packagist</th><th>github</th><th>composer</th></tr></thead><tbody><tr><td><a href="https://packagist.org/login/">packagist注册链接</a></td><td><a href="https://github.com/join?source=experiment-header-control-home">github注册链接</a></td><td><a href="https://docs.phpcomposer.com/">composer文档</a></td></tr></tbody></table><p><a name="7rYOu"></a></p><h1 id="三、发布流程"><a href="#三、发布流程" class="headerlink" title="三、发布流程"></a>三、发布流程</h1><p><a name="SR9W9"></a></p><h2 id="1-首先在github上创建一个项目"><a href="#1-首先在github上创建一个项目" class="headerlink" title="1.首先在github上创建一个项目"></a>1.首先在github上创建一个项目</h2><p><a name="K5hbO"></a></p><h2 id="2-把项目克隆到本地"><a href="#2-把项目克隆到本地" class="headerlink" title="2.把项目克隆到本地"></a>2.把项目克隆到本地</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone git@github.com:chendujin/validator.git<br></code></pre></td></tr></tbody></table></figure><p><a name="g9StX"></a></p><h2 id="3-进入项目根目录初始化项目"><a href="#3-进入项目根目录初始化项目" class="headerlink" title="3.进入项目根目录初始化项目"></a>3.进入项目根目录初始化项目</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs git">➜  validator git:(master) composer init<br>                                            <br>  Welcome to the Composer config generator  <br>                                            <br>This command will guide you through creating your composer.json config.<br>Package name (&lt;vendor&gt;/&lt;name&gt;) [chendujin/validator]: <br>Description []: a xdp framework<br>Author [北行10000 &lt;13341007105@163.com&gt;, n to skip]: <br>Minimum Stability []: dev<br>Package Type (e.g. library, project, metapackage, composer-plugin) []: <br>License []: MIT<br>Define your dependencies.<br>Would you like to define your dependencies (require) interactively [yes]? <br>Search for a package: <br>Would you like to define your dev dependencies (require-dev) interactively [yes]? <br>Search for a package: <br>{<br>"name": "chendujin/validator",<br>"description": "各种验证类包",<br>"type": "library",<br>"license": "MIT",<br>"authors": [<br>{<br>            "name": "chendujin",<br>            "email": "1096381436@qq.com"<br>        }<br>],<br>"minimum-stability": "alpha",<br>"require": {<br>"php": "&gt;=7.1.0"<br>},<br>"autoload": {<br>        "psr-4": {<br>            "DataTrans\\": "src/"<br>        }<br>    }<br>}<br>Do you confirm generation [yes]? <br>Would you like the vendor directory added to your .gitignore [yes]? yes<br></code></pre></td></tr></tbody></table></figure><p>此时目录下回程车一个composer.json文件，文件内容形如：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"chendujin/validator"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"各种验证类包"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"library"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"license"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"MIT"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"authors"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">{</span><br>      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"chendujin"</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">"email"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1096381436@qq.com"</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"minimum-stability"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"alpha"</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"require"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"php"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&gt;=7.1.0"</span><br>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"autoload"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"psr-4"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>      <span class="hljs-attr">"DataTrans\\"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"src/"</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><p><a name="96U3U"></a></p><h2 id="4-编写自己的composer包"><a href="#4-编写自己的composer包" class="headerlink" title="4.编写自己的composer包"></a>4.编写自己的composer包</h2><p><a name="ar0MM"></a></p><h3 id="4-1-此处我创建了一个src目录并实现了Validator类"><a href="#4-1-此处我创建了一个src目录并实现了Validator类" class="headerlink" title="4.1 此处我创建了一个src目录并实现了Validator类"></a>4.1 此处我创建了一个src目录并实现了Validator类</h3><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  <span class="hljs-keyword">validator</span> git:(master) ✗ tree<br>.<br>├── README.md<br>├── composer.json<br>└── src<br>    └── <span class="hljs-keyword">Validator</span>.php<br></code></pre></td></tr></tbody></table></figure><p><a name="kF1yp"></a></p><h3 id="4-2-Validator类"><a href="#4-2-Validator类" class="headerlink" title="4.2 Validator类"></a>4.2 Validator类</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 全局数据验证类。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fingerQin</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">DataTrans</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Validator</span> </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为合法的用户名。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $username</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $min_len 最小长度。包含。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $max_len 最大长度。包含。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $mode 用户名模式：digit、alpha、digit_alpha、chinese、digit_alpha_chinese、mix</span><br><span class="hljs-comment">     *            digit：数字</span><br><span class="hljs-comment">     *            aplha：字母</span><br><span class="hljs-comment">     *            digit_alpha：数字和字母</span><br><span class="hljs-comment">     *            chinese：中文</span><br><span class="hljs-comment">     *            digit_alpha_chinese：数字字母中文</span><br><span class="hljs-comment">     *            mix：混合型：数字字母中文下划线破折号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_username</span>(<span class="hljs-params"><span class="hljs-variable">$username</span>, <span class="hljs-variable">$min_len</span>, <span class="hljs-variable">$max_len</span>, <span class="hljs-variable">$mode</span> = <span class="hljs-string">'mix'</span></span>) </span>{<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-variable">$mode</span>) {<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'digit'</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^\d{<span class="hljs-subst">{$min_len}</span>,<span class="hljs-subst">{$max_len}</span>}$/"</span>, <span class="hljs-variable">$username</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'alpha'</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^([a-zA-Z]){<span class="hljs-subst">{$min_len}</span>,<span class="hljs-subst">{$max_len}</span>}$/"</span>, <span class="hljs-variable">$username</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'digit_alpha'</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^([a-z0-9_-]){<span class="hljs-subst">{$min_len}</span>,<span class="hljs-subst">{$max_len}</span>}$/"</span>, <span class="hljs-variable">$username</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'chinese'</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^[\x7f-\xff]{<span class="hljs-subst">{$min_len}</span>,<span class="hljs-subst">{$max_len}</span>}$/"</span>, <span class="hljs-variable">$username</span>)) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'digit_alpha_chinese'</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^[\x7f-\xff|0-9a-zA-Z]{<span class="hljs-subst">{$min_len}</span>,<span class="hljs-subst">{$max_len}</span>}$/"</span>, <span class="hljs-variable">$username</span>)) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'mix'</span>:<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^[\x7f-\xff|0-9a-zA-Z-_]{<span class="hljs-subst">{$min_len}</span>,<span class="hljs-subst">{$max_len}</span>}$/"</span>, <span class="hljs-variable">$username</span>)) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为合法的密码。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $password</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $min_len 最小长度。包含。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $max_len 最大长度。包含。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $mode 用户名模式：digit_alpha、mix</span><br><span class="hljs-comment">     *            digit_alpha：数字和字母</span><br><span class="hljs-comment">     *            mix：混合型：数字字母下划线破折号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_password</span>(<span class="hljs-params"><span class="hljs-variable">$password</span>, <span class="hljs-variable">$min_len</span>, <span class="hljs-variable">$max_len</span>, <span class="hljs-variable">$mode</span> = <span class="hljs-string">'mix'</span></span>) </span>{<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-variable">$mode</span>) {<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'digit_alpha'</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^([a-z0-9]){<span class="hljs-subst">{$min_len}</span>,<span class="hljs-subst">{$max_len}</span>}$/"</span>, <span class="hljs-variable">$password</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'mix'</span>:<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^[0-9a-zA-Z-_]{<span class="hljs-subst">{$min_len}</span>,<span class="hljs-subst">{$max_len}</span>}$/"</span>, <span class="hljs-variable">$password</span>)) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为QQ号码。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $qq</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_qq</span>(<span class="hljs-params"><span class="hljs-variable">$qq</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'/^[1-9]\d{4,12}$/'</span>, <span class="hljs-variable">$qq</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为手机号码。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $mobilephone</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_mobilephone</span>(<span class="hljs-params"><span class="hljs-variable">$mobilephone</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'/^13[\d]{9}$|14^[0-9]\d{8}|^15[0-9]\d{8}$|^18[0-9]\d{8}$/'</span>, <span class="hljs-variable">$mobilephone</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为座机号码。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $telphone</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_telphone</span>(<span class="hljs-params"><span class="hljs-variable">$telphone</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'/^((\(\d{2,3}\))|(\d{3}\-))?(\(0\d{2,3}\)|0\d{2,3}-)?[1-9]\d{6,7}(\-\d{1,4})?$/'</span>, <span class="hljs-variable">$telphone</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为邮政编码。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $zipcode</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_zipcode</span>(<span class="hljs-params"><span class="hljs-variable">$zipcode</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'/^[1-9]\d{5}$/'</span>, <span class="hljs-variable">$zipcode</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断字母是否在某个区域内。用于判断某个字符只能介于[a-h](包含)之间的类似情况。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $alpha 原值。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $start_alpha 起始值。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $end_alpha 截止值。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alpha_between</span>(<span class="hljs-params"><span class="hljs-variable">$alpha</span>, <span class="hljs-variable">$start_alpha</span>, <span class="hljs-variable">$end_alpha</span></span>) </span>{<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Validator</span>::<span class="hljs-title function_ invoke__">is_alpha</span>(<span class="hljs-variable">$alpha</span>) === <span class="hljs-literal">false</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Validator</span>::<span class="hljs-title function_ invoke__">is_alpha</span>(<span class="hljs-variable">$start_alpha</span>) === <span class="hljs-literal">false</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Validator</span>::<span class="hljs-title function_ invoke__">is_alpha</span>(<span class="hljs-variable">$end_alpha</span>) === <span class="hljs-literal">false</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$start_alpha</span> &gt;= <span class="hljs-variable">$end_alpha</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$alpha</span> &lt; <span class="hljs-variable">$start_alpha</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$alpha</span> &gt; <span class="hljs-variable">$end_alpha</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断数字是否在某个区域之间。[2, 10],包含边界值。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $value 原值。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $start_value 起始值。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $end_value 截止值。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">number_between</span>(<span class="hljs-params"><span class="hljs-variable">$value</span>, <span class="hljs-variable">$start_value</span>, <span class="hljs-variable">$end_value</span></span>) </span>{<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$value</span>) === <span class="hljs-literal">false</span> || <span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$start_value</span>) === <span class="hljs-literal">false</span> || <span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$end_value</span>) === <span class="hljs-literal">false</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$start_value</span> &gt;= <span class="hljs-variable">$end_value</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$value</span> &lt; <span class="hljs-variable">$start_value</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$value</span> &gt; <span class="hljs-variable">$end_value</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证是否为中文。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $char</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_chinese</span>(<span class="hljs-params"><span class="hljs-variable">$char</span></span>) </span>{<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$char</span>) === <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">"/^[\x7f-\xff]+$/"</span>, <span class="hljs-variable">$char</span>)) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为字母、数字、下划线（_）、破折号（-）。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_alpha_dash</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'/^([a-z0-9_-])+$/i'</span>, <span class="hljs-variable">$str</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证身份证号码是否合法。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $vStr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_idcard</span>(<span class="hljs-params"><span class="hljs-variable">$vStr</span></span>) </span>{<br>        <span class="hljs-variable">$vCity</span> = <span class="hljs-keyword">array</span>(<br>            <span class="hljs-string">'11'</span>,<span class="hljs-string">'12'</span>,<span class="hljs-string">'13'</span>,<span class="hljs-string">'14'</span>,<span class="hljs-string">'15'</span>,<span class="hljs-string">'21'</span>,<span class="hljs-string">'22'</span>,<br>            <span class="hljs-string">'23'</span>,<span class="hljs-string">'31'</span>,<span class="hljs-string">'32'</span>,<span class="hljs-string">'33'</span>,<span class="hljs-string">'34'</span>,<span class="hljs-string">'35'</span>,<span class="hljs-string">'36'</span>,<br>            <span class="hljs-string">'37'</span>,<span class="hljs-string">'41'</span>,<span class="hljs-string">'42'</span>,<span class="hljs-string">'43'</span>,<span class="hljs-string">'44'</span>,<span class="hljs-string">'45'</span>,<span class="hljs-string">'46'</span>,<br>            <span class="hljs-string">'50'</span>,<span class="hljs-string">'51'</span>,<span class="hljs-string">'52'</span>,<span class="hljs-string">'53'</span>,<span class="hljs-string">'54'</span>,<span class="hljs-string">'61'</span>,<span class="hljs-string">'62'</span>,<br>            <span class="hljs-string">'63'</span>,<span class="hljs-string">'64'</span>,<span class="hljs-string">'65'</span>,<span class="hljs-string">'71'</span>,<span class="hljs-string">'81'</span>,<span class="hljs-string">'82'</span>,<span class="hljs-string">'91'</span><br>        );<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'/^([\d]{17}[xX\d]|[\d]{15})$/'</span>, <span class="hljs-variable">$vStr</span>)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$vStr</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>), <span class="hljs-variable">$vCity</span>)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-variable">$vStr</span> = <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">'/[xX]$/i'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-variable">$vStr</span>);<br>        <span class="hljs-variable">$vLength</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$vStr</span>);<br>     <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$vLength</span> == <span class="hljs-number">18</span>) {<br>            <span class="hljs-variable">$vBirthday</span> = <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$vStr</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) . <span class="hljs-string">'-'</span> . <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$vStr</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>) . <span class="hljs-string">'-'</span> . <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$vStr</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2</span>);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-variable">$vBirthday</span> = <span class="hljs-string">'19'</span> . <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$vStr</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>) . <span class="hljs-string">'-'</span> . <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$vStr</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>) . <span class="hljs-string">'-'</span> . <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$vStr</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>);<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">'Y-m-d'</span>, <span class="hljs-title function_ invoke__">strtotime</span>(<span class="hljs-variable">$vBirthday</span>)) != <span class="hljs-variable">$vBirthday</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$vLength</span> == <span class="hljs-number">18</span>) {<br>            <span class="hljs-variable">$vSum</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">17</span> ; <span class="hljs-variable">$i</span> &gt;= <span class="hljs-number">0</span> ; <span class="hljs-variable">$i</span>--) {<br>                <span class="hljs-variable">$vSubStr</span> = <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$vStr</span>, <span class="hljs-number">17</span> - <span class="hljs-variable">$i</span>, <span class="hljs-number">1</span>);<br>                <span class="hljs-variable">$vSum</span> += (<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-variable">$i</span>) % <span class="hljs-number">11</span>) * ((<span class="hljs-variable">$vSubStr</span> == <span class="hljs-string">'a'</span>) ? <span class="hljs-number">10</span> : <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$vSubStr</span>, <span class="hljs-number">11</span>));<br>            }<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable">$vSum</span> % <span class="hljs-number">11</span> != <span class="hljs-number">1</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证日期时间格式。</span><br><span class="hljs-comment">     * -- 1、验证$value是否为$format格式。</span><br><span class="hljs-comment">     * -- 2、只能验证格式，不能验证时间是否正确。比如：2014-22-22</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $format 格式。格式如：Y-m-d 或H:i:s</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $value 日期。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_date_format</span>(<span class="hljs-params"><span class="hljs-variable">$format</span>, <span class="hljs-variable">$value</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">date_create_from_format</span>(<span class="hljs-variable">$format</span>, <span class="hljs-variable">$value</span>) !== <span class="hljs-literal">false</span>;<br>    }<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为整数。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_integer</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">filter_var</span>(<span class="hljs-variable">$str</span>, FILTER_VALIDATE_INT) !== <span class="hljs-literal">false</span>;<br>    }<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为字母数字。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_alpha_number</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'/^([a-z0-9])+$/i'</span>, <span class="hljs-variable">$str</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为字母。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_alpha</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'/^([a-z])+$/i'</span>, <span class="hljs-variable">$str</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证IP是否合法。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $ip</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_ip</span>(<span class="hljs-params"><span class="hljs-variable">$ip</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">filter_var</span>(<span class="hljs-variable">$ip</span>, FILTER_VALIDATE_IP) !== <span class="hljs-literal">false</span>;<br>    }<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证URL是否合法。</span><br><span class="hljs-comment">     * -- 合法的URL：http://www.baidu.com</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $url</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_url</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">filter_var</span>(<span class="hljs-variable">$url</span>, FILTER_VALIDATE_URL) !== <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断email格式是否正确。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $email</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_email</span>(<span class="hljs-params"><span class="hljs-variable">$email</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">filter_var</span>(<span class="hljs-variable">$email</span>, FILTER_VALIDATE_EMAIL) !== <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否必需。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_require</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$str</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断字符串是否为utf8编码，英文和半角字符返回ture。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $string</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_utf8</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">'%^(?:</span><br><span class="hljs-string">                    [\x09\x0A\x0D\x20-\x7E] # ASCII</span><br><span class="hljs-string">                    | [\xC2-\xDF][\x80-\xBF] # non-overlong 2-byte</span><br><span class="hljs-string">                    | \xE0[\xA0-\xBF][\x80-\xBF] # excluding overlongs</span><br><span class="hljs-string">                    | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2} # straight 3-byte</span><br><span class="hljs-string">                    | \xED[\x80-\x9F][\x80-\xBF] # excluding surrogates</span><br><span class="hljs-string">                    | \xF0[\x90-\xBF][\x80-\xBF]{2} # planes 1-3</span><br><span class="hljs-string">                    | [\xF1-\xF3][\x80-\xBF]{3} # planes 4-15</span><br><span class="hljs-string">                    | \xF4[\x80-\x8F][\x80-\xBF]{2} # plane 16</span><br><span class="hljs-string">                    )*$%xs'</span>, <span class="hljs-variable">$string</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    }<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查字符串长度。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $str 字符串。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $min 最小长度。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $max 最大长度。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bool $is_utf8 是否UTF-8字符。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">len</span>(<span class="hljs-params"><span class="hljs-variable">$str</span>, <span class="hljs-variable">$min</span> = <span class="hljs-number">0</span>, <span class="hljs-variable">$max</span> = <span class="hljs-number">255</span>, <span class="hljs-variable">$is_utf8</span> = <span class="hljs-literal">false</span></span>) </span>{<br>        <span class="hljs-variable">$len</span> = <span class="hljs-variable">$is_utf8</span> ? <span class="hljs-title function_ invoke__">mb_strlen</span>(<span class="hljs-variable">$str</span>) : <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$str</span>);<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-variable">$len</span> &gt;= <span class="hljs-variable">$min</span>) &amp;&amp; (<span class="hljs-variable">$len</span> &lt;= <span class="hljs-variable">$max</span>)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><a name="OsLtu"></a></p><h3 id="4-3-自动加载src目录"><a href="#4-3-自动加载src目录" class="headerlink" title="4.3 自动加载src目录"></a>4.3 自动加载src目录</h3><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">在<span class="hljs-number">4.2</span>添加了<span class="hljs-attribute">src</span>的加载运行composer install实现自动加载<br>➜  validator git:(master) ✗ composer install<br>Loading composer repositories with package information<br>Updating dependencies (including require-dev)<br>Nothing to install or update<br>Generating autoload files<br>此时目录中会生成一个vendor 它实现了加载方法<br>➜  validator git:(master) ✗ tree<br>.<br>├── README<span class="hljs-selector-class">.md</span><br>├── composer<span class="hljs-selector-class">.json</span><br>├── <span class="hljs-attribute">src</span><br>│   └── Validator<span class="hljs-selector-class">.php</span><br>└── vendor<br>    ├── autoload<span class="hljs-selector-class">.php</span><br>    └── composer<br>        ├── ClassLoader<span class="hljs-selector-class">.php</span><br>        ├── LICENSE<br>        ├── autoload_classmap<span class="hljs-selector-class">.php</span><br>        ├── autoload_namespaces<span class="hljs-selector-class">.php</span><br>        ├── autoload_psr4<span class="hljs-selector-class">.php</span><br>        ├── autoload_real<span class="hljs-selector-class">.php</span><br>        ├── autoload_static<span class="hljs-selector-class">.php</span><br>        └── installed.json<br></code></pre></td></tr></tbody></table></figure><p><a name="KbNOl"></a></p><h3 id="4-4-测试结果"><a href="#4-4-测试结果" class="headerlink" title="4.4 测试结果"></a>4.4 测试结果</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php">创建test.php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">'../vendor/autoload.php'</span>;<br><br><span class="hljs-keyword">use</span> \<span class="hljs-title">DataTrans</span>\<span class="hljs-title">Validator</span>;<br><br><span class="hljs-variable">$mobilephone</span> = <span class="hljs-string">'18665027895'</span>;<br><span class="hljs-variable">$ok</span> = <span class="hljs-title class_">Validator</span>::<span class="hljs-title function_ invoke__">is_mobilephone</span>(<span class="hljs-variable">$mobilephone</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$ok</span>) {<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">'是手机号码'</span>;<br>} <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">'不是手机号码'</span>;<br>}<br>命令行中运行<br>➜  validator git:(master) ✗ php test.php<br>是手机号码<br></code></pre></td></tr></tbody></table></figure><p><a name="XTvHM"></a></p><h3 id="4-5-忽略vendor、composer-json文件"><a href="#4-5-忽略vendor、composer-json文件" class="headerlink" title="4.5 忽略vendor、composer.json文件"></a>4.5 忽略vendor、composer.json文件</h3><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">修改<span class="hljs-string">.gitignore</span>增加下面两行<br><span class="hljs-string">.vscode</span><br><span class="hljs-string">/vendor/</span><br>composer.lock<br></code></pre></td></tr></tbody></table></figure><p><a name="Lbjsr"></a></p><h3 id="4-6提交代码到-github"><a href="#4-6提交代码到-github" class="headerlink" title="4.6提交代码到 github"></a>4.6提交代码到 github</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">"提交Validator扩展包"</span><br>git push origin master<br></code></pre></td></tr></tbody></table></figure><p><a name="daXn2"></a></p><h2 id="5-Packagist配置"><a href="#5-Packagist配置" class="headerlink" title="5. Packagist配置"></a>5. Packagist配置</h2><p><a name="AWVQe"></a></p><h3 id="5-1-github关联到Packagist"><a href="#5-1-github关联到Packagist" class="headerlink" title="5.1 github关联到Packagist"></a>5.1 github关联到Packagist</h3><ol><li>首先要在Packagist上登录</li><li>点击顶部导航条中的Summit按钮</li><li>在输入框中输入github上的仓库地址，如：<a href="mailto:git@github.com">git@github.com</a>:chendujin/validator.git</li><li>然后点击Check按钮</li><li>Packagist会去检测此仓库地址的代码是否符合Composer的Package包的要求</li><li>检测正常的话，会出现Submit按钮，再点击一下Submit按钮，我们的包就提交到Packagist上了</li></ol><p><a name="BRC4N"></a></p><h3 id="5-2-配置自动同步"><a href="#5-2-配置自动同步" class="headerlink" title="5.2 配置自动同步"></a>5.2 配置自动同步</h3><ol><li>从Packagist点击个人中心点击profile获取token然后复制</li><li>到github项目首页上点击settings、点击webhooks、点击addwebhook</li><li>把<a href="https://packagist.org/api/bitbucket?username=USERNAME&amp;apiToken=TOKEN">https://packagist.org/api/bitbucket?username=USERNAME&amp;apiToken=TOKEN</a> 复制到Payload URL，在下方输入密码后保存</li></ol><p><a name="PFQvd"></a></p><h1 id="四、引用包"><a href="#四、引用包" class="headerlink" title="四、引用包"></a>四、引用包</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">composer require chendujin/validator<br></code></pre></td></tr></tbody></table></figure><p><a name="cdbH6"></a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果下载不下来到话就换一下镜像<br><code>composer config -g repo.packagist composer https://packagist.laravel-china.org</code><br>刚发布上去可能会下载不到，没有同步过来– 可以等一会在试试看</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go跨平台编译(交叉编译)</title>
      <link href="/posts/e4d19241.html"/>
      <url>/posts/e4d19241.html</url>
      
        <content type="html"><![CDATA[<p><a name="flj2V"></a></p><h2 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a><strong>跨平台编译</strong></h2><p>跨平台编译，也叫交叉编译，我可以在win平台上，编译成linux平台可执行的文件。<br>这也是Go备受青睐的原因，像java,python,php等语言，我们开发一般是在win平台上开发，部署的时候在linux上部署，在处理第三方依赖是比较麻烦，不仅开发累，运维也累，虽然现在有docker解决了这个痛点，但是应该还是没原生来的舒服。<br>如果使用Go的话，不管是什么第三方依赖，最终只会打包成一个可执行文件，直接部署即刻，并且是高并发方式，心再大一点，连Nginx都不用，但是一点不用担心并发问题。</p><p><strong>Windows下编译Mac和Linux平台64位可执行程序：</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build<br>SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build<br></code></pre></td></tr></tbody></table></figure><p><strong>Mac 下编译 Linux 和 Windows平台 64位 可执行程序：</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build<br>CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build<br></code></pre></td></tr></tbody></table></figure><p><strong>Linux 下编译 Mac 和 Windows 平台64位可执行程序：</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build<br>CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go入门基础 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go入门基础 </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-内置类型和内置函数</title>
      <link href="/posts/4312b66a.html"/>
      <url>/posts/4312b66a.html</url>
      
        <content type="html"><![CDATA[<p><a name="IZWUv"></a></p><h2 id="1-内置类型"><a href="#1-内置类型" class="headerlink" title="1. 内置类型"></a>1. 内置类型</h2><p><a name="SUiXe"></a></p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bool</span> -- 布尔类型<br><span class="hljs-attribute">string</span> -- <span class="hljs-number">8</span>位byte序列构成的字符串，约定但不必须是utf-<span class="hljs-number">8</span>编码的文本。字符串可以为空但不能是nil，其值不可变。<br><span class="hljs-attribute">int</span> -- 至少<span class="hljs-number">32</span>位的有符号整形，但和int32/rune并非同一类型。<br><span class="hljs-attribute">uint</span> -- 至少<span class="hljs-number">32</span>位的无符号整形，但和uint32不是同一类型。<br><span class="hljs-attribute">int8</span> -- <span class="hljs-number">8</span>位有符号整形，范围[-<span class="hljs-number">128</span>, <span class="hljs-number">127</span>]。<br><span class="hljs-attribute">uint8</span> -- <span class="hljs-number">8</span>位无符号整型，范围[<span class="hljs-number">0</span>, <span class="hljs-number">255</span>]。<br><span class="hljs-attribute">int16</span> -- <span class="hljs-number">16</span>位有符号整形，范围[-<span class="hljs-number">32768</span>, <span class="hljs-number">32767</span>]。<br><span class="hljs-attribute">uint16</span> -- <span class="hljs-number">16</span>位无符号整型，范围[<span class="hljs-number">0</span>, <span class="hljs-number">65535</span>]。<br><span class="hljs-attribute">int32</span> -- <span class="hljs-number">32</span>位有符号整形，范围[-<span class="hljs-number">2147483648</span>, <span class="hljs-number">2147483647</span>]。<br><span class="hljs-attribute">uint32</span> -- <span class="hljs-number">32</span>位无符号整型，范围[<span class="hljs-number">0</span>, <span class="hljs-number">4294967295</span>]。<br><span class="hljs-attribute">int64</span> -- <span class="hljs-number">64</span>位有符号整形，范围[-<span class="hljs-number">9223372036854775808</span>, <span class="hljs-number">9223372036854775807</span>]。<br><span class="hljs-attribute">uint64</span> -- <span class="hljs-number">64</span>位无符号整型，范围[<span class="hljs-number">0</span>, <span class="hljs-number">18446744073709551615</span>]。<br><span class="hljs-attribute">uintptr</span> -- 可以保存任意指针的位模式的整数类型。<br><span class="hljs-attribute">byte</span> -- <span class="hljs-number">8</span>位无符号整型，是uint8的别名，二者视为同一类型。<br><span class="hljs-attribute">rune</span> -- <span class="hljs-number">32</span>位有符号整形，int32的别名，二者视为同一类型。<br><span class="hljs-attribute">float32</span> -- 所有IEEE-<span class="hljs-number">754</span> <span class="hljs-number">32</span>位浮点数的集合，<span class="hljs-number">12</span>位有效数字。<br><span class="hljs-attribute">float64</span> -- 所有IEEE-<span class="hljs-number">754</span> <span class="hljs-number">64</span>位浮点数的集合，<span class="hljs-number">16</span>位有效数字。<br><span class="hljs-attribute">complex64</span> -- 具有float32 类型实部和虚部的复数类型。<br><span class="hljs-attribute">complex128</span> -- 具有float64 类型实部和虚部的复数类型。<br><span class="hljs-attribute">array</span> -- 固定长度的数组<br></code></pre></td></tr></tbody></table></figure><p><a name="MiQVZ"></a></p><h3 id="引用类型：-指针类型"><a href="#引用类型：-指针类型" class="headerlink" title="引用类型：(指针类型)"></a>引用类型：(指针类型)</h3><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">slice</span>   <span class="hljs-comment">-- 序列数组(最常用)</span><br>map     <span class="hljs-comment">-- 映射</span><br>chan    <span class="hljs-comment">-- 管道</span><br></code></pre></td></tr></tbody></table></figure><p><a name="GrSz5"></a></p><h2 id="2-内置函数"><a href="#2-内置函数" class="headerlink" title="2. 内置函数"></a>2. 内置函数</h2><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>append</td><td>用来追加元素到array、slice中,返回修改后的array、slice</td></tr><tr><td>close</td><td>用于管道通信，主要用来关闭channel，用于<strong>发送方</strong>关闭chan，仅适用于双向或发送通道。</td></tr><tr><td>delete</td><td>从map中删除key对应的value</td></tr><tr><td>new、make</td><td><strong>new 和 make 均是用于分配内存：</strong> <strong>new</strong> 用于<strong>值类型</strong>和<strong>用户定义的类型</strong>，如int、struct <strong>自定义结构体</strong>。返回指向Type的指针。生成类型T的零值指针,注意它返回的是指针 <em>T。*<em>make</em></em> 用于<strong>内置引用类型</strong>（只能应用于slice、map 和channel）。返回Type本身。生成slice、map、channel对象。<br>它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。<br>new(T) 分配类型 T 的<strong>零值并返回其地址</strong>，也就是<strong>指向类型 T 的指针</strong>。它也可以被用于基本类型：<code>v := new(int)</code>。<br>make(T) 返回类型 T 的<strong>初始化之后的值(实例)<strong>，返回的是一个实例，而不是指针,因此它比 new 进行更多的工作，</strong>new() 是一个函数，不要忘记它的括号。</strong> <br> <strong>new 函数作用于值类型，仅分配内存空间，返回的是指针，make 函数作用于引用类型，除了分配内存空间，还会对对应类型进行初始化，返回的是初始值。</strong> 在 Go 语言中，引用类型包括切片（slice）、字典（map）和管道（channel），其它都是值类型。</td></tr><tr><td>len</td><td>len 用于返回某个类型的长度或数量（string、array、slice、map 和channel）</td></tr><tr><td>cap</td><td>capacity是容量的意思，用于返回某个类型的最大容量（只能用于slice和 map）</td></tr><tr><td>copy</td><td>用于复制和连接slice，返回复制的数目</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制： <br>panic：停止常规的goroutine <br>recover：允许程序定义goroutine的panic动作</td></tr><tr><td>complex、real、imag</td><td>用于创建和操作复数<br> complex：从指定的实部和虚部构建复数<br>real：返回complex的实部<br> imag：返回complex的虚部</td></tr><tr><td>print、println</td><td>底层打印函数，在部署环境中建议使用 fmt 包</td></tr></tbody></table><p><a name="f6aWm"></a></p><h3 id="make用法示例"><a href="#make用法示例" class="headerlink" title="make用法示例"></a>make用法示例</h3><blockquote><p><strong>func make(t Type, size …IntegerType) Type</strong></p></blockquote><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"># 生成slice、<span class="hljs-keyword">map</span>、channel对象<br>sl1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)     <span class="hljs-comment">//定义长度和容量都为5的切片</span><br>sl2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">//定义长度为5，容量为10的切片</span><br><br>map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>) <span class="hljs-comment">//定义map</span><br>map2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">//定义map 初始可以容纳2个元素的空间</span><br><br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">//定义不带缓存的channel</span><br>c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 定义缓存大小为5的channel</span><br><br># 切片：size指定了其长度。该切片的容量等于其长度。切片支持第二个整数实参可用来指定不同的容量；<br>     它必须不小于其长度，因此 <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>) 会分配一个长度为<span class="hljs-number">0</span>，容量为<span class="hljs-number">10</span>的切片。<br># 映射：初始分配的创建取决于size，但产生的映射长度为<span class="hljs-number">0</span>。size可以省略，这种情况下就会分配一个<br>     小的起始大小。<br># 通道：通道的缓存根据指定的缓存容量初始化。若 size为零或被省略，该信道即为无缓存的。<br></code></pre></td></tr></tbody></table></figure><ul><li>make函数也用于内存分配，和new不同的地方在于，make函数只能用于chan，map和切片三种类型的创建，返回值就是对象本身，因为这三类数据结构本身就是引用类型，必须要初始化。<br><a name="oGMQe"></a><h3 id="new用法示例"><a href="#new用法示例" class="headerlink" title="new用法示例"></a>new用法示例</h3><blockquote><p><strong>funcnew(Type) Type</strong></p></blockquote></li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">p1 := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)     <span class="hljs-comment">// 返回 int 类型指针</span><br>p2 := <span class="hljs-built_in">new</span>(<span class="hljs-type">string</span>)  <span class="hljs-comment">// 返回 string 类型指针</span><br>p3 := <span class="hljs-built_in">new</span>([<span class="hljs-number">3</span>]<span class="hljs-type">int</span>)  <span class="hljs-comment">// 返回数组类型指针，数组长度是3</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> {<br>    id <span class="hljs-type">int</span><br>    name <span class="hljs-type">string</span><br>    grade <span class="hljs-type">string</span><br>}<br>p4 := <span class="hljs-built_in">new</span>(Student)  <span class="hljs-comment">// 返回对象类型指针</span><br><br><span class="hljs-built_in">println</span>(<span class="hljs-string">"p1: "</span>, p1)<br><span class="hljs-built_in">println</span>(<span class="hljs-string">"p2: "</span>, p2)<br><span class="hljs-built_in">println</span>(<span class="hljs-string">"p3: "</span>, p3)<br><span class="hljs-built_in">println</span>(<span class="hljs-string">"p4: "</span>, p4)<br></code></pre></td></tr></tbody></table></figure><ul><li>new函数用来创建某一个类型的指针型对象，理论上，只要一个数据类型能够被访问到，就能用new函数来创建指针类型的对象。返回值是一个指向新分配的type类型的零值的指针。</li><li>在Go语言中，如果使用new创建chan类型的指针对象，在使用之前仍然需要使用make函数来初始化chan的容量。</li><li>new函数创建对象与直接使用struct{}创建的对象的区别是，前者为指向对象的一个指针，后者创建的是对象引用本身。<br><a name="jiOyk"></a><h3 id="append用法示例"><a href="#append用法示例" class="headerlink" title="append用法示例"></a>append用法示例</h3><blockquote><p><strong>func append(slice []Type, elems …Type) []Type</strong></p></blockquote></li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"># 增加<span class="hljs-number">0</span>到n个元素到slice中，返回新的slice，注意第一个参数不能是指针类型<br>intslice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>intslice = <span class="hljs-built_in">append</span>(intslice, <span class="hljs-number">1</span>)<br>intslice = <span class="hljs-built_in">append</span>(intslice, <span class="hljs-number">2</span>)<br><span class="hljs-comment">//intslice : [1,2]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>go语言中的append函数作用是在切片变量的后面追加新的数据，然后返回新的切片变量</li><li>内建函数append将元素追加到切片的末尾。若它有足够的容量，其目标就会重新切片以容纳新的元素。否则，就会分配一个新的基本数组。append返回更新后的切片，因此必须存储追加后的结果。<br><a name="HhCvq"></a><h3 id="complex用法示例"><a href="#complex用法示例" class="headerlink" title="complex用法示例"></a>complex用法示例</h3>Go提供了两种大小的复数类型：complex64和complex128，分别由float32和float64组成。<blockquote><p><strong>func complex(r, i FloatType) ComplexType  // 参数列表中r 为复数的实部，i 表示为复数的虚部</strong><br><strong>func real(c ComplexType) FloatType</strong><br><strong>func imag(c ComplexType) FloatType</strong></p></blockquote></li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1+2i  构建复数</span><br><span class="hljs-keyword">var</span> y <span class="hljs-type">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 3+4i 构建复数</span><br>fmt.Println(x*y)                 <span class="hljs-comment">// "(-5+10i)" </span><br>fmt.Println(<span class="hljs-built_in">real</span>(x*y))           <span class="hljs-comment">// "-5"  获取实部</span><br>fmt.Println(<span class="hljs-built_in">imag</span>(x*y))           <span class="hljs-comment">// "10"  获取虚部</span><br></code></pre></td></tr></tbody></table></figure><p><a name="iZULq"></a></p><h3 id="close用法示例"><a href="#close用法示例" class="headerlink" title="close用法示例"></a>close用法示例</h3><blockquote><p><strong>func close(c chan&lt;- Type)</strong></p></blockquote><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"># 关闭channel<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-built_in">close</span>(ch)<br><span class="hljs-built_in">close</span>(ch)  <span class="hljs-comment">// 这样会panic的，channel不能close两次</span><br>ch &lt;- <span class="hljs-literal">false</span>  <span class="hljs-comment">//已经关闭channel 不能写入数据</span><br>i, ok := &lt;- ch  判断channel是否关闭<br>i := &lt;-ch 不会<span class="hljs-built_in">panic</span>, i读取到的值是<span class="hljs-literal">false</span>,如果是有缓存channel，可以继续读取channel中的剩余的数据<br></code></pre></td></tr></tbody></table></figure><ul><li>内建函数close关闭信道，该通道必须为双向的或只发送的。它应当只由发送者执行，而不应由接收者执行，其效果是在最后发送的值被接收后停止该通道。在最后的值从已关闭的信道中被接收后，任何对其的接收操作都会无阻塞的成功。</li><li>close函数用于关闭一个非只读的管道。</li><li>close方法应该由管道的数据发送一方调用。</li><li>当最后一个发送的值被从管道中接收之后，后面的所有值接收都会非阻塞直接返回，返回值为元素类型的零值。</li><li>如果chan已经关闭，则x,ok := &lt;- chan 中，ok为false。<br><a name="vL4qo"></a><h3 id="panic用法示例"><a href="#panic用法示例" class="headerlink" title="panic用法示例"></a>panic用法示例</h3><blockquote><p><strong>func panic(v interface{})</strong><br><strong>func recover() interface{}</strong></p></blockquote></li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> { <span class="hljs-comment">// 必须要先声明defer，否则不能捕获到panic异常</span><br>    fmt.Println(<span class="hljs-string">"c"</span>)<br>    <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> { <span class="hljs-comment">//调用recover函数将会捕获到当前的panic（如果有的话</span><br>        fmt.Println(err) <span class="hljs-comment">// 这里的err其实就是panic传入的内容，55</span><br>    }<br>    fmt.Println(<span class="hljs-string">"d"</span>)<br>}()<br><br>fmt.Println(<span class="hljs-string">"a"</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-number">55</span>) <span class="hljs-comment">// panic是用来表示非常严重的不可恢复的错误的,一般会导致程序挂掉（除非recover)</span><br>fmt.Println(<span class="hljs-string">"b"</span>)<br>fmt.Println(<span class="hljs-string">"f"</span>)<br><span class="hljs-comment">// 输出结果：a c 55 d</span><br><br># <span class="hljs-built_in">panic</span> 只会触发当前 Goroutine 的延迟函数调用<br># <span class="hljs-built_in">recover</span> 只有在 <span class="hljs-keyword">defer</span> 函数中调用才会生效；<br># <span class="hljs-built_in">panic</span> 允许在 <span class="hljs-keyword">defer</span> 中嵌套多次调用；<br></code></pre></td></tr></tbody></table></figure><ul><li>内建函数panic停止当前Go程的正常执行。当函数F调用panic时，F的正常执行就会立刻停止。F中defer的所有函数先入后出执行后，F返回给其调用者G。G如同F一样行动，层层返回，直到该Go程中所有函数都按相反的顺序停止执行。之后，程序被终止，而错误情况会被报告，包括引发该恐慌的实参值，此终止序列称为恐慌过程。</li><li>内建函数recover允许程序管理恐慌过程中的Go程序。在defer的函数中，执行recover调用会取回传至panic调用的错误值，恢复正常执行，停止恐慌过程。若recover在defer的函数之外被调用，它将不会停止恐慌过程序列。在此情况下，或当该Go程不在恐慌过程中时，或提供给panic的实参为nil时，recover就会返回nil。</li><li>panic函数表示程序中非常严重，不可恢复的错误，与java中的 try{} catch{} 类似。</li><li>panic异常被抛出之后，会一层一层的上传至最外层，直至程序崩溃。</li><li>recover函数用于捕获程序中抛出的panic，recover函数只能在defer延迟函数中调用。<br><a name="oU4hY"></a><h3 id="cap用法示例"><a href="#cap用法示例" class="headerlink" title="cap用法示例"></a>cap用法示例</h3><blockquote><p><strong>func cap(v Type) int</strong></p></blockquote></li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"># 可以用来查看数组或slice的容量<br>slice := []<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>}<br>slice1 := slice[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]<br>    <br>fmt.Println(slice)       <span class="hljs-comment">//[1 2 3 4 5 6 7 8 9]</span><br>fmt.Println(slice1)      <span class="hljs-comment">// [2 3 4 5] : 包括1 但不包括5</span><br>fmt.Println(<span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 4 切片的长度</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 8 切片的容量</span><br><br># 内建函数<span class="hljs-built_in">cap</span>返回 v 的容量，这取决于具体类型：<br># 数组：v中元素的数量，与 <span class="hljs-built_in">len</span>(v) 相同<br># 数组指针：*v中元素的数量，与<span class="hljs-built_in">len</span>(v) 相同<br># 切片：切片的容量（底层数组的长度）；若 v为<span class="hljs-literal">nil</span>，<span class="hljs-built_in">cap</span>(v) 即为零<br># 信道：按照元素的单元，相应信道缓存的容量；若v为<span class="hljs-literal">nil</span>，<span class="hljs-built_in">cap</span>(v)即为零<br></code></pre></td></tr></tbody></table></figure><ul><li>cap函数用来计算切片，通道，数组类型变量的容量，即这个容器最多能装多少元素。</li><li>如果v是nil，则cap(v) 容量获取到的是0。<br><a name="FpLCV"></a><h3 id="len用法示例"><a href="#len用法示例" class="headerlink" title="len用法示例"></a>len用法示例</h3><blockquote><p><strong>func len(v Type) int</strong></p></blockquote></li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"># 得到字符串、数组、数值指针、slice、<span class="hljs-keyword">map</span>、<span class="hljs-keyword">chan</span>的长度<br>s := <span class="hljs-string">"hello world,你好中国"</span><br>a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}<br>sl := a[:<span class="hljs-number">3</span>]<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>{<span class="hljs-string">"a"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"b"</span>: <span class="hljs-number">2</span>}<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><br>fmt.Println(<span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 字符串：记录字节数。   24</span><br>fmt.Println(<span class="hljs-built_in">len</span>(a)) <span class="hljs-comment">// 数组：记录数组元素个数。 5</span><br>fmt.Println(<span class="hljs-built_in">len</span>(sl)) <span class="hljs-comment">// 切片：记录切片元素个数。 3</span><br>fmt.Println(<span class="hljs-built_in">len</span>(m))  <span class="hljs-comment">// map：记录map元素个数。2</span><br>fmt.Println(<span class="hljs-built_in">len</span>(c))  <span class="hljs-comment">// channel：记录channel通道中的元素个数    0</span><br></code></pre></td></tr></tbody></table></figure><ul><li>len函数用来获取字符串，切片，数组，通道，字典类型变量的内容长度，不同的类型，长度的计算规则不一致。对于切片，字典，数组，通道类型的变量，他们中的每一个元素就是一个长度。string类型的变量，每一个字节都是一个长度，中文字在utf8编码中占三个字节，故len获取string类型长度时，每一个汉字都是三个长度。</li><li>len计算的是变量已有数据的内容长度，并非是变量的容量。</li><li>如果v是nil，则len(v)为0。<br><a name="myXVj"></a><h3 id="delete用法示例"><a href="#delete用法示例" class="headerlink" title="delete用法示例"></a>delete用法示例</h3><blockquote><p><strong>func delete(m map[Type]Type1, key Type)</strong></p></blockquote></li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"># 删除<span class="hljs-keyword">map</span>中的一个映射， m为<span class="hljs-literal">nil</span>或者m[k]不存在也不会<span class="hljs-built_in">panic</span>,而是一个空操作<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>{<br>    <span class="hljs-number">1</span>: <span class="hljs-string">"张三"</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">"李四"</span>,<br>}<br><span class="hljs-built_in">delete</span>(m, <span class="hljs-number">1</span>)<br>fmt.Println(m) <span class="hljs-comment">// map[2:李四]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>内建函数delete按照指定的键将元素从映射中删除。若m为nil或无此元素，delete不进行操作<br><a name="wPWFJ"></a><h3 id="copy用法示例"><a href="#copy用法示例" class="headerlink" title="copy用法示例"></a>copy用法示例</h3><blockquote><p><strong>func copy(dst, src []Type) int</strong></p></blockquote></li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"># 用于将源slice的数据（第二个参数），复制到目标slice（第一个参数）。<br># 返回值为拷贝了的数据个数，是<span class="hljs-built_in">len</span>(dst)和<span class="hljs-built_in">len</span>(src)中的最小值。<br><span class="hljs-keyword">var</span> a = []<span class="hljs-type">int</span>{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>}<br><span class="hljs-keyword">var</span> s = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">6</span>)<br><span class="hljs-comment">//源长度为8，目标为6，只会复制前6个</span><br>n1 := <span class="hljs-built_in">copy</span>(s, a)<br>fmt.Println(<span class="hljs-string">"s - "</span>, s)<br>fmt.Println(<span class="hljs-string">"n1 - "</span>, n1)<br><span class="hljs-comment">//源长为7，目标为6，复制索引1到6</span><br>n2 := <span class="hljs-built_in">copy</span>(s, a[<span class="hljs-number">1</span>:])<br>fmt.Println(<span class="hljs-string">"s - "</span>, s)<br>fmt.Println(<span class="hljs-string">"n2 - "</span>, n2)<br><span class="hljs-comment">//源长为8-5=3，只会复制3个值，目标中的后三个值不会变</span><br>n3 := <span class="hljs-built_in">copy</span>(s, a[<span class="hljs-number">5</span>:])<br>fmt.Println(<span class="hljs-string">"s - "</span>, s)<br>fmt.Println(<span class="hljs-string">"n3 - "</span>, n3)<br><span class="hljs-comment">//将源中的索引5,6,7复制到目标中的索引3,4,5</span><br>n4 := <span class="hljs-built_in">copy</span>(s[<span class="hljs-number">3</span>:], a[<span class="hljs-number">5</span>:])<br>fmt.Println(<span class="hljs-string">"s - "</span>, s)<br>fmt.Println(<span class="hljs-string">"n4 - "</span>, n4)<br></code></pre></td></tr></tbody></table></figure><ul><li><p>copy函数把slice源的数据复制到目的切片中，需要注意的是，copy不会主动的扩展目的切片的容量，在目的slice填充满之后会舍弃超出的部分，返回的是复制成功的元素个数</p></li><li><p>若目的slice原来有元素，则会被覆盖掉<br><a name="xcRXe"></a></p><h2 id="3-内置接口error"><a href="#3-内置接口error" class="headerlink" title="3. 内置接口error"></a>3. 内置接口error</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> { <span class="hljs-comment">//只要实现了Error()函数，返回值为String的都实现了err接口</span><br>    Error()    String <span class="hljs-comment">//内建error接口类型是约定用于表示错误信息，nil值表示无错误。</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>nil是预定义的标识符，代表指针、通道、函数、接口、映射或切片的零值。</strong></p></li><li><p><strong>iota是一个预定义的标识符，代表顺序按行增加的无符号整数。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go入门基础 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go入门基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-init函数和mian函数</title>
      <link href="/posts/78525829.html"/>
      <url>/posts/78525829.html</url>
      
        <content type="html"><![CDATA[<p><a name="dscSF"></a></p><h2 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h2><p>go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性。<br>有下面的特征：</p><blockquote><ol><li>init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</li><li>每个包可以拥有多个init函数</li><li>包的每个源文件也可以拥有多个init函数</li><li>同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)  </li><li>不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序 </li><li>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用 </li></ol></blockquote><p><a name="qHkgp"></a></p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><pre><code class="hljs">Go语言程序的默认入口函数(主函数)：</code></pre><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">Go语言程序的默认入口函数(主函数)：<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>    函数体用｛｝一对括号包裹。<br><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-comment">//函数体</span><br>    }<br></code></pre></td></tr></tbody></table></figure><p><a name="Us0BK"></a></p><h2 id="init函数和main函数的异同"><a href="#init函数和main函数的异同" class="headerlink" title="init函数和main函数的异同"></a>init函数和main函数的异同</h2><blockquote><p>相同点：<br>两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。<br>不同点：<br>init可以应用于任意包中，且可以重复定义多个。<br>main函数只能用于main包中，且只能定义一个。</p></blockquote><p><strong>两个函数的执行顺序：</strong></p><ul><li>对同一个go文件的init()调用顺序是从上到下的。</li><li>对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数。</li><li>对于不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。</li><li>如果init函数中使用了println()或者print()你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go入门基础 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go入门基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go实现单链表</title>
      <link href="/posts/570a3f11.html"/>
      <url>/posts/570a3f11.html</url>
      
        <content type="html"><![CDATA[<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>NNode: 包含一个数据域，一个指针域（指向下一个节点）<br>LList : 包含头指针 (指向第一个节点)，链表长度<br>链表的特点：不能随机访问，只能根据链一个一个查找，查找的时间复杂度是 O (n)</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +---------------------------------------------------------------</span><br><span class="hljs-comment">// | Description: Go实现单链表(goLinkList.go)</span><br><span class="hljs-comment">// +---------------------------------------------------------------</span><br><span class="hljs-comment">// | Author: thomas.chen &lt;thomas.chen@huolala.cn&gt;</span><br><span class="hljs-comment">// +---------------------------------------------------------------</span><br><span class="hljs-comment">// | CreateTime: 2022/3/10</span><br><span class="hljs-comment">// +---------------------------------------------------------------</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-comment">// NNode 定义节点的结构体</span><br><span class="hljs-keyword">type</span> NNode <span class="hljs-keyword">struct</span> {<br>Data <span class="hljs-keyword">interface</span>{} <span class="hljs-comment">// 数据域</span><br>Next *NNode      <span class="hljs-comment">// 指针域</span><br>}<br><br><span class="hljs-comment">// LList 定义链表结构体</span><br><span class="hljs-keyword">type</span> LList <span class="hljs-keyword">struct</span> {<br>Header *NNode <span class="hljs-comment">// 指向第一个节点</span><br>Length <span class="hljs-type">int</span>    <span class="hljs-comment">// 链表长度</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateNode</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>{})</span></span> *NNode {<br><span class="hljs-keyword">return</span> &amp;NNode{v, <span class="hljs-literal">nil</span>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateList</span><span class="hljs-params">()</span></span> *LList {<br>header := CreateNode(<span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">return</span> &amp;LList{header, <span class="hljs-number">0</span>}<br>}<br><br><span class="hljs-comment">// Add 往链表头增加一个节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LList)</span></span> Add(data <span class="hljs-keyword">interface</span>{}) {<br>newNode := CreateNode(data)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>l.Length++<br>}()<br><br><span class="hljs-keyword">if</span> l.Length == <span class="hljs-number">0</span> {<br>l.Header = newNode<br>} <span class="hljs-keyword">else</span> {<br>newNode.Next = l.Header<br>l.Header = newNode <span class="hljs-comment">// 头指针指向新加的节点</span><br>}<br>}<br><br><span class="hljs-comment">// Append 往链表尾加一个节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LList)</span></span> Append(data <span class="hljs-keyword">interface</span>{}) {<br>newNode := CreateNode(data)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>l.Length++<br>}()<br><br><span class="hljs-keyword">if</span> l.Length == <span class="hljs-number">0</span> {<br>l.Header = newNode<br>}<br><br><span class="hljs-keyword">if</span> l.Length &gt; <span class="hljs-number">0</span> {<br>current := l.Header<br><span class="hljs-keyword">for</span> current.Next != <span class="hljs-literal">nil</span> { <span class="hljs-comment">// 循环找到最后一个节点</span><br>current = current.Next<br>}<br>current.Next = newNode <span class="hljs-comment">// 把新节点地址给最后一个节点的Next</span><br>}<br>}<br><br><span class="hljs-comment">// Insert 往i插入一个节点，后插</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LList)</span></span> Insert(i <span class="hljs-type">int</span>, data <span class="hljs-keyword">interface</span>{}) {<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>l.Length++<br>}()<br><br><span class="hljs-keyword">if</span> i &gt;= l.Length {<br>l.Append(data)<br><span class="hljs-keyword">return</span><br>}<br>newNode := CreateNode(data)<br><span class="hljs-comment">// 找到第i个节点pre和第i+1个after</span><br>j := <span class="hljs-number">1</span><br>pre := l.Header<br><span class="hljs-keyword">for</span> j != i {<br>pre = pre.Next<br>j++<br>}<br>newNode.Next = pre.Next <span class="hljs-comment">// 获取到i+1个节点</span><br><span class="hljs-comment">// 修改i节点，新节点的指针</span><br>pre.Next = newNode<br>}<br><br><span class="hljs-comment">// Delete 删除第i个节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LList)</span></span> Delete(i <span class="hljs-type">int</span>) {<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>l.Length--<br>}()<br><br><span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> { <span class="hljs-comment">// 删除第一个节点，把header指向第二个节点即可</span><br>l.Header = l.Header.Next<br><span class="hljs-keyword">return</span><br>}<br><span class="hljs-comment">// 找到第i-1个节点的next指向第i+1个节点即可</span><br>j := <span class="hljs-number">1</span><br>current := l.Header<br><span class="hljs-keyword">for</span> ; j &lt; i<span class="hljs-number">-1</span>; j++ {<br>current = current.Next<br>}<br>current.Next = current.Next.Next<br>}<br><br><span class="hljs-comment">// Remove 删除指定值节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LList)</span></span> Remove(data <span class="hljs-keyword">interface</span>{}) {<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br>l.Length--<br>}()<br>current := l.Header<br><span class="hljs-keyword">if</span> current.Data == data { <span class="hljs-comment">// 删除值恰好为第一个节点，把header指向第二个节点即可</span><br>l.Header = l.Header.Next<br><span class="hljs-keyword">return</span><br>}<br><span class="hljs-keyword">for</span> current.Next != <span class="hljs-literal">nil</span> {<br><span class="hljs-keyword">if</span> current.Next.Data == data {<br>current.Next = current.Next.Next<br>}<br>current = current.Next<br>}<br><span class="hljs-keyword">return</span><br>}<br><br><span class="hljs-comment">// GetListLength 获取链表长度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LList)</span></span> GetListLength() <span class="hljs-type">int</span> {<br>fmt.Printf(<span class="hljs-string">"当前链表长度：%d\n"</span>, l.Length)<br><span class="hljs-keyword">return</span> l.Length<br>}<br><br><span class="hljs-comment">// Scan 遍历链表，显示出来</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LList)</span></span> Scan() {<br>current := l.Header<br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> current.Next != <span class="hljs-literal">nil</span> {<br>fmt.Printf(<span class="hljs-string">"第%d的节点是%d\n"</span>, i, current.Data)<br>current = current.Next<br>i++<br>}<br>fmt.Printf(<span class="hljs-string">"第%d的节点是%d\n"</span>, i, current.Data)<br>}<br><br><span class="hljs-comment">// ShowList 打印链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LList)</span></span> ShowList() {<br><span class="hljs-comment">//打印链表</span><br><span class="hljs-keyword">if</span> l.Length == <span class="hljs-number">0</span> {<br>fmt.Println(<span class="hljs-string">"-&gt; 空链表!"</span>)<br><span class="hljs-keyword">return</span><br>}<br><br>current := l.Header<br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> current.Next != <span class="hljs-literal">nil</span> {<br>fmt.Printf(<span class="hljs-string">"%d -&gt; "</span>, current.Data)<br>current = current.Next<br>i++<br>}<br>fmt.Printf(<span class="hljs-string">"%d -&gt; "</span>, current.Data)<br>fmt.Println(<span class="hljs-string">""</span>)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>list := CreateList()<br>list.Add(<span class="hljs-number">100</span>)<br>list.Add(<span class="hljs-number">200</span>)<br>list.Add(<span class="hljs-number">400</span>)<br>list.Append(<span class="hljs-number">99</span>)<br>list.Insert(<span class="hljs-number">1</span>, <span class="hljs-number">300</span>)<br>list.Insert(<span class="hljs-number">5</span>, <span class="hljs-number">88</span>)<br>list.Insert(<span class="hljs-number">5</span>, <span class="hljs-number">90</span>)<br>list.ShowList()<br>list.GetListLength()<br><span class="hljs-comment">//list.Scan()</span><br><span class="hljs-comment">//list.Delete(6)</span><br>list.Remove(<span class="hljs-number">400</span>)<br><span class="hljs-comment">//list.Scan()</span><br>list.ShowList()<br>list.GetListLength()<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">400 -&gt; 300 -&gt; 200 -&gt; 100 -&gt; 99 -&gt; 90 -&gt; 88 -&gt;<br>当前链表长度：8<br>300 -&gt; 200 -&gt; 100 -&gt; 99 -&gt; 90 -&gt; 88 -&gt;<br>当前链表长度：7<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学基础</title>
      <link href="/posts/e403a46.html"/>
      <url>/posts/e403a46.html</url>
      
        <content type="html"><![CDATA[<p>学习数据结构，需要具备以下数学基础知识，这里只是简单提及一些公式和原理，具体的内容和深入学习请参考《高等数学》《离散数学》《数论》相关知识。</p><p><a name="zi9Lw"></a></p><h4 id="1-指数"><a href="#1-指数" class="headerlink" title="1.  指数"></a>1.  指数</h4><p>指数是幂运算aⁿ(a≠0)中的一个参数，a为底数，n为指数，指数位于底数的右上角，幂运算表示指数个底数相乘。<br>如43=4<em>4</em>4<br>一些基本的公式<br><img src="https://cdn.l2xy.com/post_img/math_img/one.png" alt="指数"><br><a name="lpRlP"></a></p><h4 id="2-对数"><a href="#2-对数" class="headerlink" title="2.  对数"></a>2.  对数</h4><p>在数学中，对数是对求幂的逆运算，正如除法是乘法的倒数，反之亦然。因此，对于公式，有且仅当<img src="https://cdn.l2xy.com/post_img/math_img/two.png"><br>一些基本的公式<br><img src="https://cdn.l2xy.com/post_img/math_img/six.png" alt="对数"><br><a name="N4G7y"></a></p><h4 id="3-级数"><a href="#3-级数" class="headerlink" title="3.  级数"></a>3.  级数</h4><p>级数是指将数列的项依次用加号连接起来的函数。我们使用∑（希腊语：Sigma，汉语：西格玛）符号进行表示，如<img src="https://cdn.l2xy.com/post_img/math_img/three.png" alt="级数"><br>级数理论是分析学的一个分支；它与另一个分支微积分学一起作为基础知识和工具出现在其余各分支中。二者共同以极限为基本工具，分别从离散与连续两个方面，结合起来研究分析学的对象，即变量之间的依赖关系──函数。<br>这里介绍一写简单而基本的公式：<br><img src="https://cdn.l2xy.com/post_img/math_img/four.png"></p><p>其他公式也都有一些相应得推导过程，这里只简单介绍。<br>此外，对于级数，还有“几何级数”的概念，其意思为N趋向于无穷，整个函数式会发生怎么样的改变，几何级数的使用，对于计算机计算程序的时空复杂度以及进行一些归纳方法非常有用。</p><p><a name="IdAmE"></a></p><h4 id="4-π运算"><a href="#4-π运算" class="headerlink" title="4. π运算"></a>4. π运算</h4><p>π（希腊语：pi，汉语：派）运算与∑符号的运算法则类似，由∑的加法变成了乘法，其代表“求乘积”，如<img src="https://cdn.l2xy.com/post_img/math_img/five.png" alt="π运算"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机体系</title>
      <link href="/posts/30268d74.html"/>
      <url>/posts/30268d74.html</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>CPU基础<br>CPU即处理器，是计算机中控制数据操控的电路。它主要由三部分构成：算术/逻辑单元、控制单元和寄存器单元。它们的作用分别为执行运算、协调机器活动以及临时存储。<br><img src="https://cdn.l2xy.com/post_img/computer_img/one.png" alt="cpu"></p><h2 id="CPU与主存"><a href="#CPU与主存" class="headerlink" title="CPU与主存"></a>CPU与主存</h2><p>CPU中的寄存器分为通用寄存器和专用寄存器，通用寄存器用于临时存放CPU正在使用的数据，而专用寄存器用于CPU专有用途，比如指令寄存器和程序计数器。CPU与主存的通过总线进行通信，CPU通过控制单元能够操作主存中的数据。<br>执行两个数值相加的过程大致为：从主存读取第一个值放到寄存器1-&gt;从主存读取第二个值放到寄存器2-&gt;两个寄存器保存的值作为输入送到加法电路-&gt;将加法结果保存到寄存器3-&gt;控制单元将结果放到主存中。<br><img src="https://cdn.l2xy.com/post_img/computer_img/two.png" alt="cpu与主存"></p><h2 id="程序等同数据"><a href="#程序等同数据" class="headerlink" title="程序等同数据"></a>程序等同数据</h2><p>原始的计算机并不像现代计算机一样将程序保存起来，以前的人们只对数据进行保存，而设备执行的步骤作为计算机的一部分而被内置在控制单元中。这样就很不灵活，最多只能通过重新布线来提升灵活性。将程序与数据视作相同本质是很大的思想突破，因为人们一直认为它们是不同的事物，数据应该存放在主存中而程序应该属于CPU的一部分。<br>将程序作为数据一样保存在主存中大有好处，控制单元能够从主存读取程序，然后对它们解码并执行。当我们要修改执行程序时可以在计算机的主存中修改，而不必对CPU更改或重新布线。</p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>程序包含了大量的机器指令，CPU对这些指令进行解码并执行。CPU分为两类体系：精简指令集计算机（RISC）和复杂指令集计算机(CISC)。RISC提供了最小的机器指令集，计算机效率高速度快且制造成本低。而CISC提供了强大丰富的指令集，能更方便实现复杂的软件。<br>机器指令分为三类：数据传输类、算术/逻辑类与控制类。<br>数据传输类指令用于将数据从一个地方移动到另一个地方。比如将主存单元的内容加载到寄存器的LOAD指令，反之将寄存器的内容保存到主存的STORE指令。此外，CPU与其它设备（键盘、鼠标、打印机、显示器、磁盘等）进行通信的指令被称为I/O指令。<br>算术/逻辑类指令用于让控制单元请求在算术/逻辑单元内执行运算。这些运算包括算术、与、或、异或和位移等。<br>控制类指令用于指导程序执行。比如转移（JUMP）指令，它包括无条件转移和条件转移。<br><img src="https://cdn.l2xy.com/post_img/computer_img/three.png" alt="指令格式"></p><h2 id="指令寄存器与程序计数器"><a href="#指令寄存器与程序计数器" class="headerlink" title="指令寄存器与程序计数器"></a>指令寄存器与程序计数器</h2><p>CPU将主存的指令加载进来解码并执行，其中涉及两个重要寄存器：指令寄存器与程序计数器。指令寄存器用于存储正在执行的指令，而程序计数器则保持下一个待执行的指令地址。<br>CPU向主存请求加载程序计数器指定的地址的指令，将其存放到指令寄存器中，加载后将程序计数器的值加2（假如指令长度为2个字节）。</p><h2 id="指令如何执行"><a href="#指令如何执行" class="headerlink" title="指令如何执行"></a>指令如何执行</h2><p>比如我们要计算11+22，假设过程为：将主存地址为00的内容加载到寄存器1中-&gt;将主存地址为01的内容加载到寄存器2中-&gt;将寄存器1和寄存器2的数据相加并将结果保存到寄存器3-&gt;将寄存器3的结果存储到主存地址为02的位置-&gt;停止。<br>这个过程CPU涉及到四个操作：加载(load)、存储(store)、加法(add)和停止(halt)。可以对这些操作进行编码，比如可以分别用1、2、3、0000表示。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1100<br>1201<br>3312<br>2302<br>0000<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.l2xy.com/post_img/computer_img/four.png" alt="指令执行"></p><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>CPU与其他设备的通信一般通过控制器来实现，控制器可能在主板上，也可能以电路板形式插到主板。控制器本身可以看成是小型计算机，也有自己简单的CPU。以前每连接一种外设都需要购买对应的控制器，而现在随着通用串行总线（USB）成为通用的标准，很多外设都可以直接用USB控制器作为通信接口。每个控制器都连接在总线上，通过总线进行通信。<br><img src="https://cdn.l2xy.com/post_img/computer_img/five.png" alt="cpu与控制器"><br>每个控制器可能被设计成对应一组地址引用，主存则会忽略这些地址引用。当CPU往这些地址上发送消息时，其实是直接穿过主存而到控制器的，操作的是控制器而非主存。这种模式称为存储映射输入/输出。此外，这种模式的另外一种实现可以在机器指令中提供特定的操作码，专门用于与控制器通信，这样的操作码称为I/O指令。</p><h2 id="直接存储器存取"><a href="#直接存储器存取" class="headerlink" title="直接存储器存取"></a>直接存储器存取</h2><p>直接存储器存取（DMA）是一种提升外设通信性能的措施，CPU并非总是需要使用总线，在总线空闲的时间里控制器能够充分利用起来。因为控制器都与总线相连接，而控制器又有执行指令的能力，所以可以将CPU的一些工作分给控制器来完成。比如在磁盘中检索数据时，CPU可以将告知控制器，然后由控制器找到数据并放到主存上，期间CPU可以去执行其他任务。这样能节省CPU资源。不过DMA会使总线通信更加复杂，而且会导致总线竞争问题。总线瓶颈源自冯诺依曼体系结构。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-搭建Jenkins服务</title>
      <link href="/posts/133182d1.html"/>
      <url>/posts/133182d1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>自动化部署（持续集成 / CI + 持续交付 / CD）不仅可以提升开发效率，让程序员更专注产品与业务的开发，还可以节省很多运维成本以及提升运维效率。其中，Jenkins 是自动化部署中最流行的工具，尤其是 Docker+Jenkins 的完美搭配，每个程序员都应该掌握这两个工具的使用。</p></blockquote><p><a name="a69f68"></a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">操作系统：CentOS Linux release <span class="hljs-number">7.6.1810</span><br>Docker 版本：<span class="hljs-number">19</span>.<span class="hljs-number">03</span>.<span class="hljs-number">5</span><br>Jenkins 版本：<span class="hljs-number">2.204.1</span><br></code></pre></td></tr></tbody></table></figure><p><a name="a4d756"></a></p><h2 id="Docker-安装-Jenkins"><a href="#Docker-安装-Jenkins" class="headerlink" title="Docker 安装 Jenkins"></a>Docker 安装 Jenkins</h2><p><a name="83df96"></a></p><h3 id="Docker-下载-Jenkins"><a href="#Docker-下载-Jenkins" class="headerlink" title="Docker 下载 Jenkins"></a>Docker 下载 Jenkins</h3><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker pull jenkins/jenkins:lts <span class="hljs-comment">//最新版</span><br></code></pre></td></tr></tbody></table></figure><p><a name="eb5ba1"></a></p><h3 id="查看-Jenkins-镜像"><a href="#查看-Jenkins-镜像" class="headerlink" title="查看 Jenkins 镜像"></a>查看 Jenkins 镜像</h3><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker images<br>docker <span class="hljs-keyword">inspect</span> jenkins镜像ID<br></code></pre></td></tr></tbody></table></figure><p><br><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/1.png"><br><a name="9e58ba"></a></p><h3 id="创建一个-Jenkins-目录"><a href="#创建一个-Jenkins-目录" class="headerlink" title="创建一个 Jenkins 目录"></a>创建一个 Jenkins 目录</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /data/jenkins_home;<br></code></pre></td></tr></tbody></table></figure><p><a name="00875a"></a></p><h3 id="安装启动-Jenkins-容器"><a href="#安装启动-Jenkins-容器" class="headerlink" title="安装启动 Jenkins 容器"></a>安装启动 Jenkins 容器</h3><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -d <span class="hljs-params">--name</span> jenkins -p 8081<span class="hljs-function">:8080</span> -v <span class="hljs-string">/data/jenkins_home</span>:<span class="hljs-string">/var/jenkins_home</span> jenkins/jenkins<span class="hljs-function">:lts</span>;<br>备注：<br>-d <span class="hljs-string">//</span>启动在后台<br><span class="hljs-params">--name</span> <span class="hljs-string">//</span>容器名字<br>-p <span class="hljs-string">//</span>端口映射（8081：宿主主机端口，8080：容器内部端口）<br>-v <span class="hljs-string">//</span>数据卷挂载映射（<span class="hljs-string">/data/jenkins_home</span>：宿主主机目录，另外一个即是容器目录）<br>enkins/jenkins<span class="hljs-function">:lts</span> <span class="hljs-string">//Jenkins</span>镜像（最新版）<br></code></pre></td></tr></tbody></table></figure><p><a name="8131cc"></a></p><h3 id="查看-Jenkins-启动情况"><a href="#查看-Jenkins-启动情况" class="headerlink" title="查看 Jenkins 启动情况"></a>查看 Jenkins 启动情况</h3><figure class="highlight docker"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker ps | grep jenkins;<br></code></pre></td></tr></tbody></table></figure><p><br><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/2.png"><br><a name="a577a3"></a></p><h3 id="安装过程遇到的小问题"><a href="#安装过程遇到的小问题" class="headerlink" title="安装过程遇到的小问题"></a>安装过程遇到的小问题</h3><p><a name="1ee354"></a></p><h4 id="Jenkins-容器-docker-run-之后状态总是-Exited"><a href="#Jenkins-容器-docker-run-之后状态总是-Exited" class="headerlink" title="Jenkins 容器 docker run 之后状态总是 Exited"></a>Jenkins 容器 docker run 之后状态总是 Exited</h4><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell">查看docker日志 ：<br><span class="hljs-title">docker</span> logs jenkins  <br>发现是目前权限问题<br>因为/<span class="hljs-class"><span class="hljs-keyword">data</span>/jenkins_home 目录是root权限</span><br></code></pre></td></tr></tbody></table></figure><p><br><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/3.png"></p><p><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/4.png"></p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">解决：<br><span class="hljs-symbol">chown</span> -R <span class="hljs-number">1000</span>:<span class="hljs-number">1000</span> /<span class="hljs-meta">data</span>/jenkins_home <span class="hljs-comment">//用户组改变</span><br></code></pre></td></tr></tbody></table></figure><p><br><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/5.png"><br><a name="650f74"></a></p><h4 id="宿主主机端口要开启"><a href="#宿主主机端口要开启" class="headerlink" title="宿主主机端口要开启"></a>宿主主机端口要开启</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">因为本操作是在阿里云ECS上进行安装的，需要在安全组里开放8081此端口。<br></code></pre></td></tr></tbody></table></figure><p><a name="1523e8"></a></p><h2 id="访问-Jenkins"><a href="#访问-Jenkins" class="headerlink" title="访问 Jenkins"></a>访问 Jenkins</h2><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">120.26</span>.<span class="hljs-number">50.165</span>:<span class="hljs-number">8081</span> <span class="hljs-regexp">//i</span>p:端口号<br></code></pre></td></tr></tbody></table></figure><p><a name="050d75"></a></p><h2 id="管理配置-Jenkins"><a href="#管理配置-Jenkins" class="headerlink" title="管理配置 Jenkins"></a>管理配置 Jenkins</h2><p><a name="fa7ffa"></a></p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">在安装完成后，默认生成了一个登录密码，首次登录需要这个密码。<br>密码路径：<span class="hljs-keyword">var</span><span class="hljs-regexp">/jenkins_home/</span>secrets<span class="hljs-regexp">/initialAdminPassword /</span>/容器内部<br>查找密码：<br>docker exec -it jenkins_01 bash <span class="hljs-comment">//进入jenkins容器</span><br>cat <span class="hljs-regexp">/var/</span>jenkins_home<span class="hljs-regexp">/secrets/</span>initialAdminPassword <span class="hljs-comment">//查看密码</span><br></code></pre></td></tr></tbody></table></figure><p><br><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/6.png"><br><a name="49c24a"></a></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">新手安装建议选择：<span class="hljs-keyword">Install</span> suggested plugins，安装过程大概半个多小时。<br></code></pre></td></tr></tbody></table></figure><p><br><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/7.png"></p><p><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/8.png"><br><a name="451e79"></a></p><h3 id="管理用户创建"><a href="#管理用户创建" class="headerlink" title="管理用户创建"></a>管理用户创建</h3><figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">这个用户就是最大管理者权限，相当于<span class="hljs-literal">admin</span><br></code></pre></td></tr></tbody></table></figure><p><br><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/9.png"><br><a name="a68c5d"></a></p><h2 id="Jenkins-配置完成"><a href="#Jenkins-配置完成" class="headerlink" title="Jenkins 配置完成"></a>Jenkins 配置完成</h2><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">到此步，安装就大功告成！<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">120.26</span>.<span class="hljs-number">50.165</span>:<span class="hljs-number">8081</span> <span class="hljs-regexp">//i</span>p:端口号<br></code></pre></td></tr></tbody></table></figure><p><br><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/10.png"></p><p><img src="https://cdn.l2xy.com/post_img/docker_jenkins_img/11.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常见命令</title>
      <link href="/posts/59b529b7.html"/>
      <url>/posts/59b529b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker-常见命令"><a href="#docker-常见命令" class="headerlink" title="docker 常见命令"></a>docker 常见命令</h1><ul><li>查看版本</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker -v<br></code></pre></td></tr></tbody></table></figure><ul><li>查看详细版本</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></tbody></table></figure><ul><li>查看 docker 基本信息</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker info<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="镜像相关的命令"><a href="#镜像相关的命令" class="headerlink" title="镜像相关的命令"></a>镜像相关的命令</h2><p>镜像仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com</a></p><ul><li>查看本地已经安装的镜像</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></tbody></table></figure><ul><li>搜索指定镜像</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search &lt;image-name&gt;<br><br><span class="hljs-comment"># 比如搜索 centos 镜像</span><br>docker search centos<br></code></pre></td></tr></tbody></table></figure><ul><li>拉取镜像</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull &lt;image-name&gt;<br><br><span class="hljs-comment"># 比如拉取 centos 镜像（将会拉取最新版本的镜像，即 latest 版本）</span><br>docker pull centos<br><br><span class="hljs-comment"># 拉取指定版本的镜像</span><br>docker pull ubuntu:16.04<br></code></pre></td></tr></tbody></table></figure><ul><li>删除镜像</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi &lt;image-name&gt;<br><br><span class="hljs-comment"># 比如删除 centos 镜像</span><br>docker rmi centos<br></code></pre></td></tr></tbody></table></figure><ul><li>删除所有的镜像</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi $(docker images -q)<br><br><span class="hljs-comment"># 查看所有镜像的镜像 id</span><br>docker images -q<br></code></pre></td></tr></tbody></table></figure><ul><li>更新镜像</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新镜像前，需要使用镜像创建一个容器</span><br>docker run -it ubuntu:15.10 bash<br><br><span class="hljs-comment"># 在运行的容器内部使用 apt-get update 更新</span><br><br><span class="hljs-comment"># 更新完毕之后，输入 exit 命令退出容器</span><br><br><span class="hljs-comment"># 使用 docker commit 来提交容器副本</span><br>docker commit -m=<span class="hljs-string">"has update"</span> -a=<span class="hljs-string">"alex"</span> e218edb10161 alex/ubuntu:v2<br><span class="hljs-comment"># -m 表示提交的描述信息</span><br><span class="hljs-comment"># -a 表示提交的镜像作者</span><br><span class="hljs-comment"># e218edb10161 表示容器的 id</span><br><span class="hljs-comment"># alex/ubuntu:v2 表示指定要创建的目标镜像名</span><br><br><span class="hljs-comment"># 查看新的镜像</span><br>docker images<br><br><span class="hljs-comment"># 使用新镜像 alex/ubuntu:v2 来启动一个容器</span><br>docker run -it alex/ubuntu:v2 bash<br></code></pre></td></tr></tbody></table></figure><ul><li>构建镜像</li></ul><ol><li>vim  ~/glory/codes/book/demo/Dockerfile 填充以下内容，构建一个 centos 8 系统</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br><span class="hljs-comment"># 指定使用哪个镜像源</span><br>FROM centos:8<br><br><span class="hljs-comment"># 如果写了 3 次 RUN 那么将会在 docker 上新建 3 层，会导致镜像膨胀过大，下面这种方式只会创建 1 层镜像</span><br>RUN /bin/echo <span class="hljs-string">'root:123456'</span> | chpasswd; \<br>useradd alex; \<br>/bin/echo <span class="hljs-string">'alex:123456'</span> | chpasswd; \<br>/bin/echo -e <span class="hljs-string">"LANG=\"en_US.UTF-8\""</span> &gt; /etc/default/local<br><br>EXPOSE 22<br>EXPOSE 80<br>CMD /usr/sbin/sshd -D<br><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>开始构建镜像，注意不要在 <code>~/glory/codes/book/demo</code> 目录下放无用的文件，因为会打包所有该目录下的文件然后发送给 docker 引擎，如果文件过多会造成 build 过程缓慢</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># -t 表示指定要创建的目标镜像名</span><br><span class="hljs-comment"># ~/glory/codes/book/demo 表示 Dockerfile 文件所在的目录</span><br>docker build -t alex/centos:8.0 ~/glory/codes/book/demo<br><br><span class="hljs-comment"># 查看已经构建好的镜像信息</span><br>docker images<br><br><span class="hljs-comment"># 使用新的镜像来创建新容器</span><br>docker run -it alex/centos:8.0 bash<br></code></pre></td></tr></tbody></table></figure><ul><li>设置镜像标签</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先查看镜像</span><br>$ docker images                                                                   <br><br>REPOSITORY            TAG                       IMAGE ID       CREATED          SIZE<br>alex/centos           8.0                       594ab4747ed4   14 minutes ago   210MB<br><br><span class="hljs-comment"># 设置镜像标签</span><br>$ docker tag 594ab4747ed4 alex1/centos1:8.1.1<br><br><span class="hljs-comment"># 再次查看镜像信息会多一个标签</span><br>$ docker images<br><br>REPOSITORY            TAG                       IMAGE ID       CREATED          SIZE<br>alex/centos           8.0                       594ab4747ed4   14 minutes ago   210MB<br>alex1/centos1         8.1.1                     594ab4747ed4   14 minutes ago   210MB<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="容器相关的命令"><a href="#容器相关的命令" class="headerlink" title="容器相关的命令"></a>容器相关的命令</h2><ul><li>查看容器的系统版本信息</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入容器后执行</span><br><span class="hljs-built_in">cat</span> /proc/version<br><span class="hljs-comment"># 比如会输出以下内容</span><br>Linux version 4.19.121-linuxkit (root@18b3f92ade35) (gcc version 9.2.0 (Alpine 9.2.0)) <span class="hljs-comment">#1 SMP Thu Jan 21 15:36:34 UTC 2021</span><br></code></pre></td></tr></tbody></table></figure><ul><li>查看所有的容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a<br><br><span class="hljs-comment"># 或者使用以下命令，是一样的效果</span><br>docker container <span class="hljs-built_in">ls</span> -a<br><br><span class="hljs-comment"># 查看最后一次创建的容器</span><br>docker ps -l<br></code></pre></td></tr></tbody></table></figure><ul><li>查看所有已经运行的容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></tbody></table></figure><ul><li>查看容器端口映射</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker port &lt;container-name or container-id&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>查看 docker 底层信息（比如：查看指定容器的 ip 地址）</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 docker 容器的配置和状态信息</span><br>docker inspect &lt;container-name or container-id&gt; <br><br><span class="hljs-comment"># 查看容器的 ip 地址</span><br>docker inspect &lt;container-name or container-id&gt; | grep IPAddress<br><br><span class="hljs-comment"># 比如查看容器 id 为 66204be9fe65 的容器所对应的 ip 地址</span><br>docker inspect 66204be9fe65 | grep IPAddress<br><br><span class="hljs-comment"># 比如查看容器名称为 alex 所对应的 ip 地址</span><br>docker inspect alex | grep IPAddress<br></code></pre></td></tr></tbody></table></figure><ul><li>创建容器并把镜像恢复到容器当中，且启动容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run [-i][-t][-v][--name][-d][-p]<br><br><span class="hljs-comment"># -i 表示 interactive 交互式</span><br><span class="hljs-comment"># -t 表示得到一个 terminal</span><br><span class="hljs-comment"># --name 表示修改容器名称</span><br><span class="hljs-comment"># -d 表示以守护进程的方式运行（默认不会进入容器，想要进入容器则需要使用 docker exec 命令）</span><br><span class="hljs-comment"># -p 表示 **指定** 映射端口</span><br><span class="hljs-comment"># -P （大写的字母 p ） 表示 **随机** 映射端口</span><br><span class="hljs-comment"># /bin/bash 和 bash 等效</span><br>docker run -it &lt;image-name&gt; /bin/bash<br><br><span class="hljs-comment"># 比如创建一个新容器并且进入 ubuntu:16.04 镜像</span><br>docker run -it ubuntu:16.04 bash<br><span class="hljs-comment"># 或者</span><br>docker run -it ubuntu:16.04 /bin/bash<br><span class="hljs-comment"># 或者</span><br>docker run -it ubuntu:16.04<br><br><span class="hljs-comment"># 以 centos 镜像创建一个新容器，并修改新容器名称为 alex-container</span><br>docker run -it --name alex-container centos bash  <br><br><span class="hljs-comment"># 以守护进程的方式运行 （后台运行）</span><br>docker run -d --name alex-container centos  <br><span class="hljs-comment"># 或者</span><br>docker run -di --name alex-container centos<br><br><span class="hljs-comment"># 指定容器绑定的网络地址，这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口（默认绑定的都是 tcp 端口）</span><br>docker run -d -p 127.0.0.1:5001:5000 centos:8.0 bash<br><span class="hljs-comment"># 如果需要绑定 udp 端口，则</span><br><span class="hljs-comment"># （还可以进入容器就直接执行 python app.py 命令）</span><br>docker run -d -p 127.0.0.1:5001:5000/udp centos:8.0 python app.py<br><br><span class="hljs-comment"># 比如，安装 hyperf 镜像并启动容器</span><br><span class="hljs-comment"># 如果 docker 启动时开启了 selinux-enabled 选项，容器内访问宿主机资源就会受限，所以启动容器时可以增加 --privileged -u root 选项</span><br>docker run --name hyperf \<br>-v /workspace/skeleton:/data/project \<br>-p 9501:9501 -it \<br>--privileged -u root \<br>--entrypoint /bin/sh \<br>hyperf/hyperf:7.4-alpine-v3.11-swoole<br><br><span class="hljs-comment"># 如果需要开通多个端口时，可以参考</span><br>docker run --name api_dfo_hyperf_ws \<br>-v /Users/pudongping/glory/codes/dfo/api_dfo_hyperf:/api_dfo_hyperf \<br>-p 9502:9502 \<br>-p 9503:9503 \<br>-p 9504:9504 \<br>-p 9505:9505 -it \<br>--entrypoint /bin/sh \<br>alex/alex_api_dfo:v1.0<br><br></code></pre></td></tr></tbody></table></figure><ul><li>启动容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start &lt;container-name or container-id&gt;<br><br><span class="hljs-comment"># 比如启动容器名称为 redis-alex 的容器</span><br>docker start redis-alex<br><span class="hljs-comment"># 比如启动容器 id 为 c8c0c770ac5b 的容器</span><br>docker start c8c0c770ac5b<br></code></pre></td></tr></tbody></table></figure><ul><li>直接进入已经创建的容器（不会启动容器）</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start -i &lt;container-name or container-id&gt;<br><br><span class="hljs-comment"># 比如进入容器 id 为 66204be9fe65 的容器</span><br>docker start -i 66204be9fe65<br><span class="hljs-comment"># 比如进入容器名称为 alex 的容器</span><br>docker start -i alex<br></code></pre></td></tr></tbody></table></figure><ul><li>重启容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart &lt;container-name or container-id&gt;<br><br><span class="hljs-comment"># 比如重启容器名称为 redis-alex 的容器</span><br>docker restart redis-alex<br><span class="hljs-comment"># 比如重启容器 id 为 c8c0c770ac5b 的容器</span><br>docker restart c8c0c770ac5b<br></code></pre></td></tr></tbody></table></figure><ul><li>进入已经运行中的容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it &lt;container-name or container-id&gt; bash<br><br><span class="hljs-comment"># 比如进入容器名称为 redis-alex 的容器</span><br>docker <span class="hljs-built_in">exec</span> -it redis-alex bash<br><span class="hljs-comment"># 比如进入容器 id 为 c8c0c770ac5b 的容器</span><br>docker <span class="hljs-built_in">exec</span> -it c8c0c770ac5b bash<br><br><span class="hljs-comment"># 进入容器之后执行 shell 命令或者执行 shell 脚本</span><br>docker <span class="hljs-built_in">exec</span> -it  &lt;container-name or container-id&gt; /bin/sh -c <span class="hljs-string">"while true; do echo hello world; sleep 1; done"</span><br><span class="hljs-comment"># 比如进入容器 id 为 c8c0c770ac5b 的容器，并且进入容器后执行 `bash /portal_api_dfo_hyperf/server.sh restart` 脚本</span><br>docker <span class="hljs-built_in">exec</span> -it c8c0c770ac5b /bin/sh -c <span class="hljs-string">"bash /portal_api_dfo_hyperf/server.sh restart"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>停止容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop &lt;container-name or container-id&gt;<br><br><span class="hljs-comment"># 比如停止容器名称为 redis-alex 的容器</span><br>docker stop redis-alex<br><span class="hljs-comment"># 比如停止容器 id 为 c8c0c770ac5b 的容器</span><br>docker stop c8c0c770ac5b<br></code></pre></td></tr></tbody></table></figure><ul><li>退出容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></tbody></table></figure><ul><li>删除容器</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> &lt;container-name or container-id&gt;<br><span class="hljs-comment"># 也可以加入 -f 参数，强制移除正在运行中的容器</span><br>docker <span class="hljs-built_in">rm</span> -f 1e560fca3906<br><span class="hljs-comment"># 清理掉所有处于终止状态的容器</span><br>docker container prune<br></code></pre></td></tr></tbody></table></figure><ul><li>修改容器名称</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rename &lt;container-name or container-id&gt; &lt;new-container-name&gt;<br><br><span class="hljs-comment"># 比如将容器 redis-alex 改名为 redis-tt</span><br>docker rename redis-alex redis-tt<br></code></pre></td></tr></tbody></table></figure><ul><li>查看容器的标准输出</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs &lt;container-name or container-id&gt;<br><br><span class="hljs-comment"># 比如查看容器 id 为 c8c0c770ac5b 的容器标准输出内容</span><br>docker logs c8c0c770ac5b<br><span class="hljs-comment"># 也可以加入 -f 参数，像使用 tail -f 一样来输出容器内部的标准输出</span><br>docker logs -f c8c0c770ac5b<br></code></pre></td></tr></tbody></table></figure><h2 id="容器与宿主机之间的文件或者目录拷贝"><a href="#容器与宿主机之间的文件或者目录拷贝" class="headerlink" title="容器与宿主机之间的文件或者目录拷贝"></a>容器与宿主机之间的文件或者目录拷贝</h2><ul><li>从宿主机拷贝文件到容器中</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> &lt;local-directory-or-file&gt; &lt;container-name&gt;:&lt;container-directory-or-file&gt;<br><br><span class="hljs-comment"># 比如将宿主机中的 /home/alex/test.txt 文件拷贝到 centos1 容器中的 /test.txt</span><br>docker <span class="hljs-built_in">cp</span> /home/alex/test.txt centos1:/test.txt<br></code></pre></td></tr></tbody></table></figure><ul><li>从容器拷贝到宿主机中</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> &lt;container-name&gt;:&lt;container-directory-or-file&gt; &lt;local-directory&gt;<br><br><span class="hljs-comment"># 比如将 centos1 容器中的 /test 目录拷贝到宿主机的 /home/alex 目录下</span><br>docker <span class="hljs-built_in">cp</span> centos1:/test /home/alex<br></code></pre></td></tr></tbody></table></figure><h2 id="目录挂载（创建容器的时候就需要进行目录挂载）"><a href="#目录挂载（创建容器的时候就需要进行目录挂载）" class="headerlink" title="目录挂载（创建容器的时候就需要进行目录挂载）"></a>目录挂载（创建容器的时候就需要进行目录挂载）</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -di -v &lt;local-directory&gt;:&lt;container-directory&gt; &lt;image-name&gt;<br><br><span class="hljs-comment"># 在 windows 下挂载（注意路径的书写方式）</span><br><span class="hljs-comment"># 比如以 centos 镜像创建一个容器，并将本地 D 盘中的 alex 目录，挂载到容器中的 /usr/local/demo 目录</span><br>docker run -di -v d:\alex:/usr/local/demo centos<br><br><span class="hljs-comment"># 在 linux 下挂载</span><br><span class="hljs-comment"># 比如以 centos 镜像创建一个容器，并将本地的 /home/alex/alex 目录，挂载到容器中的 /usr/local/demo 目录</span><br>docker run -di -v /home/alex/alex:/usr/local/demo centos<br></code></pre></td></tr></tbody></table></figure><h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><ul><li>导出容器快照</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> &lt;container-id&gt; &gt; &lt;your-backup-name.tar&gt;<br><br><span class="hljs-comment"># 比如将容器 id 为 7691a814370e 的容器导出快照为 alex.tar</span><br>docker <span class="hljs-built_in">export</span> 7691a814370e &gt; alex.tar<br></code></pre></td></tr></tbody></table></figure><ul><li>导入容器快照</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;your-backup-name.tar&gt; | docker import - &lt;image-author-name&gt;/&lt;your-new-image-name&gt;:&lt;your-new-image-version&gt;<br><br><span class="hljs-comment"># 比如将容器快照文件 alex.tar 导入到 alex-demo 镜像并定义 alex-demo 镜像的作者为 alex，版本号为 v1.0</span><br><span class="hljs-built_in">cat</span> alex.tar | docker import - alex/alex-demo:v1.0<br><span class="hljs-comment"># 此外，也可以通过指定 url 或者某个目录来导入</span><br>docker import http://example.com/example-image.tgz example/image-repo:v1.0<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 环境搭建</title>
      <link href="/posts/a8b7793d.html"/>
      <url>/posts/a8b7793d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-环境搭建"><a href="#Docker-环境搭建" class="headerlink" title="Docker 环境搭建"></a>Docker 环境搭建</h1><h2 id="适用于-Ubuntu，Debian，Centos-等大部分-Linux（使用官方安装脚本自动安装）"><a href="#适用于-Ubuntu，Debian，Centos-等大部分-Linux（使用官方安装脚本自动安装）" class="headerlink" title="适用于 Ubuntu，Debian，Centos 等大部分 Linux（使用官方安装脚本自动安装）"></a>适用于 Ubuntu，Debian，Centos 等大部分 Linux（使用官方安装脚本自动安装）</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -sSL https://get.daocloud.io/docker | sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者执行</span><br><br>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br></code></pre></td></tr></tbody></table></figure><h2 id="Windows-10-系统上如果不想用-docker-则需要关闭-hyper"><a href="#Windows-10-系统上如果不想用-docker-则需要关闭-hyper" class="headerlink" title="Windows 10 系统上如果不想用 docker 则需要关闭 hyper"></a>Windows 10 系统上如果不想用 docker 则需要关闭 hyper</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmd 命令行执行： bcdedit /set hypervisorlaunchtype off<br><br>poweroff 命令行执行： Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V<br></code></pre></td></tr></tbody></table></figure><h4 id="关于报错"><a href="#关于报错" class="headerlink" title="关于报错"></a>关于报错</h4><ul><li>container-selinux &gt;= 2.9 解决方案</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Error: Package: docker-ce-18.03.1.ce-1.el7.centos.x86_64 (docker-ce-edge)<br>           Requires: container-selinux &gt;= 2.9<br> You could try using --skip-broken to work around the problem<br> You could try running: rpm -Va --nofiles --nodigest<br></code></pre></td></tr></tbody></table></figure><blockquote><p>这个报错是 container-selinux 版本低或者是没安装的原因<br>yum 安装 container-selinux 一般的 yum 源又找不到这个包<br>需要安装 epel 源，才能 yum 安装 container-selinux<br>然后在安装 docker-ce 就可以了。</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先配置阿里云的 yum 源</span><br>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装阿里云上的 epel 源</span><br>yum install epel-release<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 container-selinux 即可</span><br>yum install container-selinux<br></code></pre></td></tr></tbody></table></figure><h3 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前 docker 版本号，出现版本号即为安装成功</span><br>docker -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看详细的 docker 信息</span><br>docker version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前 docker 的信息</span><br>docker info<br><br></code></pre></td></tr></tbody></table></figure><h3 id="开启-docker-守护进程"><a href="#开启-docker-守护进程" class="headerlink" title="开启 docker 守护进程"></a>开启 docker 守护进程</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br>systemctl enable docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重载配置</span><br>systemctl daemon-reload<br></code></pre></td></tr></tbody></table></figure><h3 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h3><p>centos 或者 ubuntu 系统时</p><p>sudo vim /etc/docker/daemon.json</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"registry-mirrors"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"https://registry.docker-cn.com"</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><h3 id="docker-国内镜像"><a href="#docker-国内镜像" class="headerlink" title="docker 国内镜像"></a>docker 国内镜像</h3><ul><li>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></li><li>官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li><li>ustc 的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li></ul><h3 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用源码安装（推荐方式）</span><br>[最新发行的版本地址](https://github.com/docker/compose/releases)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 1.27.4 版本的 docker-compose （下载了源码，并改名为 docker-compose）</span><br>sudo curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">增加执行权限</span><br>sudo chmod u+x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立软连接到 /usr/bin 目录</span><br>sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 docker-compose 版本</span><br>docker-compose version<br><br>---------------------------------<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果是在 centos 系统中</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装扩展源</span><br>sudo yum -y install epel-release<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 python-pip 模块</span><br>sudo yum -y install python-pip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果是在 ubuntu 系统中</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 python-pip 模块</span><br>apt install python-pip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 pip 安装 docker-compose</span><br>pip install docker-compose<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除掉旧的环境变量 docker-compose</span><br>sudo rm /usr/bin/docker-compose<br>sudo rm /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者使用 pip 命令卸载 docker-compose</span><br>pip uninstall docker-compose<br></code></pre></td></tr></tbody></table></figure><h3 id="安装-redis"><a href="#安装-redis" class="headerlink" title="安装 redis"></a>安装 redis</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis:latest<br><br>docker images<br><br>docker run -itd --name alex-redis -p 6379:6379 redis<br><br>docker exec -it alex-redis /bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">外部可以直接通过宿主机ip:6379 访问到 redis 服务</span><br></code></pre></td></tr></tbody></table></figure><h3 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql:5.7.33<br><br>docker images<br><br>docker run -itd --name alex-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.32<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker 容器中可以使用 localhost 或者 127.0.0.1 均可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">外部可以直接通过宿主机ip:3306 访问到 mysql 服务，密码为 123456</span><br><br>------------<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 mysql 8 时</span><br>docker pull mysql:8.0.23<br>docker run -itd --name alex-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0.23<br>docker exec -it alex-mysql bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录 mysql</span><br>mysql -u root -p<br>alter user 'root'@'localhost' identified by '123456';<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加远程登录用户</span><br>create user 'root'@'%' identified with mysql_native_password by '123456';<br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新权限</span><br>grant all privileges on *.* to 'root'@'%';<br><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Supervisor 进程管理工具使用</title>
      <link href="/posts/21919295.html"/>
      <url>/posts/21919295.html</url>
      
        <content type="html"><![CDATA[<h1 id="Supervisor-进程管理工具使用"><a href="#Supervisor-进程管理工具使用" class="headerlink" title="Supervisor 进程管理工具使用"></a>Supervisor 进程管理工具使用</h1><ul><li><a href="https://pypi.org/project/supervisor/">pypi 插件链接地址</a></li><li><a href="http://supervisord.org/">官方文档地址</a></li><li><a href="https://www.jianshu.com/p/3658c963d28b">supervisor 从安装到使用</a></li></ul><blockquote><p>php artisan horizon 和 php artisan queue:work 命令一样，都可以正常处理异步任务<br>php artisan horizon:terminate =&gt; Horizon 进程会等待当前正在执行的任务执行完毕，然后再退出进程。</p></blockquote><h2 id="在阿里云-CentOS-7-6-上"><a href="#在阿里云-CentOS-7-6-上" class="headerlink" title="在阿里云 CentOS 7.6 上"></a>在阿里云 CentOS 7.6 上</h2><ul><li>安装 supervisor</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y supervisor<br></code></pre></td></tr></tbody></table></figure><ul><li>查看主配置信息 <code>supervisord.conf</code> 留意 <code>include</code> 选项</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /etc/supervisord.conf<br><br><span class="hljs-comment"># 这里决定了你所需要写的进程配置文件格式，这里是 ini ，因此我们也必须写成 ini 后缀的文件</span><br>[include]<br>files = supervisord.d/*.ini<br><br></code></pre></td></tr></tbody></table></figure><ul><li>添加自定义进程配置信息</li></ul><p>vim /etc/supervisord.d/larablog.ini</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br>[program:larablog-horizon]<br>process_name=%(program_name)s<br><span class="hljs-built_in">command</span>=php /www/wwwroot/larablog/artisan horizon<br>autostart=<span class="hljs-literal">true</span><br>autorestart=<span class="hljs-literal">true</span><br>user=www<br>redirect_stderr=<span class="hljs-literal">true</span><br>stdout_logfile=/www/wwwroot/larablog/storage/logs/worker.log<br><br></code></pre></td></tr></tbody></table></figure><ul><li>program:larablog-horizon 代表这个配置的名称是 larablog-horizon；</li><li>process_name= 代表这个进程在 Supervisor 内部的命名；</li><li>command= 代表要执行的命令；</li><li>autostart=true 代表这个进程跟随 Supervisor，只要 Supervisor 启动了，就启动这个进程；</li><li>autorestart=true 代表要求 Supervisor 监听进程状态，假如异常退出就再次启动，重启次数默认有 3 次限制；</li><li>user=www 代表以 www 身份启动进程；</li><li>redirect_stderr=true 代表输出错误信息；</li><li>stdout_logfile= 代表将进程的输出保存到日志文件中。</li></ul><ul><li>更新配置</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo supervisorctl update<br></code></pre></td></tr></tbody></table></figure><p>如果遇到报错 <code>error: &lt;class 'socket.error'&gt;, [Errno 2] No such file or directory: file: /usr/lib64/python2.7/socket.py line: 224</code> 则执行以下命令</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo supervisord -c /etc/supervisord.conf<br><br><span class="hljs-comment"># 再次尝试执行重载配置命令</span><br>sudo supervisorctl update<br><br>sudo supervisorctl -c /etc/supervisord.conf<br></code></pre></td></tr></tbody></table></figure><ul><li>查看进程状态</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo supervisorctl status<br></code></pre></td></tr></tbody></table></figure><h2 id="在-ubuntu-上"><a href="#在-ubuntu-上" class="headerlink" title="在 ubuntu 上"></a>在 ubuntu 上</h2><ul><li>安装 supervisor</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install supervisor<br></code></pre></td></tr></tbody></table></figure><ul><li>添加自定义进程配置信息</li></ul><p>vim /etc/supervisor/conf.d/larablog.conf</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br>[program:larablog-horizon]<br>process_name=%(program_name)s<br><span class="hljs-built_in">command</span>=php /www/wwwroot/larablog/artisan horizon<br>autostart=<span class="hljs-literal">true</span><br>autorestart=<span class="hljs-literal">true</span><br>user=www<br>redirect_stderr=<span class="hljs-literal">true</span><br>stdout_logfile=/www/wwwroot/larablog/storage/logs/worker.log<br><br></code></pre></td></tr></tbody></table></figure><ul><li>更新配置</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo supervisorctl update<br></code></pre></td></tr></tbody></table></figure><ul><li>检查是否正常运行</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo supervisorctl status<br></code></pre></td></tr></tbody></table></figure><ul><li>单独启动一个指定名称的进程</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo supervisorctl start &lt;process-name&gt;<br><br><span class="hljs-comment"># 比如启动名称为 larablog-horizon 的进程</span><br>sudo supervisorctl start larablog-horizon<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervisor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚簇索引和非聚簇索引</title>
      <link href="/posts/f71a6538.html"/>
      <url>/posts/f71a6538.html</url>
      
        <content type="html"><![CDATA[<h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><p><a name="roRRs"></a></p><h2 id="1-聚簇索引-主键索引"><a href="#1-聚簇索引-主键索引" class="headerlink" title="1. 聚簇索引(主键索引)"></a>1. 聚簇索引(主键索引)</h2><p>InnoDB会自动为主键id创建一棵名为主键索引（又叫做聚簇索引）的B+树，这个B+树的最重要的特点就是叶子节点包含了完整的用户记录，大概长这个样子。<br><img src="https://cdn.l2xy.com/post_img/mysql_img/clustered_one.webp"><br>主键索引的B+树的每一个节点内的记录都是按照主键值由小到大的顺序，采用单向链表的方式进行连接的。</p><p><a name="wgzX5"></a></p><h2 id="2-非聚簇索引-非主键索引、二级索引"><a href="#2-非聚簇索引-非主键索引、二级索引" class="headerlink" title="2. 非聚簇索引(非主键索引、二级索引)"></a>2. 非聚簇索引(非主键索引、二级索引)</h2><p><img src="https://cdn.l2xy.com/post_img/mysql_img/clustered_two.webp"><br>InnoDB存储引擎会根据搜索条件在该二级索引的叶子节点中找到name为蝉沐风的记录，但是二级索引中只记录了name、phone和主键id字段（谁让我们用的是SELECT *呢），因此InnoDB需要拿着主键id去主键索引中查找这一条完整的记录，这个过程叫做<strong>回表</strong>。<br>想一下，如果二级索引的叶子节点上有我们想要的所有数据，是不是就不需要回表了呢？是的，这就是<strong>覆盖索引</strong>。</p><p><img src="https://cdn.l2xy.com/post_img/mysql_img/clustered_three.png"></p><p><a name="R0YvY"></a></p><h2 id="3-什么是回表"><a href="#3-什么是回表" class="headerlink" title="3. 什么是回表"></a>3. 什么是回表</h2><p>我们可以通过二级索引找到B+树中的叶子结点，但是二级索引的叶子节点的内容并不全，只有索引列的值和主键值。我们需要拿着主键值再去聚簇索引（主键索引）的叶子节点中去拿到完整的用户记录，这个过程叫做回表。<br><img src="https://cdn.l2xy.com/post_img/mysql_img/clustered_four.png"><br><a name="jgxcB"></a></p><h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><p>我们根据name字段查找二级索引的叶子节点的代价还是比较小的，原因有二：</p><ol><li>叶子节点所在的页通过双向链表进行关联，遍历的速度比较快；</li><li>MySQL会尽量让同一个索引的叶子节点的数据页在磁盘空间中相邻，尽力避免随机IO。</li></ol><p>但是二级索引叶子节点中的主键id的排布就没有任何规律了，毕竟name索引是对name字段进行排序的。进行回表的时候，极有可能出现主键id所在的记录在聚簇索引叶子节点中反复横跳的情况（正如上图中回表的3条线表示的那样），也就是随机IO。如果目标数据页恰好在内存中的话效果倒也不会太差，但如果不在内存中，还要从磁盘中加载一个数据页的内容（16KB）到内存中，这个速度可就太慢了。<br>是不是说完了回表的代价之后，我会给出一种更高效的搜索方式？不是，回表已经是一种比较高效的搜索方式了，我们需要做的就是尽量地减少回表操作带来的损耗，总结起来就是两点：</p><ol><li>能不回表就不回；</li><li>必须回表就减少回表的次数。</li></ol><p><a name="LIeUb"></a></p><h2 id="4-索引覆盖、索引下推"><a href="#4-索引覆盖、索引下推" class="headerlink" title="4. 索引覆盖、索引下推"></a>4. 索引覆盖、索引下推</h2><p><a name="Ggk4v"></a></p><h3 id="4-1-索引覆盖"><a href="#4-1-索引覆盖" class="headerlink" title="4.1 索引覆盖"></a>4.1 索引覆盖</h3><p>想一下，如果非聚簇索引的叶子节点上有你想要的所有数据，是不是就不需要回表了呢？比如我为name和phone字段创建了一个联合索引，如下图：<br><img src="https://cdn.l2xy.com/post_img/mysql_img/clustered_five.webp"><br>如果我们恰好只想搜索name、phone以及主键字段，<br>SELECT id, name,  phone FROM user_innodb WHERE name = “蝉沐风”; 复制代码<br>可以直接从叶子节点获取所有数据，根本不需要回表操作。<br>我们把索引中已经包含了所有需要读取的列数据的查询方式称为<strong>覆盖索引</strong>（或<strong>索引覆盖</strong>）。<br><a name="lfWnU"></a></p><h3 id="4-2-索引下推"><a href="#4-2-索引下推" class="headerlink" title="4.2 索引下推"></a>4.2 索引下推</h3><p><a name="L3Ql4"></a></p><h4 id="4-2-1-概念"><a href="#4-2-1-概念" class="headerlink" title="4.2.1 概念"></a>4.2.1 概念</h4><p>还是拿name和phone的联合索引为例，我们要查询所有name为「蝉沐风」，并且手机尾号为6606的记录，查询SQL如下：<br>SELECT * FROM user_innodb WHERE name = “蝉沐风” AND phone LIKE “%6606”; 复制代码<br>由于联合索引的叶子节点的记录是先按照name字段排序，name字段相同的情况下再按照phone字段排序，因此把%加在phone字段前面的时候，是无法利用索引的顺序性来进行快速比较的，也就是说这条查询语句中只有name字段可以使用索引进行快速比较和过滤。正常情况下查询过程是这个样子的：</p><ol><li>InnoDB使用联合索引查出所有name为蝉沐风的二级索引数据，得到3个主键值：3485，78921，423476；</li><li>拿到主键索引进行回表，到聚簇索引中拿到这三条完整的用户记录；</li><li>InnoDB把这3条完整的用户记录返回给MySQL的Server层，在Server层过滤出尾号为6606的用户。</li></ol><p>如下面两幅图所示，第一幅图表示InnoDB通过3次回表拿到3条完整的用户记录，交给Server层；第二幅图表示Server层经过phone LIKE “%6606”条件的过滤之后找到符合搜索条件的记录，返给客户端。<br><img src="https://cdn.l2xy.com/post_img/mysql_img/clustered_six.webp"><br><img src="https://cdn.l2xy.com/post_img/mysql_img/clustered_seven.webp"><br>值得我们关注的是，索引的使用是在存储引擎中进行的，而数据记录的比较是在Server层中进行的。现在我们把上述搜索考虑地极端一点，假如数据表中10万条记录都符合name=’蝉沐风’的条件，而只有1条符合phone LIKE “%6606”条件，这就意味着，InnoDB需要将99999条无效的记录传输给Server层让其自己筛选，更严重的是，这99999条数据都是通过回表搜索出来的啊！关于回表的代价你已经知道了。<br>现在引入<strong>索引下推</strong>。准确来说，应该叫做<strong>索引条件下推</strong>（Index Condition Pushdown，<strong>ICP</strong>），就是过滤的动作由下层的存储引擎层通过使用索引来完成，而不需要上推到Server层进行处理。ICP是在MySQL5.6之后完善的功能。<br>再回顾一下，我们第一步已经通过name = “蝉沐风”在联合索引的叶子节点中找到了符合条件的3条记录，而且phone字段也恰好在联合索引的叶子节点的记录中。这个时候可以直接在联合索引的叶子节点中进行遍历，筛选出尾号为6606的记录，找到主键值为78921的记录，最后只需要进行1次回表操作即可找到符合全部条件的1条记录，返回给Server层。<br>很明显，使用ICP的方式能有效减少回表的次数。<br>另外，ICP是默认开启的，对于二级索引，只要能把条件甩给下面的存储引擎，存储引擎就会进行过滤，不需要我们干预。</p><p><img src="https://cdn.l2xy.com/post_img/mysql_img/clustered_eight.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 之索引、视图、触发器</title>
      <link href="/posts/b1cb609d.html"/>
      <url>/posts/b1cb609d.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-之索引、视图、触发器"><a href="#MySQL-之索引、视图、触发器" class="headerlink" title="MySQL 之索引、视图、触发器"></a>MySQL 之索引、视图、触发器</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li>索引的引入</li></ul><p>索引是由数据库表中一列或者多列组合而成，其作用是提高对表中数据的查询速度；类似于图书的目录，方便快速定位，寻找指定的内容。</p><ul><li>索引的优缺点</li></ul><p>优点：提高查询数据的速度<br>缺点：创建和维护索引的时间增加了</p><ul><li>建立索引的建议</li></ul><ol><li>一张表建议最多建立 5 个索引</li><li>建立复合索引优于单值索引（复合索引占用空间小）</li></ol><ul><li>建立索引的技巧</li></ul><ol><li>如果是左连接则需要在右表关联字段上建立索引，因为左表是查的全部数据。如果是右连接则需要在左表关联字段上建立索引。</li><li>尽可能减少 join 语句中的 NestedLoop 的循环总次数。（永远用小结果集驱动大的结果集）</li><li>优先优化 NestedLoop 的内层循环。</li><li>保证 join 语句中被驱动表上 join 条件字段已经被索引。</li><li>当无法保证被驱动表的 join 条件字段被索引且内存资源充足的前提下，不要太吝啬 JoinBuffer 的设置。</li></ol><ul><li>索引失效的常见原因</li></ul><ol><li>查询全部列，不会使用到索引（select *）</li><li>不遵守最佳左前缀法则（如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且<strong>不跳过索引的列</strong>）</li><li>在索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效而转向全表扫描</li><li>存储引擎使用了索引中范围条件右边的列，会导致不会使用到索引</li><li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少 select *</li><li>mysql 在使用不等于 （!= 或 &lt;&gt;）的时候无法使用索引会导致全表扫描</li><li>is null,is not null 也无法使用索引</li><li>like 以通配符开头 （’%abc’ 或者 ‘%abc%’）mysql 索引失效会变成全表扫描的操作，当百分号写在右边的时候索引不会失效。解决 ‘%abc%’ 索引失效的方法是，在要模糊查询字段上建立索引，使用覆盖索引的方式查询，则索引则不会失效。</li><li>varchar 类型 （字符串）不加单引号索引失效（如果是 InnoDB 存储类型，会导致行锁变表锁）</li><li>少用 or，用它来连接时索引会失效，即使其中的条件带有索引也不会使用到索引，如果要想使用 or，又想让索引生效，只能将 or 条件中的每一列都加上索引。如果出现 or 的语句中没有一个列加了索引，那么建议使用 union 拼接多个查询语句。</li><li>not in 和 not exist 不会走索引</li></ol><ul><li>优化口诀<br>全值匹配我最爱，最左前缀要遵守；<br>带头大哥不能死，中间兄弟不能断；<br>索引列上少计算，范围之后全失效；<br>like百分写最右，覆盖索引不写*；<br>不等空值还有or，索引失效要少用。</li></ul><ul><li>创建索引的前提</li></ul><p>索引的效率取决于<strong>索引列的值是否为散列</strong>，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如 gender 列，大约一半的记录值是 M，另一半是 F，因此，对该列创建索引就没有意义。区分度的公式是 <code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p><em><strong>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</strong></em></p><ul><li>创建表的时候创建索引：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>-- 创建普通索引<br>CREATE TABLE t_user1 (<br>id INT,<br>userName VARCHAR (20),<br>PASSWORD VARCHAR (20),<br>INDEX (userName)<br>);<br><br>-- 创建唯一性索引并为索引取别名<br>CREATE TABLE t_user2 (<br>id INT,<br>userName VARCHAR (20),<br>PASSWORD VARCHAR (20),<br>UNIQUE INDEX usrn (userName)<br>);<br><br>-- 创建多列索引<br>CREATE TABLE t_user3 (<br>id INT,<br>userName VARCHAR (20),<br>PASSWORD VARCHAR (20),<br>INDEX index_user_pwd (userName,PASSWORD)<br>);<br><br></code></pre></td></tr></tbody></table></figure><ul><li>在已有表中创建索引</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>-- 在已有表中创建普通索引<br>CREATE INDEX index_userName ON t_user4(userName);<br><br>-- 在已有表中创建唯一性索引<br>CREATE UNIQUE INDEX index_userName ON t_user4(userName);<br><br>-- 在已有表中创建多列索引<br>CREATE INDEX index_userName_pwd ON t_user4(userName,PASSWORD);<br>// 或者采用下面的方式<br>ALTER TABLE students<br>ADD INDEX idx_name_score (name, score);<br><br>-- 使用 ALTER 删除索引<br>ALTER TABLE t_user5 ADD INDEX index_user(userName)<br><br></code></pre></td></tr></tbody></table></figure><ul><li>查看索引</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>show index from table_name\G;<br><br></code></pre></td></tr></tbody></table></figure><ul><li>删除索引</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>-- 删除索引<br>-- DROP INDEX 索引名 ON 表名;<br>DROP INDEX index_user ON t_user5;<br><br></code></pre></td></tr></tbody></table></figure><ul><li>索引检索原理</li></ul><p><img src="https://cdn.l2xy.com/post_img/mysql_img/indexes_one.png" alt="索引检索原理"></p><p><img src="https://cdn.l2xy.com/post_img/mysql_img/indexes_two.png" alt="索引的分析"></p><ul><li>哪些情况下应该建立索引 ？</li></ul><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引（因为每次更新不单单是更新了记录还会更新索引）</li><li>where 条件里用不到的字段不创建索引</li><li>单键索引还是组合索引的选择问题？（在高并发下倾向创建组合索引）</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ol><ul><li>哪些情况下不要建立索引？</li></ul><ol><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意：如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ol><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li>视图的引入</li></ul><ol><li>试图是一种虚拟的表，是从数据库中一个或者多个表中导出来的表。</li><li>数据库中只存放了视图的定义，而并没有存放视图中的数据，这些数据存放在原来的表中。</li><li>使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。</li></ol><ul><li>视图的作用</li></ul><ol><li>使操作简便化；eg：如果一张表中有 100 个字段，需求只需要 20 个字段，那么可以定义一个视图只取出 20 个字段。</li><li>增加数据的安全性；eg：如果写代码的时候不想要别人知道某些字段，那么可以定义视图，只取出安全系数低的字段</li><li>提高表的逻辑独立性；</li></ol><ul><li>创建视图</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>CREATE [ALGORITHM = {UNDEFIEND | MERGE | TEMPTABLE}]<br>    VIEW 视图名 [(属性清单)]<br>    AS SELECT 语句<br>    [WITH [CASCADED | LOCAL] CHECK OPTION]<br>    <br>-- 创建单表视图<br>CREATE VIEW v1 AS SELECT userName,password FROM t_user4<br><br>-- 创建单表视图并给视图字段取别名<br>CREATE VIEW v1(u,p) AS SELECT userName,password FROM t_user4<br><br>-- 查询视图结果<br>SELECT * FROM v1<br><br>-- 在多表上创建视图<br>CREATE VIEW v2 AS SELECT bookName.bookTypeName FROM t_book,t_booktype WHERE t_book.bookTypeId = t_booktype.id    <br>    <br></code></pre></td></tr></tbody></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><ul><li>触发器的引入</li></ul><p>触发器（trigger）是由事件来触发某个操作，这些事件包括 insert 语句、 update 语句和 delete 语句。当数据库系统执行这些事件时，就会激活触发器执行相应的操作。</p><ul><li>创建与使用触发器</li></ul><ol><li>创建只有一个执行语句的触发器</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>CREATE TRIGGER 触发器名 BEFORE | AFTER 触发事件 ON 表名 FOR EACH ROW 执行语句<br><br>-- 其中 new 和 old 为过渡变量， new 代表新的数据，old 代表旧的数据<br>eg：<br><br>CREATE TRIGGER trig_book AFTER INSERT<br>ON t_book FOR EACH ROW<br>UPDATE t_booktype SET bookNum=bookNum+1 WHERE new.bookTypeId=t_booktype.id<br><br>-- 执行以下语句之后将会触发触发器<br>INSERT INTO t_book VALUES(NULL,'php学习',100,'ke',1)<br><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>创建有多个执行语句的触发器</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>CREATE TRIGGER 触发器名 BEFORE | AFTER 触发事件<br>    ON 表名 FOR EACH ROW<br>    BEGIN<br>        执行语句列表<br>    END  <br><br>-- 其中，因为 mysql 遇到分号（;）之后会认为语句终止（分号前面的语句为执行语句），<br>因此需要使用 delimiter 来手动定义在 | 符号中间的语句才为执行语句   <br>eg：<br><br>delimiter |<br>CREATE TRIGGER trig_book2 AFTER DELETE<br>ON t_book FOR EACH ROW<br>BEGIN <br>UPDATE t_booktype SET bookNum=bookNum-1 WHERE old.bookTypeId=t_booktype.id;<br>INSERT INTO t_log VALUES (NULL,NULL,'在book表里删除了一条数据');<br>DELETE FROM t_test WHERE old.bookTypeId=t_test.id;<br>END<br>|<br>delimiter;<br><br>-- 执行以下语句之后将会触发触发器<br>DELETE FROM t_book WHERE id=3;<br>    <br></code></pre></td></tr></tbody></table></figure><ul><li>查看触发器</li></ul><ol><li>直接执行 sql 语句</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>SHOW TRIGGERS;<br><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>在系统数据库中 information_schema 库中查看 TRIGGERS 表</li></ol><ul><li>删除触发器</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>DROP TRIGGER [触发器名];<br><br>eg:<br>DROP TRIGGER trig_book2;<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 安装 homebrew</title>
      <link href="/posts/6fa24dc0.html"/>
      <url>/posts/6fa24dc0.html</url>
      
        <content type="html"><![CDATA[<h1 id="MacOS-安装-homebrew"><a href="#MacOS-安装-homebrew" class="headerlink" title="MacOS 安装 homebrew"></a>MacOS 安装 homebrew</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>brew update</td><td>更新 Homebrew 自身</td></tr><tr><td>brew outdated</td><td>查看哪些安装包需要更新</td></tr><tr><td>brew upgrade</td><td>更新所有的包</td></tr><tr><td>brew upgrade $FORMULA</td><td>更新指定的包</td></tr><tr><td>brew cleanup</td><td>清理所有包的旧版本</td></tr><tr><td>brew cleanup $FORMULA</td><td>清理指定包的旧版本</td></tr><tr><td>brew cleanup -n</td><td>查看可清理的旧版本包，不执行实际操作</td></tr><tr><td>brew pin $FORMULA</td><td>锁定某个包</td></tr><tr><td>brew unpin $FORMULA</td><td>取消锁定</td></tr><tr><td>brew info $FORMULA</td><td>显示某个包的信息</td></tr><tr><td>brew info</td><td>显示安装了包数量，文件数量，和总占用空间</td></tr><tr><td>brew deps –installed –tree</td><td>查看已安装的包的依赖，树形显示</td></tr><tr><td>brew list</td><td>列出已安装的包</td></tr><tr><td>brew rm $FORMULA</td><td>删除某个包</td></tr><tr><td>brew uninstall –force $FORMULA</td><td>删除所有版本</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote><p><a href="https://brew.sh/">Homebrew 官网地址</a><br><a href="https://github.com/homebrew/install#uninstall-homebrew">Homebrew GitHub 地址</a><br><a href="https://github.com/Homebrew/brew/releases/tag/2.7.3">官网源码下载</a><br><a href="https://github.com/homebrew/install#uninstall-homebrew">官网 GitHub 地址</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">清华大学开源软件镜像站 - 安装 homebrew</a><br><a href="https://www.jianshu.com/p/5822d24a651e">使用国内镜像安装 homebrew</a>  </p></blockquote><blockquote><p>如果使用官网推荐的方式下载时提示以下错误信息时，则表示网络超时，建议直接使用源码包的形式安装</p></blockquote><p>错误信息如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused<br></code></pre></td></tr></tbody></table></figure><h2 id="直接使用包安装"><a href="#直接使用包安装" class="headerlink" title="直接使用包安装"></a>直接使用包安装</h2><ol><li>进入 <a href="https://github.com/Homebrew/brew/tags">Homebrew 的 GitHub 仓库 tag 地址</a> 下载最新的 tag</li><li>根据系统选择下载：mac、windows 可以下载 zip 文件， linux 可以下载 tar.gz 的文件。</li><li>下载后解压。</li><li>进入本地 <code>Homebrew</code> 的存放路径，如果找不到的话，可以直接在 <code>terminal</code> 下输入以下命令</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 进入  usr/local 目录</span><br><span class="hljs-built_in">cd</span> /usr/local<br><br><span class="hljs-comment"># 使用访达(finder) 打开当前目录</span><br>open .<br><br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>查看 <code>/usr/local</code> 目录下是否有 <code>Homebrew</code> 文件夹（注意大小写），如果你发现没有 <code>Homebrew</code> 文件夹，则执行以下命令创建 <code>Homebrew</code> 文件夹</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-built_in">mkdir</span> -p /user/local/Homebrew<br><br></code></pre></td></tr></tbody></table></figure><ol start="6"><li><p>将第三步中解压后的内容全部复制到 <code>/usr/local/Homebrew</code> 目录</p></li><li><p>重启命令行窗口，输入 <code>brew</code> 命令，出现 brew 相关的 help 页面，即表示已经安装成功</p></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-built_in">cd</span> /user/local/Homebrew &amp;&amp; brew<br><br></code></pre></td></tr></tbody></table></figure><p>敲击 <code>brew</code> 命令时，出现以下内容时，表示已经安装 Homebrew 成功</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">Example usage:<br>  brew search [TEXT|/REGEX/]<br>  brew info [FORMULA...]<br>  brew install FORMULA...<br>  brew update<br>  brew upgrade [FORMULA...]<br>  brew uninstall FORMULA...<br>  brew list [FORMULA...]<br><br>Troubleshooting:<br>  brew config<br>  brew doctor<br>  brew install --verbose --debug FORMULA<br><br>Contributing:<br>  brew create [URL [--no-fetch]]<br>  brew edit [FORMULA...]<br><br>Further <span class="hljs-built_in">help</span>:<br>  brew commands<br>  brew <span class="hljs-built_in">help</span> [COMMAND]<br>  man brew<br>  https://docs.brew.sh<br></code></pre></td></tr></tbody></table></figure><ol start="8"><li>安装完成后，一定要下载一个软件测试下，比如下载 <code>wget</code></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install wget<br></code></pre></td></tr></tbody></table></figure><ol start="9"><li>更换 brew 的下载源</li></ol><ul><li><p><a href="http://mirrors.ustc.edu.cn/help/brew.git.html">Homebrew 源</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 替换 USTC 镜像</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-subst">$(brew --repo)</span>"</span><br>git remote set-url origin https://mirrors.ustc.edu.cn/brew.git<br><br><span class="hljs-comment"># 重置为官方地址</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-subst">$(brew --repo)</span>"</span><br>git remote set-url origin https://github.com/Homebrew/brew.git<br></code></pre></td></tr></tbody></table></figure></li><li><p><a href="http://mirrors.ustc.edu.cn/help/homebrew-bottles.html">Homebrew Bottles 源</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 请在运行 brew 前设置环境变量 HOMEBREW_BOTTLE_DOMAIN ，值为 https://mirrors.ustc.edu.cn/homebrew-bottles</span><br><br><span class="hljs-comment"># 对于 bash 用户</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles'</span> &gt;&gt; ~/.bash_profile<br><br><span class="hljs-built_in">source</span> ~/.bash_profile<br><br><br><span class="hljs-comment"># 对于 zsh 用户</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles'</span> &gt;&gt; ~/.zshrc<br><br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></tbody></table></figure></li><li><p><a href="http://mirrors.ustc.edu.cn/help/homebrew-core.git.html">Homebrew Core 源</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 替换 USTC 镜像</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span><br>git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git<br><br><span class="hljs-comment"># 重置为官方地址</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span><br>git remote set-url origin https://github.com/Homebrew/homebrew-core<br></code></pre></td></tr></tbody></table></figure></li><li><p><a href="http://mirrors.ustc.edu.cn/help/homebrew-cask.git.html">Homebrew Cask 源</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 替换为 USTC 镜像</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-subst">$(brew --repo)</span>"</span>/Library/Taps/homebrew/homebrew-cask<br>git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git<br><br><span class="hljs-comment"># 重置为官方地址</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-subst">$(brew --repo)</span>"</span>/Library/Taps/homebrew/homebrew-cask<br>git remote set-url origin https://github.com/Homebrew/homebrew-cask<br></code></pre></td></tr></tbody></table></figure></li><li><p><a href="http://mirrors.ustc.edu.cn/help/homebrew-cask-versions.git.html">Homebrew Cask Versions 源</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 替换为 USTC 镜像</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-subst">$(brew --repo)</span>"</span>/Library/Taps/homebrew/homebrew-cask-versions<br>git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask-versions.git<br><br><span class="hljs-comment"># 重置为官方地址</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-subst">$(brew --repo)</span>"</span>/Library/Taps/homebrew/homebrew-cask-versions<br>git remote set-url origin https://github.com/Homebrew/homebrew-cask-versions.git<br></code></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的持久化</title>
      <link href="/posts/6d929828.html"/>
      <url>/posts/6d929828.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-的持久化"><a href="#Redis-的持久化" class="headerlink" title="Redis 的持久化"></a>Redis 的持久化</h1><h2 id="两种持久化方式"><a href="#两种持久化方式" class="headerlink" title="两种持久化方式"></a>两种持久化方式</h2><ul><li>RDB 指定的时间间隔内保存数据快照</li><li>AOF 先把命令追加到操作日志的尾部，保存所有历史操作命令</li></ul><h3 id="RDB-模式"><a href="#RDB-模式" class="headerlink" title="RDB 模式"></a>RDB 模式</h3><ul><li><strong>优点</strong></li></ul><ol><li>适合用于进行备份</li><li>fork 出子进程进行备份，主进程没有任何 IO 操作</li><li>恢复大数据集时的速度快</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>特定条件下进行一次持久化，易丢失数据</li><li>庞大数据时，保存时会出现性能问题</li></ol><p>设置方式</p><p>配置文件路径： sudo vim /etc/redis/redis.conf</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 备份的频次</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>    # <span class="hljs-number">900</span> 秒内，有 <span class="hljs-number">1</span> 次更新操作，就将数据同步到数据文件<br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># 备份的文件名</span><br> <span class="hljs-attribute">253</span> dbfilename dump.rdb<br><br><span class="hljs-comment"># 备份的目录路径</span><br> <span class="hljs-attribute">263</span> dir /var/lib/redis<br><br></code></pre></td></tr></tbody></table></figure><p>默认的备份文件为： vim /var/lib/redis/dump.rdb</p><h3 id="AOF-模式"><a href="#AOF-模式" class="headerlink" title="AOF 模式"></a>AOF 模式</h3><ul><li><strong>优点</strong></li></ul><ol><li>数据非常完整，故障恢复丢失数据少</li><li>可对历史操作进行处理</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>文件的体积大</li><li>速度低于 RDB 且故障恢复速度慢</li></ol><p>设置方式</p><p>配置文件路径： sudo vim /etc/redis/redis.conf</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># 当 appendonly 参数为 yes 时，则开启 AOF 模式</span><br><span class="hljs-number"> 672 </span>appendonly yes<br><br><span class="hljs-comment"># 备份的文件名</span><br><span class="hljs-number"> 676 </span>appendfilename "appendonly.aof"<br><br><span class="hljs-comment"># 同步的方式</span><br><span class="hljs-number"> 701 </span><span class="hljs-comment"># appendfsync always  // 同步持久化，每次数据变更都会立刻保存到磁盘上，需要实时记录，因此效率不高，但是数据十分完整</span><br><span class="hljs-number"> 702 </span>appendfsync everysec  // 异步持久化，每隔 1s 记录一次<br><span class="hljs-number"> 703 </span><span class="hljs-comment"># appendfsync no  // 不同步</span><br><br></code></pre></td></tr></tbody></table></figure><p>默认的备份文件为： vim /var/lib/redis/appendonly.aof</p><blockquote><p>两种模式可以同时开启，同时开启的时候会优先执行 AOF 模式的备份文件，进行 AOF 模式恢复，同时开启的时候，需要注意在 redis 使用之初就要先开启 AOF 模式，以免 AOF 模式，只会记录部分命令，导致恢复数据不完整。</p></blockquote><h2 id="合理地使用-Redis"><a href="#合理地使用-Redis" class="headerlink" title="合理地使用 Redis"></a>合理地使用 Redis</h2><ul><li>防止内存占满：</li></ul><ol><li>设置超时时间</li><li>不存放过大文件（最好不要超过 500 字节）</li><li>不存放不常用数据</li></ol><ul><li>提高使用效率</li></ul><ol><li>合理使用不同的数据结构类型</li><li>慎用正则处理或者批量操作 Hash、Set 等。（因为 redis 是单线程，如果正则匹配 key 的话，可能会影响其他命令的使用）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cluster 集群解决方案</title>
      <link href="/posts/663a091e.html"/>
      <url>/posts/663a091e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Cluster-集群解决方案"><a href="#Redis-Cluster-集群解决方案" class="headerlink" title="Redis Cluster 集群解决方案"></a>Redis Cluster 集群解决方案</h1><ul><li>多个 Redis 实例协同进行</li><li>采用 slot （槽）分割数据，是 CRC16 与 16384 取模后分散</li><li>主从结构和选举算法，保证每个节点的可靠性</li><li>客户端可以连接任意一个 node 进行操作</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14623749-a6ad3bca1885917a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主从协同进行"></p><ul><li>所有的 redis 节点彼此互联（PING-PONG 机制），内部使用二进制协议优化传输速度和带宽。</li><li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与 redis 节点直连，不需要中间 proxy 层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li><li>redis-cluster 把所有的物理节点映射到 [0-16383] slot 上，cluster 负责维护 node &lt;-&gt; slot &lt;-&gt; value</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14623749-51f56d899218929f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当有一台服务器出现故障时"></p><h2 id="Redis-Cluster-注意事项"><a href="#Redis-Cluster-注意事项" class="headerlink" title="Redis Cluster 注意事项"></a>Redis Cluster 注意事项</h2><ul><li>不完全支持批量操作：mset、mget</li><li>事务不能跨节点支持</li><li>不支持多实例</li><li>key 是最小粒度</li><li>最少 6 个才能保证组成完整高可用的集群</li><li>连接的时候只需要连接 1 台服务器即可。</li><li>如果 1 个主从连接宕机的话，那么集群就宕机了。</li></ul><h2 id="Redis-Cluster-配置步骤"><a href="#Redis-Cluster-配置步骤" class="headerlink" title="Redis Cluster 配置步骤"></a>Redis Cluster 配置步骤</h2><p><em><strong>（建议使用官方安装包的方式安装 redis，不要使用 apt-get install 或者 yum 直接安装）</strong></em></p><ol><li>分别安装 <strong>6 台</strong> 服务器，三个主节点，三个从节点</li></ol><p>我这里采用的是虚拟机，相应的 ip 地址分别为：</p><ul><li>192.168.174.128  （28 号服务器）</li><li>192.168.174.129  （29 号服务器）</li><li>192.168.174.130  （30 号服务器）</li><li>192.168.174.131  （31 号服务器）</li><li>192.168.174.132  （32 号服务器）</li><li>192.168.174.133  （33 号服务器）</li></ul><ol start="2"><li>配置 <code>redis.conf</code> 配置文件 <em><strong>（在所有的服务器上操作）</strong></em></li></ol><p>vim /etc/redis/redis.conf</p><ul><li>第一步：</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-comment"># 默认为本地 ip 地址，需要改成当前服务器的 ip 地址，以便其他服务器可以正常访问</span><br>  <span class="hljs-attribute">69</span> bind <span class="hljs-number">127.0.0.1</span> ::<span class="hljs-number">1</span><br>  <br><span class="hljs-comment"># 比如 28 号服务器更改为以下 ip 地址</span><br><span class="hljs-attribute">bind</span> <span class="hljs-number">192.168.174.128</span><br><br></code></pre></td></tr></tbody></table></figure><ul><li>第二步：</li></ul><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br><span class="hljs-meta"># 这个参数的含义是指：禁止公网连接 redis 缓存，这样可以加强 redis 安全性。如果是在线上环境的话，我们不需要更改此参数值，然后需要进行设置账号密码，进行 auth 认证。这里为了测试方便，我们直接改成 no</span><br>  <span class="hljs-number">89</span> <span class="hljs-keyword">protected</span>-mode yes<br>  <br><span class="hljs-meta"># 需要更改为以下</span><br><span class="hljs-keyword">protected</span>-mode no<br><br></code></pre></td></tr></tbody></table></figure><ul><li>第三步：开启集群相关参数</li></ul><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap"><br><span class="hljs-comment"># 默认集群是关闭的</span><br><span class="hljs-number"> 815 </span><span class="hljs-comment"># cluster-enabled yes</span><br><br><span class="hljs-comment"># 需要更改为以下（去除掉 # 号注释即可）</span><br><span class="hljs-number"> 815 </span>cluster-enabled yes<br><br></code></pre></td></tr></tbody></table></figure><ul><li>第四步：开启集群配置文件</li></ul><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 默认集群配置文件是关闭的<br> 823 # <span class="hljs-keyword">cluster</span>-config-<span class="hljs-keyword">file</span> nodes-6379.<span class="hljs-keyword">conf</span><br> <br># 需要更改为以下（去除掉 # 号注释即可） <br> 823 <span class="hljs-keyword">cluster</span>-config-<span class="hljs-keyword">file</span> nodes-6379.<span class="hljs-keyword">conf</span> <br> <br></code></pre></td></tr></tbody></table></figure><ul><li>第五步：开启集群超时时间</li></ul><figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 当一个节点出现问题的时候，最大超时连接时间为 15s ，当超过 15s 还没有连接的时候，就会认为该节点出现故障了，就会通过选举算法，将从服务器提升为主服务器。该参数默认是关闭的。</span><br> <span class="hljs-number">829</span> <span class="hljs-comment"># cluster-node-timeout 15000</span><br> <br><span class="hljs-comment"># 需要更改为以下（去除掉 # 号注释即可）</span><br> <span class="hljs-number">829</span> cluster-<span class="hljs-keyword">node</span><span class="hljs-title">-timeout</span> <span class="hljs-number">15000</span><br> <br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>安装 <code>ruby</code> 组件。如果不安装这个软件，集群的时候，会报组件错误。你需要在那台服务器上面做集群，你就需要在哪台服务器上安装这个组件，并不是每台服务器上面都安装。这里采用第一台服务器做集群，因此在第一台服务器上安装 <code>ruby</code> 组件。<em><strong>（在 28 号服务器上操作）</strong></em></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install ruby<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>安装其他组件  <em><strong>（在 28 号服务器上操作）</strong></em></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gem install redis<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>配置集群  <em><strong>（在 28 号服务器上操作）</strong></em></li></ol><p>因为我是直接采用的 <code>apt-get install</code> 的方式安装的 <code>redis</code> 因此，服务器上面的 <code>redis</code> 工具 <code>redis-trib.rb</code> 在 <code>/usr/share/doc/redis-tools/examples</code> 目录下。如果你是通过安装包安装的 <code>redis</code> 那么请直接到 <code>redis</code> 解压目录中执行命令，如： <code>~/redis-4.0.9/src/redis-trib.rb</code></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">/usr/share/doc/redis-tools/examples/redis-trib.rb create --replicas <span class="hljs-number">1 192.168.174</span>.<span class="hljs-number">128:6379 192</span>.<span class="hljs-number">168.174.129</span>:<span class="hljs-number">6379 192.168</span>.<span class="hljs-number">174.130:6379</span> <span class="hljs-number">192.168.174.131</span>:<span class="hljs-number">6379 192.168</span>.<span class="hljs-number">174.132:6379</span> <span class="hljs-number">192.168.174.133</span>:<span class="hljs-number">6379</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14623749-d756993ee1a78b0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置集群"></p><h3 id="如果出现如下报错时"><a href="#如果出现如下报错时" class="headerlink" title="如果出现如下报错时"></a>如果出现如下报错时</h3><p><img src="https://upload-images.jianshu.io/upload_images/14623749-398cfd78326a863f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插槽节点被占用"></p><p><strong>问题原因：</strong><br>slot 插槽被占用了（这是搭建集群前时，以前 redis 的旧数据和配置信息没有清理干净。）<br><strong>解决方案如下：</strong><br>用 redis-cli 登录到每个节点执行  flushall  和 cluster reset  就可以了</p><p><img src="https://upload-images.jianshu.io/upload_images/14623749-460623a9e0c0186b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解决方案如图所示"></p><p><img src="https://upload-images.jianshu.io/upload_images/14623749-f2ae4a85d4fd0304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="再次设置集群，则可以连接成功"></p><ol start="6"><li>连接集群 <em><strong>（在任意一台服务器上操作）</strong></em></li></ol><p>这里我挑选的是 ip 地址为 ： 192.168.174.131 的服务器，特别说明下，当执行 <code>keys</code> 命令的时候，只针对于当前服务器</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 带 -c 参数表示连接集群</span><br><span class="hljs-attribute">redis</span>-cli -h <span class="hljs-number">192.168.174.131</span> -c<br></code></pre></td></tr></tbody></table></figure><ol start="7"><li>测试</li></ol><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">alex@alex-virtual-machine:~$ redis-cli -h <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">174</span>.<span class="hljs-number">131</span> -c    # 连接的 <span class="hljs-number">31</span> 号服务器<br><span class="hljs-number">192.168.174.131:6379</span>&gt; keys *  # 这里的 keys 也只能查看所有在 <span class="hljs-number">31</span> 号服务器上面的 keys<br>(empty list or set)<br><span class="hljs-number">192.168.174.131:6379</span>&gt; set aa <span class="hljs-number">111</span>  # 随便设置一个 key<br>-&gt; Redirected to slot <span class="hljs-string">[1180]</span> located at <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">174</span>.<span class="hljs-number">128</span>:<span class="hljs-number">6379</span>  # 数据却在 <span class="hljs-number">28</span> 号服务器上被保存<br>OK<br><span class="hljs-number">192.168.174.128:6379</span>&gt;   # 并且此时的状态直接跳到了 <span class="hljs-number">28</span> 号服务器上面<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14623749-1f41460e9f146d8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连接 31 号服务器，数据存到了 28 号服务器上"></p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby">alex<span class="hljs-variable">@alex</span>-virtual-<span class="hljs-symbol">machine:</span>~<span class="hljs-variable">$ </span>redis-cli -h <span class="hljs-number">192.168</span>.<span class="hljs-number">174.129</span> -c  <span class="hljs-comment"># 通过 29 号服务器连接集群</span><br><span class="hljs-meta prompt_">192.168.174.129:6379&gt;</span> get aa  <span class="hljs-comment"># 从 29 号服务器中去取值</span><br>-&gt; <span class="hljs-title class_">Redirected</span> to slot [<span class="hljs-number">1180</span>] located at <span class="hljs-number">192.168</span>.<span class="hljs-number">174.128</span><span class="hljs-symbol">:</span><span class="hljs-number">6379</span>  <span class="hljs-comment"># 会直接从 28 号服务器中返回值</span><br><span class="hljs-string">"111"</span><br><span class="hljs-meta prompt_">192.168.174.128:6379&gt;</span>   <span class="hljs-comment"># 并且此时的状态直接跳到了 28 号服务器上面</span><br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14623749-56e8e278da0250a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从 30 号服务器上面取刚刚设置的值，会直接跳到 28 号服务器返回值"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">alex@alex-virtual-machine:~$ redis-cli -h <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">174</span>.<span class="hljs-number">130</span> -c  # 通过 <span class="hljs-number">30</span> 号服务器连接集群<br><span class="hljs-number">192.168.174.130:6379</span>&gt; keys *  # <span class="hljs-number">30</span> 号服务器中并没有设置过 key，如果 <span class="hljs-number">30</span> 号服务器可以取出值，证明可以跨服务器取出 keys，但是并没有数据，证明 keys 只能取出当前服务器中的 keys<br>(empty list or set)<br><span class="hljs-number">192.168.174.130:6379</span>&gt; <br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14623749-a8098e86eba5fc31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="keys 只能取出当前服务器中的所有 key"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> Redis </tag>
            
            <tag> 分布式集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 三范式</title>
      <link href="/posts/b17a8184.html"/>
      <url>/posts/b17a8184.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-三范式"><a href="#MySQL-三范式" class="headerlink" title="MySQL 三范式"></a>MySQL 三范式</h1><h2 id="第一范式（1NF）：表中的每列的属性不可再分"><a href="#第一范式（1NF）：表中的每列的属性不可再分" class="headerlink" title="第一范式（1NF）：表中的每列的属性不可再分"></a>第一范式（1NF）：表中的每列的属性不可再分</h2><p>比如：</p><table><thead><tr><th>学号（主键）</th><th>姓名</th><th>性别</th><th>就读信息</th></tr></thead><tbody><tr><td>20200101</td><td>张三</td><td>男</td><td>大一，土木工程</td></tr></tbody></table><blockquote><p>上表中可以看到，（就读信息）这一列，其实还可以分解成（年级）和（专业），因此（就读信息）这一属性还可以再分，故不满足第一范式</p></blockquote><p>修改成：</p><table><thead><tr><th>学号（主键）</th><th>姓名</th><th>性别</th><th>年级</th><th>专业</th></tr></thead><tbody><tr><td>20200101</td><td>张三</td><td>男</td><td>大一</td><td>土木工程</td></tr></tbody></table><h2 id="第二范式（2NF）：在第一范式的基础上，表里的非主键属性必须都依赖于主键（联合主键）"><a href="#第二范式（2NF）：在第一范式的基础上，表里的非主键属性必须都依赖于主键（联合主键）" class="headerlink" title="第二范式（2NF）：在第一范式的基础上，表里的非主键属性必须都依赖于主键（联合主键）"></a>第二范式（2NF）：在第一范式的基础上，表里的非主键属性必须都依赖于主键（联合主键）</h2><p>比如：</p><table><thead><tr><th>学号（主键）</th><th>课程（主键）</th><th>教师姓名</th><th>成绩</th><th>学生姓名</th><th>专业</th></tr></thead><tbody><tr><td>20200101</td><td>C语言程序设计</td><td>老张</td><td>80</td><td>张三</td><td>计算机科学与技术</td></tr><tr><td>20200102</td><td>JAVA程序设计</td><td>老李</td><td>87</td><td>李四</td><td>网络工程</td></tr><tr><td>20200103</td><td>数据结构</td><td>老王</td><td>90</td><td>王五</td><td>软件工程</td></tr></tbody></table><blockquote><p>上表中可以看到，（教师姓名、成绩）两个属性都依赖于（学号）和（课程），但是（学生姓名、专业）这两个属性却只依赖于（学号），不依赖于（课程），即 <strong>只需要知道（学号）便可以知道（学生姓名和专业两个属性）</strong>，所以，导致非主键属性（学生姓名、专业）不完全依赖于主键（学号、课程），故不符合第二范式</p></blockquote><p>修改成：</p><table><thead><tr><th>学号（主键）</th><th>课程（主键）</th><th>教师姓名</th><th>成绩</th></tr></thead><tbody><tr><td>20200101</td><td>C语言程序设计</td><td>老张</td><td>80</td></tr><tr><td>20200102</td><td>JAVA程序设计</td><td>老李</td><td>87</td></tr><tr><td>20200103</td><td>数据结构</td><td>老王</td><td>90</td></tr></tbody></table><hr><table><thead><tr><th>学号（主键）</th><th>学生姓名</th><th>专业</th></tr></thead><tbody><tr><td>20200101</td><td>张三</td><td>计算机科学与技术</td></tr><tr><td>20200102</td><td>李四</td><td>网络工程</td></tr><tr><td>20200103</td><td>王五</td><td>软件工程</td></tr></tbody></table><h2 id="第三范式（3NF）：在第二范式的基础上，表中的非主属性不可以存在依赖关系"><a href="#第三范式（3NF）：在第二范式的基础上，表中的非主属性不可以存在依赖关系" class="headerlink" title="第三范式（3NF）：在第二范式的基础上，表中的非主属性不可以存在依赖关系"></a>第三范式（3NF）：在第二范式的基础上，表中的非主属性不可以存在依赖关系</h2><table><thead><tr><th>学号（主键）</th><th>姓名</th><th>性别</th><th>年级</th><th>专业</th><th>班主任姓名</th><th>班主任性别</th><th>班主任年龄</th></tr></thead><tbody><tr><td>20200101</td><td>张三</td><td>男</td><td>大一</td><td>计算机科学与技术</td><td>老张</td><td>男</td><td>33</td></tr><tr><td>20200102</td><td>李四</td><td>男</td><td>大二</td><td>网络工程</td><td>老李</td><td>男</td><td>34</td></tr><tr><td>20200103</td><td>王五</td><td>女</td><td>大三</td><td>软件工程</td><td>老王</td><td>男</td><td>35</td></tr></tbody></table><blockquote><p>上表中可以看到，非主键属性都依赖于（学号），满足了第二范式。但是（班主任性别、班主任年龄）这两个属性都是直接依赖于（班主任姓名）这一属性的，与（学号）属于间接依赖，这就导致了表中的非主键属性存在着依赖关系，不符合第三范式</p></blockquote><table><thead><tr><th>学号（主键）</th><th>姓名</th><th>性别</th><th>年级</th><th>专业</th></tr></thead><tbody><tr><td>20200101</td><td>张三</td><td>男</td><td>大一</td><td>计算机科学与技术</td></tr><tr><td>20200102</td><td>李四</td><td>男</td><td>大二</td><td>网络工程</td></tr><tr><td>20200103</td><td>王五</td><td>女</td><td>大三</td><td>软件工程</td></tr></tbody></table><hr><table><thead><tr><th>班主任姓名（主键）</th><th>班主任性别</th><th>班主任年龄</th></tr></thead><tbody><tr><td>老张</td><td>男</td><td>33</td></tr><tr><td>老李</td><td>男</td><td>34</td></tr><tr><td>老王</td><td>男</td><td>35</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 性能分析</title>
      <link href="/posts/1e4459df.html"/>
      <url>/posts/1e4459df.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-性能分析"><a href="#MySQL-性能分析" class="headerlink" title="MySQL 性能分析"></a>MySQL 性能分析</h1><h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>explain select * from users;<br><br>-- 本意为显示警告信息。但是和 explain 一块儿使用，就会显示出优化后的 sql。需要注意使用顺序。（只能在 mysql cli 中才会有结果）<br>show warnings;<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>最重要的 5 个字段是：id、type、key、rows、Extra</p></blockquote><ul><li><strong>id</strong>： select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序</li></ul><ol><li>id 相同，执行顺序由上至下</li><li>id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</li><li>id 有相同也有不同的，id 值越大优先级越高越先被执行，id 值相同的按由上到下执行</li></ol><ul><li><strong>select_type</strong>：查询的类型，主要是用于区别普通查询，联合查询，子查询等的复杂查询</li></ul><ol><li>simple ： 简单的 select 查询，查询中不包含子查询或者 union</li><li>primary ：查询中若包含任何复杂的子部份，最 外层查询则被标记为 primary</li><li>subquery ： 在 select 或 where 列表中包含子查询</li><li>derived ： 在 from 列表中包含的子查询被标记为 derived（衍生）MySQL 会递归执行这些子查询，把结果放在临时表里。</li><li>union ： 若第二个 select 出现在 union 之后，则被标记为 union：若 union 包含在 from 子句的子查询中，外层 select 将被标记为： derived</li><li>union result ： 从 union 表获取结果的 select</li></ol><ul><li><strong>table</strong> ： 显示这一行的数据是关于哪张表的</li><li><strong>type</strong> ： 访问类型排序<ul><li>常用的从最好到最差依次是，system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</li><li>完整的从最好到最差依次是 system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; ALL</li><li>一般来说， 得保证查询至少达到 range 级别，最好能达到 ref 级别</li></ul></li></ul><ol><li>system ：表只有一行记录（等于系统表），这是 const 类型的特例，平时不会出现，这个也可以忽略不计</li><li>const ： 表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</li><li>eq_ref : 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li><li>ref ： 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</li><li>range ：只检索给定范围的行，使用一个索引来选择行，key 列显示使用了哪个索引，一般就是在你的 where 语句中出现了 between 、&lt; 、&gt; 、in 等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引</li><li>index ： Full Index Scan，Index 与 ALL 区别为 index 类型只遍历索引树。这通常比 ALL 快，因为索引文件通常比数据文件小。（也就是说虽然 all 和 index 都是读全表，但 index 是从索引中读取的，而 all 是从硬盘中读的）</li><li>all ： Full Table Scan，将遍历全表以找到匹配的行</li></ol><p><strong>一般来说，得保证查询至少达到 range 级别，最好能达到 ref</strong></p><ul><li><strong>possible_keys</strong> ：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong></li><li><strong>key</strong> ： 实际使用的索引。如果为 null，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在 key 列表中。</li><li><strong>key_len</strong> : 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的</li><li><strong>ref</strong> ： 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</li><li><strong>rows</strong> ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数（行数越小越好）</li><li><strong>Extra</strong> ：包含不适合在其它列中显示但十分重要的额外信息</li></ul><ol><li>Using filesort ： 说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。<strong>九死一生了，效率比较差</strong></li><li>Using temporary ：使用了临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常用于排序 order by 和分组查询 group by。<strong>十死无生，效率最差！</strong></li><li>Using index ： 表示相应的 select 操作中使用了覆盖索引（Covering index），避免访问了表的数据行，效率不错！如果同时出现 using where ，表明索引被用来执行索引键值的查找；如果没有同时出现 using where ，表明索引用来读取数据而非执行查找动作。</li><li>Using where ：表明使用了 where 过滤</li><li>using join buffer ：使用了连接缓存</li><li>impossible where ： where 子句的值总是 false，不能用来获取任何元组</li><li>select tables optimized away ：在没有 group by 子句的情况下，基于索引优化 min/max 操作或者对于 MyISAM 存储引擎优化 count(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li><li>distinct ：优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作</li></ol><h2 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h2><ul><li>通俗来讲</li></ul><ol><li>观察，至少跑 1 天 ，看看生产的慢 sql 情况。</li><li>开启慢查询日志，设置阈值，比如超过 5 秒钟的就是慢 sql，并将它抓取出来。</li><li>explain + 慢 sql 分析</li><li>show profile</li><li>运维经理或者 DBA，进行 sql 数据库服务器的参数调优。</li></ol><ul><li>学术说法</li></ul><ol><li>慢查询的开启并捕获</li><li>explain + 慢 sql 分析</li><li>show profile 查询 sql 在 mysql 服务器里面的执行细节和生命周期情况</li><li>sql 数据库服务器的参数调优</li></ol><h3 id="提高-order-by-的速度"><a href="#提高-order-by-的速度" class="headerlink" title="提高 order by 的速度"></a>提高 order by 的速度</h3><ol><li>order by 时，select * 是一个大忌，只查询需要的字段，这点非常重要。在这里的影响是：</li></ol><ul><li>当查询的字段大小总和小于 max_length_for_sort_data 而且排序字段不是 text|blob 类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。</li><li>两种算法的数据都有可能超出 sort_buffer 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险会更大一些，所以要提高 sort_buffer_size</li></ul><ol start="2"><li>尝试提高 sort_buffer_size 不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的</li><li>尝试提高 max_length_for_sort_data 提高这个参数，会增加用改进算法的概率，但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I/O 活动和低的处理器使用率。</li></ol><h3 id="为排序使用索引"><a href="#为排序使用索引" class="headerlink" title="为排序使用索引"></a>为排序使用索引</h3><ul><li>MySQL 两种排序方式：文件排序或扫描有序索引排序</li><li>MySQL 能为排序与查询使用相同的索引</li></ul><p>KEY a_b_c (a,b,c)</p><ol><li>order by 能使用索引最左前缀<br>ORDER BY a<br>ORDER BY a,b<br>ORDER BY a,b,c<br>ORDER BY a DESC, b DESC, c DESC</li><li>如果 where 使用索引的最左前缀定义为常量，则 order by 能使用索引<br>WHERE a = const ORDER BY b,c<br>WHERE a = const AND b = const ORDER BY c<br>WHERE a = const ORDER BY b,c<br>WHERE a = const AND b &gt; const ORDER BY b,c</li></ol><h2 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h2><ul><li>查看是否开启及如何开启慢查询日志</li></ul><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 查看是否开启了慢查询日志</span><br>show variables like <span class="hljs-string">'%slow_query_log%'</span>;<br><br><span class="hljs-meta"># 开启慢查询日志（临时开启）</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p>如果要永久生效，就必须修改配置文件 my.cnf （其他系统变量也是如此）<br>修改 my.cnf 文件，[mysqld] 下增加或修改参数 slow_query_log 和 slow_query_log_file 后，然后重启 MySQL 服务器。</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">slow_query_log</span> = <span class="hljs-number">1</span> <br><span class="hljs-attr">slow_query_log_file</span> = /var/lib/mysql/slow-query.log<br></code></pre></td></tr></tbody></table></figure><p>慢查询日志是由参数 long_query_time 控制，默认情况下 long_query_time 的值为 10 秒，可以使用以下命令查看</p><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">'long_query_time%'</span>;<br></code></pre></td></tr></tbody></table></figure><p>可以使用命令修改，也可以在 my.cnf 参数里面修改。<br>假如运行时间正好等于 long_query_time 的情况，并不会被记录下来。也就是说，在 mysql 源码里是 <strong>判断大于 long_query_time，而非大于等于</strong></p><p>设置阙值到 3 秒钟的就是慢 sql</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> long_query_time = <span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>设置慢查询日志阙值后看不出变化？</p><ol><li>需要重新连接或新开一个会话才能看到修改值</li><li>或者直接使用以下命令也可以看到修改后的结果</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">'long_query_time'</span>;<br></code></pre></td></tr></tbody></table></figure><p>如何测试？</p><figure class="highlight autoit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 模拟查询超过 4 秒钟</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sleep</span>(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><p>查看慢查询日志中记录了有多少条慢 sql</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">'%Slow_queries%'</span>;<br></code></pre></td></tr></tbody></table></figure><h3 id="慢查询分析工具-mysqldumpslow"><a href="#慢查询分析工具-mysqldumpslow" class="headerlink" title="慢查询分析工具 mysqldumpslow"></a>慢查询分析工具 mysqldumpslow</h3><p>可用参数：</p><ul><li>s : 表示按照何种方式排序</li><li>c ：访问次数</li><li>l ：锁定时间</li><li>r ：返回记录</li><li>t ：查询时间</li><li>al ：平均锁定时间</li><li>ar ：平均返回记录数</li><li>at ：平均查询时间</li><li>t ：即返回前面多少条的数据</li><li>g ：后边搭配一个正则匹配模式，大小写不敏感的</li></ul><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 得到返回记录集最多的 10 条 sql<br>mysqldumpslow -s r -t 10 /<span class="hljs-keyword">var</span>/lib/mysql/slow-<span class="hljs-keyword">query</span>.<span class="hljs-keyword">log</span><br><br># 得到访问次数最多的 10 条 sql<br>mysqldumpslow -s c -t 10 /<span class="hljs-keyword">var</span>/lib/mysql/slow-<span class="hljs-keyword">query</span>.<span class="hljs-keyword">log</span><br><br># 得到按照时间排序的前 10 条里面包含左连接的查询语句<br>mysqldumpslow -s t -t 10 -<span class="hljs-keyword">g</span> <span class="hljs-string">"left join"</span> /<span class="hljs-keyword">var</span>/lib/mysql/slow-<span class="hljs-keyword">query</span>.<span class="hljs-keyword">log</span><br><br>另外建议在使用这些命令时结合 | 和 <span class="hljs-keyword">more</span> 使用，否则有可能出现爆屏情况<br>mysqldumpslow -s r -t 10 /<span class="hljs-keyword">var</span>/lib/mysql/slow-<span class="hljs-keyword">query</span>.<span class="hljs-keyword">log</span> | <span class="hljs-keyword">more</span><br></code></pre></td></tr></tbody></table></figure><h2 id="Show-Profile-（可以看到每一条-sql-执行的生命周期）"><a href="#Show-Profile-（可以看到每一条-sql-执行的生命周期）" class="headerlink" title="Show Profile （可以看到每一条 sql 执行的生命周期）"></a>Show Profile （可以看到每一条 sql 执行的生命周期）</h2><p>是 mysql 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于 sql 的调优的测量。<br>默认情况下，参数处于关闭状态，并保存最近 15 次的运行结果。</p><ol><li>查看是否已经开启</li></ol><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 查看是否已经开启</span><br><span class="hljs-attribute">show</span> VARIABLES like <span class="hljs-string">'profiling'</span>;<br><br><span class="hljs-comment"># 如果没有开启的话，则开启</span><br><span class="hljs-attribute">set</span> profiling = <span class="hljs-literal">on</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>运行各种查询语句</li><li>使用以下命令，即可看到以上的查询语句</li></ol><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">show profiles<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>诊断 sql</li></ol><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">show </span>profile cpu,<span class="hljs-keyword">block </span>io for query <span class="hljs-number">1</span><span class="hljs-comment">;（上一步问题 sql 前面的数字号码）</span><br></code></pre></td></tr></tbody></table></figure><p>show profile 的可用参数为：</p><ul><li>all ：显示所有的开销信息</li><li>block io ：显示块 io 相关开销</li><li>context switches ：上下文切换相关开销</li><li>cpu ：显示 cpu 相关开销信息</li><li>ipc ：显示发送和接收相关开销信息</li><li>memory ：显示内存相关开销信息</li><li>page faults ： 显示页面错误相关开销信息</li><li>source ：显示和 Source_function，Source_file，Source_line 相关的开销信息</li><li>swaps ：显示交换次数相关开销的信息</li></ul><h3 id="日常开发需要注意项"><a href="#日常开发需要注意项" class="headerlink" title="日常开发需要注意项"></a>日常开发需要注意项</h3><ol><li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li><li>Creating tmp table 创建临时表。（拷贝数据到临时表，用完再删除）</li><li>Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！</li><li>locked 锁表了</li></ol><h2 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h2><blockquote><p>永远不要在生产环境中开启这个功能！</p></blockquote><ul><li>在配置文件中开启<br>在 mysql 的 my.cnf 中，设置如下：</li></ul><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启</span><br><span class="hljs-attr">general_log</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 记录日志文件的路径</span><br><span class="hljs-attr">general_log_file</span> = /path/logfile<br><span class="hljs-comment"># 输出格式</span><br><span class="hljs-attr">log_output</span> = FILE<br></code></pre></td></tr></tbody></table></figure><ul><li>直接执行 sql 语句开启</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 开启</span><br><span class="hljs-built_in">set</span> global <span class="hljs-attribute">general_log</span>=1;<br><span class="hljs-comment"># 用表格的方式记录查询日志</span><br><span class="hljs-built_in">set</span> global log_output = <span class="hljs-string">'TABLE'</span>;<br><span class="hljs-comment"># 此后，你所编写的 sql 语句，将会记录到 mysql 库里的 general_log 表</span><br>select * <span class="hljs-keyword">from</span> mysql.general_log;<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 主从复制</title>
      <link href="/posts/6b30c31b.html"/>
      <url>/posts/6b30c31b.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h2><ul><li>主从复制原理</li></ul><p><img src="https://cdn.l2xy.com/post_img/mysql_img/mysql_slave.png" alt="主从复制原理"></p><ul><li>主从复制的基本原则</li></ul><ol><li> 每个 slave 只有一个 master</li><li> 每个 slave 只能有一个唯一的服务器 ID</li><li> 每个 master 可以有多个 salve</li></ol><h3 id="一主一从常见配置"><a href="#一主一从常见配置" class="headerlink" title="一主一从常见配置"></a>一主一从常见配置</h3><ul><li>mysql 版本一致且后台以服务运行</li><li>主从都配置在 [mysqld] 节点下，都是小写</li></ul><h4 id="主数据库配置，修改-etc-my-cnf-配置文件"><a href="#主数据库配置，修改-etc-my-cnf-配置文件" class="headerlink" title="主数据库配置，修改 /etc/my.cnf 配置文件"></a>主数据库配置，修改 /etc/my.cnf 配置文件</h4><ol><li>主服务器唯一 ID <strong>必须</strong></li></ol><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">server-id</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>启用二进制日志 <strong>必须</strong></li></ol><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># mysqlbin 为官方推荐的文件名</span><br><span class="hljs-attr">log-bin</span>=自己的本地路径/mysqlbin<br><br><span class="hljs-attr">log-bin</span>=/var/local/mysql-server5.<span class="hljs-number">7</span>/data/mysqlbin<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>启用错误日志 <strong>可选</strong></li></ol><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"># mysqlerr 为官方推荐的文件名<br><span class="hljs-keyword">log</span>-<span class="hljs-keyword">err</span>=自己的本地路径/mysqlerr<br><br><span class="hljs-keyword">log</span>-<span class="hljs-keyword">err</span>=/<span class="hljs-keyword">var</span>/<span class="hljs-keyword">local</span>/mysql-server5.7/data/mysqlerr<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>根目录 <strong>可选</strong></li></ol><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">basedir</span><span class="hljs-operator">=</span><span class="hljs-string">"自己的本地路径"</span><br><br><span class="hljs-attribute">basedir</span><span class="hljs-operator">=</span><span class="hljs-string">"/var/local/mysql-server5.7/"</span><br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>临时目录 <strong>可选</strong></li></ol><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">tmpdir</span><span class="hljs-operator">=</span><span class="hljs-string">"自己的本地路径"</span><br><br><span class="hljs-attribute">tmpdir</span><span class="hljs-operator">=</span><span class="hljs-string">"/var/local/mysql-server5.7/"</span><br></code></pre></td></tr></tbody></table></figure><ol start="6"><li>数据目录 <strong>可选</strong></li></ol><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">datadir</span><span class="hljs-operator">=</span><span class="hljs-string">"自己的本地路径"</span><br><br><span class="hljs-attribute">datadir</span><span class="hljs-operator">=</span><span class="hljs-string">"/var/local/mysql-server5.7/"</span><br></code></pre></td></tr></tbody></table></figure><ol start="7"><li>主机，读写都可以 <strong>可选</strong></li></ol><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">read-only</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><ol start="8"><li>设置不要复制的数据库 <strong>可选</strong></li></ol><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">binlog-ignore-db</span><span class="hljs-operator">=</span>mysql<br></code></pre></td></tr></tbody></table></figure><ol start="9"><li>设置需要复制的数据库 <strong>可选</strong></li></ol><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">binlog-do-db</span><span class="hljs-operator">=</span>需要复制的主数据库名字<br></code></pre></td></tr></tbody></table></figure><p>完整的配置为：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><br><span class="hljs-attr">port</span>=<span class="hljs-number">3306</span><br><br><span class="hljs-attr">server-id</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">log-bin</span>=/var/local/mysql-server5.<span class="hljs-number">7</span>/data/mysqlbin<br><span class="hljs-attr">log-err</span>=/var/local/mysql-server5.<span class="hljs-number">7</span>/data/mysqlerr<br><span class="hljs-attr">basedir</span>=<span class="hljs-string">"/var/local/mysql-server5.7/"</span><br><span class="hljs-attr">tmpdir</span>=<span class="hljs-string">"/var/local/mysql-server5.7/"</span><br><span class="hljs-attr">datadir</span>=<span class="hljs-string">"/var/local/mysql-server5.7/"</span><br><span class="hljs-attr">read-only</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">binlog-ignore-db</span>=mysql<br></code></pre></td></tr></tbody></table></figure><h4 id="从数据库配置，修改-etc-my-cnf-配置文件"><a href="#从数据库配置，修改-etc-my-cnf-配置文件" class="headerlink" title="从数据库配置，修改 /etc/my.cnf 配置文件"></a>从数据库配置，修改 /etc/my.cnf 配置文件</h4><ol><li>从服务器唯一 ID <strong>必须</strong></li></ol><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 默认配置文件中将此行注释掉了，可以直接取消注释即可，如果没有找到，也可以自己添加</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>启用二进制日志 <strong>必须</strong></li></ol><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 默认配置文件中将此行注释掉了，可以直接取消注释即可，如果没有找到，也可以自己添加</span><br><br><span class="hljs-attr">log-bin</span>=mysql-bin<br></code></pre></td></tr></tbody></table></figure><ul><li>主从机器都关闭掉防火墙</li><li>在主数据库上建立账户并授权 slave</li></ul><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 从数据库用于拷贝的账号为：alex</span><br><span class="hljs-comment"># 从数据库用于拷贝的密码为：123456</span><br><span class="hljs-comment"># 从数据库所在服务器的 ip 地址为：127.0.0.12</span><br><br><span class="hljs-attribute">grant</span> replication slave <span class="hljs-literal">on</span> *.* to <span class="hljs-string">'alex'</span>@<span class="hljs-string">'127.0.0.12'</span> identified by <span class="hljs-string">'123456'</span>;<br><br><span class="hljs-comment"># 刷新权限</span><br><span class="hljs-attribute">flush</span> privileges;<br><br><span class="hljs-comment"># 查询 master 的状态，并记录下 File 和 Position 的值</span><br><span class="hljs-attribute">show</span> master status;<br></code></pre></td></tr></tbody></table></figure><ul><li>在从数据库上配置</li></ul><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 主数据库所在服务器的 ip 地址为：127.0.0.1</span><br><span class="hljs-comment"># 在主数据库建立用于从数据库拷贝的账号为：alex</span><br><span class="hljs-comment"># 在主数据库建立用于从数据库拷贝的密码为：123456</span><br><span class="hljs-comment"># 主数据库中查询出的 File 值为：mysqlbin.000035</span><br><span class="hljs-comment"># 主数据库中查询出的 Position 的值为：341</span><br><br><span class="hljs-attribute">change</span> master to master_host=<span class="hljs-string">'127.0.0.1'</span>, master_user=<span class="hljs-string">'alex'</span>,master_password=<span class="hljs-string">'123456'</span>,master_log_file=<span class="hljs-string">'mysqlbin.000035'</span>,master_log_pos=<span class="hljs-number">341</span>;<br> <br><span class="hljs-comment"># 启动从服务器复制功能</span><br><span class="hljs-attribute">start</span> slave;<br><br><span class="hljs-comment"># 执行以下命令，当 Slave_IO_Running: Yes 和 Slave_SQL_Running: Yes 同时为 yes 时，表示主从复制已经打通了</span><br><span class="hljs-attribute">show</span> slave status\G<br></code></pre></td></tr></tbody></table></figure><ul><li><p>测试主从复制是否成功？</p><ul><li>主数据库新建一个库、新建表、插入一条记录，从数据库去查询是否含有以上数据即可</li></ul></li><li><p>如何停止从数据库复制功能？</p></li></ul><figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 从数据库上</span><br><span class="hljs-literal">stop</span> <span class="hljs-literal">slave</span>;<br></code></pre></td></tr></tbody></table></figure><ul><li>当 Slave_IO_Running 和 Slave_SQL_Running 参数不同时为 yes 时？</li></ul><figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 先停止从数据库复制功能（从数据库上执行）</span><br><span class="hljs-literal">stop</span> <span class="hljs-literal">slave</span>;<br><br><span class="hljs-comment"># 查询 master 的状态，并记录下 File 和 Position 的值 （主数据库上执行，这次会有新的 File 值和 Position 值）</span><br>show <span class="hljs-keyword">master</span> <span class="hljs-title">status</span>;<br><br>change <span class="hljs-keyword">master</span> <span class="hljs-title">to</span> <span class="hljs-attr">master_host=</span>'主数据库所在服务器的 ip 地址', <span class="hljs-attr">master_user=</span>'alex',<span class="hljs-attr">master_password=</span>'<span class="hljs-number">123456</span>',<span class="hljs-attr">master_log_file=</span>'新的 File 值',<span class="hljs-attr">master_log_pos=</span>新的Position 值;<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 主从复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.4 64位 搭建 LAMP</title>
      <link href="/posts/241df954.html"/>
      <url>/posts/241df954.html</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS-7-4-64位-搭建LAMP"><a href="#CentOS-7-4-64位-搭建LAMP" class="headerlink" title="CentOS 7.4 64位 搭建LAMP"></a>CentOS 7.4 64位 搭建LAMP</h1><ul><li><h2 id="安装php7-2"><a href="#安装php7-2" class="headerlink" title="安装php7.2"></a>安装php7.2</h2>若直接采用centos中的yum安装：sudo yum -y install php，版本是5.4，远远不够，因此我们要手动更新rpm即可。</li></ul><h3 id="1-首先获取-rpm-（添加-php-的-yum-仓库-）："><a href="#1-首先获取-rpm-（添加-php-的-yum-仓库-）：" class="headerlink" title="1. 首先获取 rpm （添加 php 的 yum 仓库 ）："></a>1. 首先获取 rpm （添加 php 的 yum 仓库 ）：</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm   <br>rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm    <br></code></pre></td></tr></tbody></table></figure><p>然后可以利用 sudo yum list php* 查看目前都有 php 的什么版本了，可以发现从 4-7.2 的版本都有，7.2 版本名为 72w，因此安装该版本即可：</p><h3 id="2-安装-php7-2"><a href="#2-安装-php7-2" class="headerlink" title="2. 安装 php7.2"></a>2. 安装 php7.2</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum -y install php72w<br></code></pre></td></tr></tbody></table></figure><p>但安装完毕后，输入 <code>php -v</code> 发现并没有该命令，因为 php72w 只是安装了 php 最小的库，一些应用还未安装，因此安装一些拓展包即可：</p><h3 id="3-安装-php7-2-其它扩展（安装过程中全部选-yes-即可）"><a href="#3-安装-php7-2-其它扩展（安装过程中全部选-yes-即可）" class="headerlink" title="3. 安装 php7.2 其它扩展（安装过程中全部选 yes 即可）"></a>3. 安装 php7.2 其它扩展（安装过程中全部选 yes 即可）</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 以下扩展中有部分和上面的扩展重复，安装的时候请注意区分</span><br><br>sudo yum install php72w.x86_64 php72w-cli.x86_64 php72w-common.x86_64 php72w-gd.x86_64 php72w-ldap.x86_64 php72w-mbstring.x86_64 php72w-mcrypt.x86_64 php72w-mysql.x86_64 php72w-pdo.x86_64 php72w-devel.x86_64<br></code></pre></td></tr></tbody></table></figure><h3 id="4-安装-PHP-7-2-的-fpm"><a href="#4-安装-PHP-7-2-的-fpm" class="headerlink" title="4. 安装 PHP 7.2 的 fpm"></a>4. 安装 PHP 7.2 的 fpm</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install php72w-fpm.x86_64<br></code></pre></td></tr></tbody></table></figure><ul><li><h2 id="安装-MySQL5-7-或-MySQL5-6"><a href="#安装-MySQL5-7-或-MySQL5-6" class="headerlink" title="安装 MySQL5.7 或 MySQL5.6"></a>安装 MySQL5.7 或 MySQL5.6</h2></li></ul><h3 id="1-配置-YUM-源"><a href="#1-配置-YUM-源" class="headerlink" title="1. 配置 YUM 源"></a>1. 配置 YUM 源</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm<br><br>sudo yum localinstall mysql57-community-release-el7-8.noarch.rpm<br><br><span class="hljs-comment"># 检查 mysql 源是否安装成功</span><br>yum repolist enabled | grep <span class="hljs-string">"mysql.*-community.*"</span><br></code></pre></td></tr></tbody></table></figure><h3 id="2-修改安装-mysql-版本配置（现在默认安装是-mysql5-7）"><a href="#2-修改安装-mysql-版本配置（现在默认安装是-mysql5-7）" class="headerlink" title="2. 修改安装 mysql 版本配置（现在默认安装是 mysql5.7）"></a>2. 修改安装 mysql 版本配置（现在默认安装是 mysql5.7）</h3><p>可以修改 <code>vim /etc/yum.repos.d/mysql-community.repo</code>  源，改变默认安装的 mysql 版本。比如要安装 5.7 版本，将 5.6 源的 <code>enabled=1</code> 改成 <code>enabled=0</code> 。然后再将 5.7 源的 <code>enabled=0</code> 改成 <code>enabled=1</code> 即可。改完之后的效果如下所示：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh">15 <span class="hljs-comment"># Enable to use MySQL 5.5</span><br>16 [mysql55-community]<br>17 name=MySQL 5.5 Community Server<br>18 baseurl=http://repo.mysql.com/yum/mysql-5.5-community/el/7/<span class="hljs-variable">$basearch</span>/<br>19 enabled=0<br>20 gpgcheck=1<br>21 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql<br>22 <br>23 <span class="hljs-comment"># Enable to use MySQL 5.6</span><br>24 [mysql56-community]<br>25 name=MySQL 5.6 Community Server<br>26 baseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/7/<span class="hljs-variable">$basearch</span>/<br>27 enabled=0<br>28 gpgcheck=1<br>29 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql<br>30 <br>31 [mysql57-community]<br>32 name=MySQL 5.7 Community Server<br>33 baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/<span class="hljs-variable">$basearch</span>/<br>34 enabled=1<br>35 gpgcheck=1<br>36 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql<br></code></pre></td></tr></tbody></table></figure><h3 id="3-安装-MySQL"><a href="#3-安装-MySQL" class="headerlink" title="3. 安装 MySQL"></a>3. 安装 MySQL</h3> <figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install mysql-community-server<br></code></pre></td></tr></tbody></table></figure><h3 id="4-启动-MySQL"><a href="#4-启动-MySQL" class="headerlink" title="4. 启动 MySQL"></a>4. 启动 MySQL</h3> <figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl start mysqld<br></code></pre></td></tr></tbody></table></figure><h3 id="5-配置开机启动"><a href="#5-配置开机启动" class="headerlink" title="5. 配置开机启动"></a>5. 配置开机启动</h3> <figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl <span class="hljs-built_in">enable</span> mysqld<br>systemctl daemon-reload<br></code></pre></td></tr></tbody></table></figure><h3 id="6-修改-root-本地登录密码"><a href="#6-修改-root-本地登录密码" class="headerlink" title="6. 修改 root 本地登录密码"></a>6. 修改 root 本地登录密码</h3><p>mysql 安装完成之后，在 /var/log/mysqld.log 文件中给 root 生成了一个默认密码。通过下面的方式找到 root 默认密码，然后登录 mysql 进行修改：</p> <figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"> <span class="hljs-comment"># 查找默认生成的密码</span><br> grep <span class="hljs-string">'temporary password'</span> /var/log/mysqld.log<br> <br> <span class="hljs-comment"># 用默认生成的密码登录 mysql</span><br> mysql -uroot -p<br> <br> <span class="hljs-comment"># 修改新密码为 MyNewPass4! </span><br> <span class="hljs-comment"># 用这种方式修改密码的时候需要把密码修改的稍微复杂一点，不然老是提示你创建的密码不安全</span><br>ALTER USER <span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span> IDENTIFIED BY <span class="hljs-string">'MyNewPass4!'</span>;<br></code></pre></td></tr></tbody></table></figure><h3 id="7-配置默认编码为-utf8"><a href="#7-配置默认编码为-utf8" class="headerlink" title="7. 配置默认编码为 utf8"></a>7. 配置默认编码为 utf8</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 直接命令行下敲命令，不需要登录 mysql 之后</span><br>character_set_server=utf8<br>init_connect=<span class="hljs-string">'SET NAMES utf8'</span><br></code></pre></td></tr></tbody></table></figure><ul><li><h2 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h2></li></ul><h3 id="1-安装-httpd"><a href="#1-安装-httpd" class="headerlink" title="1. 安装 httpd"></a>1. 安装 httpd</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum -y install httpd<br></code></pre></td></tr></tbody></table></figure><h3 id="2-修改-apache-配置文件"><a href="#2-修改-apache-配置文件" class="headerlink" title="2. 修改 apache 配置文件"></a>2. 修改 apache 配置文件</h3><p>主配置文件的路径为 /etc/httpd/conf/httpd.conf<br>扩展配置文件路径为 /etc/httpd/conf.d/*.conf</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/httpd/conf.d/sample.conf<br><br><span class="hljs-comment"># 配置文件编写如下</span><br><br> &lt;VirtualHost *:80&gt;<br>   <span class="hljs-comment"># 项目文件目录，默认项目目录在 /var/www/html/ 下</span><br>   DocumentRoot /var/www/html/sample/public<br>   <span class="hljs-comment"># 虚拟域名</span><br>   ServerName test.drling.xin<br>   <span class="hljs-comment"># 多个虚拟域名</span><br>   ServerAlias sample.drling.xin<br>   <span class="hljs-comment"># 如果还需要配置第三个虚拟域名</span><br>   ServerAlias www.drling.xin<br>   <span class="hljs-comment"># 错误日志目录</span><br>   ErrorLog /var/log/httpd/sample-error_log<br>   <span class="hljs-comment"># 访问日志目录</span><br>   Customlog /var/log/httpd/sample-access_log common<br> &lt;/VirtualHost&gt;<br></code></pre></td></tr></tbody></table></figure><h3 id="3-启动-httpd"><a href="#3-启动-httpd" class="headerlink" title="3. 启动 httpd"></a>3. 启动 httpd</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 开启/重启/停止/状态</span><br>systemctl start/restart/stop/status httpd <br><br><span class="hljs-comment"># 开机启动 httpd</span><br>systemctl <span class="hljs-built_in">enable</span> httpd<br></code></pre></td></tr></tbody></table></figure><p><strong>以下步骤我搭建服务器的时候没有操作，发现项目也运行起来了</strong></p><h3 id="4-修改-httpd-conf-配置"><a href="#4-修改-httpd-conf-配置" class="headerlink" title="4. 修改 httpd.conf 配置"></a>4. 修改 httpd.conf 配置</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># line 86: 改变管理员的邮箱地址</span><br>ServerAdmin root@linuxprobe.org<br><span class="hljs-comment"># line 95: 改变域名信息</span><br>ServerName www.linuxprobe.org:80<br><span class="hljs-comment"># line 151: none变成All</span><br>AllowOverride All<br><span class="hljs-comment"># line 164: 添加只能使用目录名称访问的文件名</span><br>DirectoryIndex index.html index.cgi index.php<br><span class="hljs-comment"># add follows to the end</span><br><span class="hljs-comment"># server's response header（安全性）</span><br>ServerTokens Prod<br><span class="hljs-comment"># keepalive is ON</span><br>KeepAlive On<br></code></pre></td></tr></tbody></table></figure><h3 id="5-修改防火墙配置"><a href="#5-修改防火墙配置" class="headerlink" title="5. 修改防火墙配置"></a>5. 修改防火墙配置</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">如果 Firewalld 正在运行，请允许 HTTP 服务。HTTP 使用 80/TCP<br>firewall-cmd --add-service=http --permanent<br>firewall-cmd --reload<br></code></pre></td></tr></tbody></table></figure><h3 id="6-运行-tp5-项目的时候提示没有写-session-的权限，默认-session-文件夹如下"><a href="#6-运行-tp5-项目的时候提示没有写-session-的权限，默认-session-文件夹如下" class="headerlink" title="6. 运行 tp5 项目的时候提示没有写 session 的权限，默认 session 文件夹如下"></a>6. 运行 tp5 项目的时候提示没有写 session 的权限，默认 session 文件夹如下</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># session 文件夹路径： /var/lib/php/session/</span><br><br><span class="hljs-comment"># 给最大权限 </span><br><span class="hljs-built_in">chmod</span> 0777 -R /var/lib/php/session<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> LAMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.4 64位 编译安装 LNMP</title>
      <link href="/posts/2ccaa736.html"/>
      <url>/posts/2ccaa736.html</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS-7-4-64位-编译安装-LNMP"><a href="#CentOS-7-4-64位-编译安装-LNMP" class="headerlink" title="CentOS 7.4 64位 编译安装 LNMP"></a>CentOS 7.4 64位 编译安装 LNMP</h1><h2 id="查看-Linux-版本"><a href="#查看-Linux-版本" class="headerlink" title="查看 Linux 版本"></a>查看 Linux 版本</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/redhat-release<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CentOS Linux release 7.4.1708 (Core)</span><br></code></pre></td></tr></tbody></table></figure><h2 id="1-安装-nginx"><a href="#1-安装-nginx" class="headerlink" title="1. 安装 nginx"></a>1. 安装 nginx</h2><p>1-1. 安装 nginx 源</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum localinstall http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm<br></code></pre></td></tr></tbody></table></figure><p>1-2. 安装 nginx</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install nginx<br></code></pre></td></tr></tbody></table></figure><p>1-3. 启动 nginx</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start nginx<br></code></pre></td></tr></tbody></table></figure><h2 id="2-安装-MySQL"><a href="#2-安装-MySQL" class="headerlink" title="2. 安装 MySQL"></a>2. 安装 MySQL</h2><p>2-1. 安装 MySQL 源</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum localinstall  http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm<br></code></pre></td></tr></tbody></table></figure><p>2-2. 安装 MySQL</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install mysql-community-server<br></code></pre></td></tr></tbody></table></figure><p>安装 MySQL 开发包 （*）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install mysql-community-devel<br></code></pre></td></tr></tbody></table></figure><p>2-3. 启动 MySQL</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start mysqld<br></code></pre></td></tr></tbody></table></figure><p>2-4. 查看 MySQL 是否启动</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status mysqld<br></code></pre></td></tr></tbody></table></figure><p>2-5. 查看 MySQL 默认密码</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首次启动,会把密码放在 /var/log/mysqld.log 里面</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2018-10-13T15:51:47.482124Z 1 [Note] A temporary password is generated <span class="hljs-keyword">for</span> root@localhost: r)eS,gjku4ts</span><br><br>grep 'temporary password' /var/log/mysqld.log<br></code></pre></td></tr></tbody></table></figure><p>2-6. 更改 MySQL 密码</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">01、登入数据库</span><br>mysql -u root -p <br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入密码</span><br>r)eS,gjku4ts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里的密码 r)eS,gjku4ts 是从以上 mysqld.log 中查询出来的</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">02、修改 root 账号密码 （密码安全级别要稍微高一点，不然更新不会成功）</span><br>ALTER USER 'root'@'localhost' IDENTIFIED BY 'QAZwsx123!@#';<br></code></pre></td></tr></tbody></table></figure><p>2-7. 将 root 用户更改为外网也可以访问</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">01、打开 mysql 数据表</span><br>use mysql;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">02、查看 mysql 数据表中数据</span><br>select user,host from user;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">03、 % 代表任何 ip 都能访问</span><br>UPDATE user SET host = '%' WHERE user = 'root';<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">04、再次查看 mysql 数据表中的数据</span><br>select user,host from user;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">05、刷新权限</span><br>flush privileges;<br></code></pre></td></tr></tbody></table></figure><p>2-8. 新建一个用户并且赋予权限（因为 root 用户开放外面使用毕竟不安全）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">01、新建 mysql 账户</span><br><br>grant all privileges on *.* to  alex@"%" identified by "QAZwsx123!@#" with grant option;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">grant 是授权命令，其中 alex 是我们连接用的用户名、<span class="hljs-string">"AZwsx123!@#"</span>是连接密码，用户名后面的 <span class="hljs-string">"%"</span> 通用符表示允许各 host 操作。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面这条命令是指</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动创建用户 alex ,密码 AZwsx123!@<span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式：grant 权限 on 数据库名.表名 to 用户@登录主机 identified by <span class="hljs-string">"用户密码"</span>;</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">@ 后面是访问mysql的客户端IP地址（或是 主机名） % 代表任意的客户端，如果填写 localhost 为本地访问（那此用户就不能远程访问该mysql数据库了）。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">02、刷新权限</span><br>flush privileges;<br></code></pre></td></tr></tbody></table></figure><h2 id="3-编译安装-php7-2"><a href="#3-编译安装-php7-2" class="headerlink" title="3. 编译安装 php7.2"></a>3. 编译安装 php7.2</h2><p>3-1. 下载安装包，一般情况下,我们都会下载到 /usr/local/src 下面</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">01、进入 src 目录</span><br>cd /usr/local/src<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">02、下载 php7.2 源码包</span><br>wget -O php72.tar.gz http://cn2.php.net/get/php-7.2.0.tar.gz/from/this/mirror<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">03、解压安装包</span><br>tar -zxvf php72.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">04、进入解压后的包</span><br>cd php-7.2.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">05、安装 php 的依赖</span><br>yum install libxml2 libxml2-devel openssl openssl-devel bzip2 bzip2-devel libcurl libcurl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel gmp gmp-devel libmcrypt libmcrypt-devel readline readline-devel libxslt libxslt-devel<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">06、新建 php 这个文件夹（编译配置会用到）</span><br>mkdir -p /usr/local/php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">07、编译配置</span><br>./configure \<br>--prefix=/usr/local/php \<br>--with-config-file-path=/etc \<br>--enable-fpm \<br>--with-fpm-user=nginx  \<br>--with-fpm-group=nginx \<br>--enable-inline-optimization \<br>--disable-debug \<br>--disable-rpath \<br>--enable-shared  \<br>--enable-soap \<br>--with-libxml-dir \<br>--with-xmlrpc \<br>--with-openssl \<br>--with-mcrypt \<br>--with-mhash \<br>--with-pcre-regex \<br>--with-sqlite3 \<br>--with-zlib \<br>--enable-bcmath \<br>--with-iconv \<br>--with-bz2 \<br>--enable-calendar \<br>--with-curl \<br>--with-cdb \<br>--enable-dom \<br>--enable-exif \<br>--enable-fileinfo \<br>--enable-filter \<br>--with-pcre-dir \<br>--enable-ftp \<br>--with-gd \<br>--with-openssl-dir \<br>--with-jpeg-dir \<br>--with-png-dir \<br>--with-zlib-dir  \<br>--with-freetype-dir \<br>--enable-gd-native-ttf \<br>--enable-gd-jis-conv \<br>--with-gettext \<br>--with-gmp \<br>--with-mhash \<br>--enable-json \<br>--enable-mbstring \<br>--enable-mbregex \<br>--enable-mbregex-backtrack \<br>--with-libmbfl \<br>--with-onig \<br>--enable-pdo \<br>--with-mysqli=mysqlnd \<br>--with-pdo-mysql=mysqlnd \<br>--with-zlib-dir \<br>--with-pdo-sqlite \<br>--with-readline \<br>--enable-session \<br>--enable-shmop \<br>--enable-simplexml \<br>--enable-sockets  \<br>--enable-sysvmsg \<br>--enable-sysvsem \<br>--enable-sysvshm \<br>--enable-wddx \<br>--with-libxml-dir \<br>--with-xsl \<br>--enable-zip \<br>--enable-mysqlnd-compression-support \<br>--with-pear \<br>--enable-opcache<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">08、编译与安装 （此处需要时间，耐心等待）</span><br>make &amp;&amp; make install<br></code></pre></td></tr></tbody></table></figure><p>3-2. 到这里已经算是安装完成了，查看 php 版本，就会出现熟悉的php 7.2.0 xxxxxx</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 php 版本</span><br>/usr/local/php/bin/php -v<br></code></pre></td></tr></tbody></table></figure><p>3-3. 但是这样,我们没有添加环境变量,太麻烦了,接下来把 php 放到环境变量里面</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">01、打开文件</span><br>vim /etc/profile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">02、在 profile 文件最底部加入</span><br>PATH=$PATH:/usr/local/php/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">03、让修改立即生效</span><br>source /etc/profile  或者  ./etc/profile<br></code></pre></td></tr></tbody></table></figure><p>3-3. 此时我们查看 PHP 版本 php -v 就行了</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将php.ini复制到/etc/下面</span><br>cp php.ini-production /etc/php.ini<br><br>cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf<br><br>cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf<br><br>cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm<br><br>chmod +x /etc/init.d/php-fpm<br><br></code></pre></td></tr></tbody></table></figure><p>3-4. 启动 php-fpm</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/etc/init.d/php-fpm start<br></code></pre></td></tr></tbody></table></figure><h2 id="4-配置-nginx-，使得-nginx-能够解析-php"><a href="#4-配置-nginx-，使得-nginx-能够解析-php" class="headerlink" title="4. 配置 nginx ，使得 nginx 能够解析 php"></a>4. 配置 nginx ，使得 nginx 能够解析 php</h2><p>4-1. 打开 nginx 配置文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/nginx/conf.d/default.conf<br></code></pre></td></tr></tbody></table></figure><p>默认配置文件中的内容如下：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><br> 1 <span class="hljs-section">server</span> {<br> 2     <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br> 3     <span class="hljs-attribute">server_name</span>  localhost;<br> 4 <br> 5     <span class="hljs-comment">#charset koi8-r;</span><br> 6     <span class="hljs-comment">#access_log  /var/log/nginx/host.access.log  main;</span><br> 7 <br> 8     <span class="hljs-section">location</span> / {<br> 9         <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>10         <span class="hljs-attribute">index</span>  index.html index.htm;<br>11     }<br>12 <br>13     <span class="hljs-comment">#error_page  404              /404.html;</span><br>14 <br>15     <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>16     <span class="hljs-comment">#</span><br>17     <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>18     <span class="hljs-section">location</span> = /50x.html {<br>19         <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>20     }<br>21 <br>22     <span class="hljs-comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br>23     <span class="hljs-comment">#</span><br>24     <span class="hljs-comment">#location ~ \.php$ {</span><br>25     <span class="hljs-comment">#    proxy_pass   http://127.0.0.1;</span><br>26     <span class="hljs-comment">#}</span><br>27 <br>28     <span class="hljs-comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br>29     <span class="hljs-comment">#</span><br>30     <span class="hljs-comment">#location ~ \.php$ {</span><br>31     <span class="hljs-comment">#    root           html;</span><br>32     <span class="hljs-comment">#    fastcgi_pass   127.0.0.1:9000;</span><br>33     <span class="hljs-comment">#    fastcgi_index  index.php;</span><br>34     <span class="hljs-comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br>35     <span class="hljs-comment">#    include        fastcgi_params;</span><br>36     <span class="hljs-comment">#}</span><br>37 <br>38     <span class="hljs-comment"># deny access to .htaccess files, if Apache's document root</span><br>39     <span class="hljs-comment"># concurs with nginx's one</span><br>40     <span class="hljs-comment">#</span><br>41     <span class="hljs-comment">#location ~ /\.ht {</span><br>42     <span class="hljs-comment">#    deny  all;</span><br>43     <span class="hljs-comment">#}</span><br>44 }<br></code></pre></td></tr></tbody></table></figure><p>4-2. 复制 nginx 默认配置文件 default.conf ，写自定义配置文件 <code>www.drling.xin.conf</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/www.drling.xin.conf<br></code></pre></td></tr></tbody></table></figure><p>4-3. 将以下内容写进 <code>www.drling.xin.conf</code> 配置文件中去</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><br><span class="hljs-section">server</span> {<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  www.drling.xin;<br><br><br>    <span class="hljs-section">location</span> / {<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>        <span class="hljs-attribute">index</span> index.php index.html index.htm;<br>    }<br><br><br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ \.php$</span> {<br>        <span class="hljs-attribute">root</span>           /usr/share/nginx/html;<br>        <span class="hljs-attribute">fastcgi_pass</span>   <span class="hljs-number">127.0.0.1:9000</span>;<br>        <span class="hljs-attribute">fastcgi_index</span>  index.php;<br>        <span class="hljs-comment">#fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br>        <span class="hljs-attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="hljs-variable">$document_root</span><span class="hljs-variable">$fastcgi_script_name</span>;<br>        <span class="hljs-attribute">include</span>        fastcgi_params;<br>    }<br><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>4-4. 查看 nginx 配置写入是否正确</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -t<br></code></pre></td></tr></tbody></table></figure><p>4-5. 重启 nginx</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart nginx<br></code></pre></td></tr></tbody></table></figure><p>4-6. 在 <code>/usr/share/nginx/html</code> 下面新建一个 index.php 文件，写入以下内容</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?</span><br><span class="hljs-title function_ invoke__">phpinfo</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>4-7. 在浏览器中访问配置文件中 server_name 后写的域名，就可以看到 phpinfo 信息了，我这里是直接在浏览器中访问 <code>www.drling.xin</code></p><p>4-8. 后续</p><p>这里提供 tp5 的 nginx 配置文件写法</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><br><span class="hljs-section">server</span> {<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  www.drling.xin;<br>    <span class="hljs-attribute">access_log</span>    /var/log/nginx/www.drling.xin_access.log;<br>    <span class="hljs-attribute">error_log</span>    /var/log/nginx/www.drling.xin_error.log;<br><br>    <span class="hljs-section">location</span> / {<br><br>        <span class="hljs-attribute">root</span>   /var/www/my_cake_test/public;<br><br>        <span class="hljs-attribute">index</span> index.php index.html index.htm;<br><br>        <span class="hljs-attribute">if</span> (!-e <span class="hljs-variable">$request_filename</span>) {<br>                <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)$</span> /index.php?s=<span class="hljs-variable">$1</span> <span class="hljs-literal">last</span>;<br>                break;<br>        }<br>        <br>    }<br>    <br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ \.php$</span> {<br>        <span class="hljs-attribute">root</span>           /var/www/my_cake_test/public;<br>        <span class="hljs-attribute">fastcgi_pass</span>   <span class="hljs-number">127.0.0.1:9000</span>;<br>        <span class="hljs-attribute">fastcgi_index</span>  index.php;<br>        <span class="hljs-comment">#fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br>        <span class="hljs-attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="hljs-variable">$document_root</span><span class="hljs-variable">$fastcgi_script_name</span>;<br>        <span class="hljs-attribute">include</span>        fastcgi_params;<br>    }<br><br><br>}<br><br></code></pre></td></tr></tbody></table></figure><p>以下为 laravel5.5 的 nginx 配置文件写法</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><br><span class="hljs-section">server</span> {<br><br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  sample.drling.xin;<br>    <span class="hljs-attribute">access_log</span>    /var/log/nginx/sample.drling.xin_access.log;<br>    <span class="hljs-attribute">error_log</span>    /var/log/nginx/sample.drling.xin_error.log;<br>    <span class="hljs-attribute">root</span>   /var/www/sample/public;<br>    <span class="hljs-attribute">index</span> index.php index.html index.htm;<br><br>    <span class="hljs-section">location</span> / {<br>        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.php?<span class="hljs-variable">$query_string</span>;<br>    }   <br><br>        <br>        <br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ \.php$</span> {<br>        <span class="hljs-attribute">root</span>           /var/www/sample/public;<br>        <span class="hljs-attribute">fastcgi_pass</span>   <span class="hljs-number">127.0.0.1:9000</span>;<br>        <span class="hljs-attribute">fastcgi_index</span>  index.php;<br>        <span class="hljs-comment">#fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br>        <span class="hljs-attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="hljs-variable">$document_root</span><span class="hljs-variable">$fastcgi_script_name</span>;<br>        <span class="hljs-attribute">include</span>        fastcgi_params;<br>    }<br><br><br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> LNMP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
